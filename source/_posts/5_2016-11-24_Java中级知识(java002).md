---
title: Java提升1
date: 2016-11-24
top: 5
categories: [后端]
tags: [java,提升]
description: "极客学院web工程师java中级知识总结笔记。"
cover_picture: http://oss.willhappy.cn/hexo/cover_pic/cover_picture_5.jpg

---

<!--more-->

[toc]

### 一.WebService入门
1. Java中的xml操作
    - XML和HTML区别
    1. XML被设计为传输和存储数据，其焦点是数据的内容
    2. HTML被设计用来显示数据，起焦点是数据的外观
    3. HTML旨在显示信息，而XML旨在传输信息

    - 使用java读取XML文件
实例：

```java
public class ReadXML {
    public static void main(String[] args) {

        try {
            //dom解析xml文件
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            DocumentBuilder builder = factory.newDocumentBuilder();
            Document document = builder.parse(new File("Java01/languages.xml"));
            Element root = document.getDocumentElement();
            System.out.println("cat=" + root.getAttribute("cat"));
            NodeList list = root.getElementsByTagName("lan");
            for (int i = 0; i < list.getLength(); i++) {
                Element lan = (Element) list.item(i);
                System.out.println("===============");
                System.out.println("id=" + lan.getAttribute("id"));

//                Element name = (Element) lan.getElementsByTagName("name").item(0);
//                System.out.println("name="+name.getTextContent());
                NodeList cList = lan.getChildNodes();
                for (int j = 0; j < cList.getLength(); j++) {
                    Node c = cList.item(j);
                    if (c instanceof Element) {
                        System.out.println(c.getNodeName() + "=" + c.getTextContent());
                    }

                }
            }
        } catch (ParserConfigurationException e) {
            e.printStackTrace();
        } catch (SAXException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

languages.xml文件：

```xml
<?xml version="1.0" encoding="utf-8" ?>
<languages cat="it">
    <lan id="1">
        <name>java</name>
        <ide>IntelliJ IDEA</ide>
    </lan>
    <lan id="2">
        <name>swift</name>
        <ide>Xcode</ide>
    </lan>
    <lan id="3">
        <name>C#</name>
        <ide>Visual Studio</ide>
    </lan>
</languages>
```

-  使用java创建xml数据
-  使用dom4j操作xml数据

<br>
2. java中的JSON操作

- JSON数据格式简介

    json是存储和交换文本信息的语法。
    1. json是轻量级的文本数据交换格式
    2. json独立于语言和平台
    3. json具有自我描述性，更易理解

- 使用java读取json数据

使用gson的jar包来读取json

- 使用java创建json数据

### 二. Spring
1. spring入门
    a. 简介：spring是一个轻量级控制反转（ioc）和面向切面（aop）的容器框架，它主要是为了解解决企业应用开发的复杂性而诞生的
    b. 优势：
    - 它定位的领域是许多其他流行的framework没有的
    - spring是全面的和模块化的
    - 他的设计从底部帮助你编写易于测试的代码
    - spring是潜在的一站式解决方案

    c. 优点：
    - 低侵入式设计，代码污染极低
    - write Once,Run Anywhere
    - DI有效的降低了耦合度
    - AOP提供了通用任务的集中管理
    - ORM和DAO简化了对数据库访问
    - 高度开放性，并不强制

2. spring之IOC

a. 浅谈IOC
IOC（Inversion of Control，控制反转）是spring的核心，贯穿始终。所谓IOC，对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系：
- 传统开发模式：对象之间互相依赖（像找对象，自己需要什么样的对象，按自己的标准去找，完全由自己来做，来筛选）
- IOC开发模式：IOC容器安排对象之间的依赖（像有一个婚姻介绍所，会收集所有的男女对象，你需要什么样的对象，只需要提交给他，他会帮你筛选，你只需要谈恋爱就行了，其他的交个婚介就可以了）

b. IOC理论背景
![SpringIOC][1]

c. IOC通俗的理解如下：
- IOC控制反转：说的是创建对象实例的控制权从代码控制剥离到IOC容器控制，实际就是你在xml文件控制，侧重原理
- DI依赖注入：说的是创建对象实例时，为这个对象注入属性值或其他对象实例，侧重于实现。
- ioc比如有一个类，在类里面有方法（不是静态的方法），调用类里面的方法，创建类的对象，使用对象调用方法，创建类对象的过程，需要new出来对象
- 把对象的创建不是通过new方式实现，而是交给spring配置创建类对象

3. spring之AOP
    a. AOP图解

![SpringAOP][2]

面向切面的编程，扩展功能不是修改源代码实现

4. springIOC容器深入理解
    a. IOC概念
    b. Java反射机制
    - ClassLoader工作机制

        1. 装载：查找和导入Class文件
        2. 链接：执行校验，准备和解析步骤
        3. 初始化：对垒的静态变量、静态代码块执行初始化工作

    c. 资源访问工具类
    d. BeanFactory和ApplicationContext的介绍
    e. Bean的生命周期

5. spring的配置文件
    a. spring容器高层视图
    - spring容器启动基本条件：

    1. spring的框架类包
    2. bean的配置文件
    3. bean的实现类
    - bean的元数据信息：

    1. bean的实现类
    2. bean的属性信息
    3. bean的依赖关系
    4. bean的行为配置
    5. bean的创建方式

    ![Spring高层视图][3]

---

传智播客spring框架2016版 笔记记录

### 一. Spring概念（传智播客笔记）

1. spring是开源的轻量级框架
2. spring核心主要两部分：
- aop：面向切面编程，扩展功能不是修改源代码实现
- ioc：控制反转
（1） 比如有一个类，在类里面有方法（不是静态的方法），调用类里面的方法，创建类的对象，使用对象调用方法，创建类对象的过程，需要new出来对象
（2） 把对象的创建不是通过new方式实现，而是交个spring配置创建类对象

3. spring是一站式框架
- spring在javaee三层结构中，每一层都提供不同的解决技术
（1） web层：springMVC
（2） service层：spring的ioc
（3） dao层：spring的jdbcTemplate

4. spring版本
- hivernate5.x
- spring4.x


### 二. Spring的ioc操作

1. 把对象的创建交给spring进行管理
2. ioc操作两部分：
- ioc的配置文件的方式
- ioc的注解方式

3. ioc底层原理
- xml配置文件
- dom4J解决xml
- 工厂设计模式
- java反射技术

![iocDevelop][4]

![iocDevelop][5]

4. ioc入门案例
- 导入jar包
（1） 解压资料zip文件
jar特点：都有三个jar包
（2） 做spring最基本功能时候，导入四个核心的jar包就可以了
（3） 导入支持日志输出的jar包
- 创建类，在类里面创建方法
- 创建spring配置文件，配置创建类
（1） spring核心配置文件名称和位置不是固定的，建议放到src下面，官方建议applicationContext.xml
（2） 引入schema约束
（3） 配置对象的创建
- 写代码测试对象创建


### 三. Spring的bean管理（xml方式）
1. bean实例化的方式
- 在spring里面通过配置文件创建对象
- bean实例化三种方式实现
（1） 使用类的无参数构造创建（重点）
注：如果类里面没有无参数的构造，会出现异常
（2） 使用静态工厂创建
① 创建静态的方法，返回类对象
（3） 使用实例工厂创建
① 创建不是静态的方法，返回类对象

2. Bean标签常用属性
- id属性：起名称，id属性值名称任意命名
注：① id属性值，不能包含特殊符号
② 根据id值得到配置对象

- class属性：创建对象所在类的全路径
- name属性：功能和id属性一样的，id属性值布恩那个包含特殊符号，但是在name属性值里面可以包含特殊符号，name属性为了解决strus1遗留的问题。
- scope属性
① singleton：默认值，单例的
② prototype：多例的
③ request：web项目中，spring创建一个bean的对象，将对象存入到session域中
④ session：web项目中，spring创建一个bean对象，将对象存入到session域中
⑤ globalSession：web项目中，应用到porlet环境，如果没有porlet环境那么globalSession相当于session。

- 属性的注入
① 创建对象的时候，向类里面属性里面设置值
② 属性注入的方式介绍
（1） 使用set方法注入
（2） 使用有参数构造注入
（3） 使用接口注入
③ 在spring框架里面，支持前两种方式

- 注入对象类型属性（重点）
①. 创建service类和dao类
（1） 在service中得到dao对象
②. 具体过程实现
（1） 在service里面把dao做为类型属性
（2） 生成dao类型属性的set方法
（3） 在配置文件中注入关系

- P 名称空间的注入
- 注入复杂类型属性
① 数组
② list集合
③ map集合
④ properties类型

3. IOC和DI区别
- IOC:控制反转，把对象创建交给spring进行配置
- DI：依赖注入，向类里面的属性中设置值
- 关系：依赖注入不能单独存在，需要在ioc基础上完成操作

4. spring整合web项目原理
- 加载spring核心配置文件
① new对象，功能可以实现，效率很低
- 实现思想：吧加载配置文件和创建对象过程，在服务器启动时候完成
- 实现原理
① ServletContext对象
② 监听器
③ 具体使用：
在服务器启动的时候，为每个项目创建一个ServletContext对象
在servletContext对象创建时候，使用监听器可以具体盗ServletContext对象在什么时候创建
使用监听器监听到ServletContext对象创建时候
加载Spring配置文件，把配置文件配置对象创建
把创建出来的对象放到ServletContext域对象里面（setAttribute方法）
获取对象的时候，盗ServletContext域中得到（getAttribute方法）


### 四. Spring的bean管理（注解）

1. 注解
> 1. 代码里面特殊标记，使用注解可以完成功能
> 2. 注解写法@注解名称（属性名称=属性值）
> 3. 注解使用在类上面，方法上面和属性上面

2. spring注解开发准备
- 导入jar包（基本jar包和aop的jar包）
- 创建类，创建方法
- 创建spring配置文件，引入约束
- 开启注解扫描

```xml
<!-- 注解扫描包 到包里面扫描类、方法和属性上面是否有注释 -->
<context:component-scan base-package="com.seeknovel"/>
<!-- 扫描属性上面的注解 -->
<context:annotation-config></context:annotation-config>
```

3. 注解创建对象
- 在创建对象的类上面使用注解实现
- 创建对象有四个注解

![@component][6]

4. 创建对象单实例还是多实例
5. 注解注入属性
- 创建service类，创建dao类，在service得到dao对象


### 五. AOP

1. aop概述
> aop:面向切面编程，扩展功能不修改源代码实现
aop采取横向抽取机制，取代了传统纵向继承体系重复性代码
2. aop原理
示意图如下：

![aopDevelop][7]

![aopTheory][8]

3. aop操作术语

**Joinpoint(连接点)**：所谓的连接点是指那些被拦截到的点。在spring中，这些点指的是方法，因为spring只支持方法类型的连接点。

**Pointcut（切入点）**：所谓的切入点是指我们要对哪些Joinpoint进行拦截的定义。

**Advice（通知/增强）**：所谓通知是指拦截到Joinpoint之后所要做的事情就是通知，通知分为前置通知，后置通知，异常通知，最终通知，环绕通知（切面要完成的功能）

**Introduction（引介）**：引介是一种特殊的通知在不修改类代码的前提下，Introduction可以在运行期为类动态添加一些方法或Field。

**Target（目标对象）**：代理的目标对象（要增强的类）
**Weaving（织入）**：是把增强应用到目标的过程，把advice应用到target的过程
**Proxy（代理）**：一个类被aop治入增强后，就产生一个结果代理类
**Aspect（切面）**：是切入点和通知（引介）的结合

术语解读：

![aopName][9]

4.Spring的aop操作

- 在spring里面进行aop操作，使用aspectj实现
① aspectj不是spring的一部分，和spring一起使用进行aop操作
② spring2.0以后增加了对AspectJ的支持
- 使用aspectj实现aop有两种方式
① 基于aspectj的xml配置
② 基于aspectj的注解方式

5. aop操作准备

- 除了导入基本的jar包之外，还需要导入aop相关的jar包
- 创建spring核心配置文件，导入aop的约束

6. 使用表达式配置切入点

- 切入点：实际增强的方法
- 常用表达式
① execution（* cn.itcast.aop.Book.add(..)）
② execution(* cn.itcast.aop.Book.*(..))
③ execution(* *.*(..))
④ 匹配所有save开头的方法 execution(* save*(..))
aop基于Aspectj配置实现：

![aopAchieve][10]

注：环绕通知的增强

```java
//环绕通知
public void aroundTest(ProceedingJoinPoint proceedingJoinPoint){
    //方法之前
    System.out.println("方法之前。。。");

    //执行被增强的方法
    proceedingJoinPoint.proceed();

    //方法之后
    System.out.println("方法之后。。。");
}
```

7. log4J介绍
- 通过log4j可以看到程序运行过程中更详细的信息
- 使用log4j查看日志
- 使用
① 导入log4j的jar包
⑤ 复制log4j配置文件，复制到src下面

- 设置日志级别
> log4j.rootLogger=info,stdout
① info：看到基本信息
② debug：看到更详细的信息


### 六. Spring整合web项目演示

1. 演示为题
（1） action调用service，service调用dao
（2） 每次访问action时候，都会加载spring配置文件
2. 解决方法：
（1） 在服务器启动时候，创建俺对象加载配置文件
（2） 底层使用监听器、ServletContext对象
3. 在spring里面不需要我们自己写代码实现，spring已经封装好了
（1） 封装了一个监听器，只需要配置监听器就可以了
（2） 配置监听器之前做事情：导入spring整合web项目jar包
在web.xml中配置:
```xml
<listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
</listener>
<!-- 指定加载spring配置文件位置 -->
<context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>classpath*:spring-context.xml</param-value>
</context-param>
```

3. 基于aspectj的注解aop
- 使用注解方式实现aop操作
① 创建对象
```xml
<!-- 创建对象 -->
<bean id="book" class="cn.itcast.aop.Book"></bean>
<bean id="myBook" class="cn.itcast.aop.MyBook"></bean>
```

② 在spring核心配置文件中，开启aop操作

```xml
<!-- 开启aop操作 -->
<aop:aspectj-autoproxy></aop:aspectj-autoproxy>
```

③ 在增强类上面使用注解完成aop操作

![aopBefore][11]

### 七. Spring的jdbcTemplate操作

1. spring框架一站式框架
（1） 针对javaee三层，每一层都有解决技术
（2） 在dao层，使用jdbcTemplate

2. spring对不同的持久化层技术都进行了封装
（1） jdbcTemplate对jdbc进行了封装
3. jdbcTemplate使用和dbutils使用很相似，都数据库进行crud操作
- 增加
① 导入jdbcTemplate的jar包
② 创建对象，设置数据库信息
③ 创建jdbcTemplate对象，设置数据源
④ 调用jdbcTemplate对象里面的方法实现操作

![springJdbc][12]

- 修改，删除类似与增加，不做赘述
- 查找
> 查找区别与dbutils，返回结果集的处理类需要自己去实现，而dbutils则给出了不同的结果集处理类，而jdbcTemplate则需要自己去实现RowMapper（）接口来处理结果。dbutils中也有类似于RowMapper（）接口的接口为ResultSetHandler（），但是他也提供了不同的实现类，来处理不同的结果。

### 八. Spring事务管理

1. Spring事物管理两种方式
（1） 编程式事务管理（不用）
（2） 声明式事务管理
- 基于xml配置文件实现
- 基于注解实现

2. spring事务管理的api介绍

![springTx][13]

（1） spring针对不同的dao层框架，提供接口不同的实现类

![springTxSx][14]

（2） 配置事物管理器

3. 搭建转账环境
（1） 创建数据库表，添加数据
（2） 创建service和dao类，完成注入关系
- service层又叫业务逻辑层
- dao层，单独对数据库操作，在dao层不添加业务

（3） 声明式事务管理（xml配置，麻烦不建议使用）
- 配置文件方式使用aop思想配置

![pzTx][15]

![pzQm][16]

（4） 声明式事务管理（注解）
- 配置事务管理器
- 配置事物注解
- 在要使用事务的方法所在类上面添加注解
图示：

![zjTx][17]

### 九. ssh框架的整合

1. ssh整合思想

![sshThink][18]

[1]: http://oss.willhappy.cn/18-5-3/73362040.jpg
[2]: http://oss.willhappy.cn/18-5-3/47267701.jpg
[3]: http://oss.willhappy.cn/18-5-3/64128309.jpg
[4]: http://oss.willhappy.cn/18-5-3/14125156.jpg
[5]: http://oss.willhappy.cn/18-5-3/51646746.jpg
[6]: http://oss.willhappy.cn/18-5-3/54295144.jpg
[7]: http://oss.willhappy.cn/18-5-3/6805202.jpg
[8]: http://oss.willhappy.cn/18-5-3/75261754.jpg
[9]: http://oss.willhappy.cn/18-5-3/69405956.jpg
[10]: http://oss.willhappy.cn/18-5-3/81650325.jpg
[11]: http://oss.willhappy.cn/18-5-3/35764246.jpg
[12]: http://oss.willhappy.cn/18-5-3/22949019.jpg
[13]: http://oss.willhappy.cn/18-5-3/45395861.jpg
[14]: http://oss.willhappy.cn/18-5-3/36709263.jpg
[15]: http://oss.willhappy.cn/18-5-3/14916884.jpg
[16]: http://oss.willhappy.cn/18-5-3/65304479.jpg
[17]: http://oss.willhappy.cn/18-5-3/45372897.jpg
[18]: http://oss.willhappy.cn/18-5-3/82192601.jpg
