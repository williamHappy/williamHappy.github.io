---
title: Java入门
date: 2016-11-20
categories: [后端]
tags: [Java,基础]
description: "极客学院web工程师java基础知识总结笔记。"
cover_picture: http://img.willhappy.cn/hexo/cover_pic/cover_picture_4.jpg

---

<!--more-->

[toc]

### 一. 什么是java
> java编程语言是个简答/完全面向对象/分布式/解释性/健壮性/安全与系统无关/可移植性/高性能/多线程和动态得编程语言。

### 二. java体系
1. java SE java平台标准版
2. java EE java平台企业版
3. java ME java平台微型版

### 三. java开发环境
1. Eclipse
2. myEclipse
3. IntelliJ IDEA

### 四. java开发前提
> java源代码是*.java得纯文本文件，可以使用任何文本编辑气编写，单不可执行。
JDK是java语言得开发包，可以将*.java文件编译盛可执行得java程序
可执行java程序需要JVM猜可以运行
JRE包含了JVM
JDK包含了JRE

*注：JRE(java runtime environment,java运行环境),运行java程序所需要得环境得集合，包含JVM标准实现及java核心类库。仅能够完成java得运行，而无法对java进行编译/调试等。
JDK（java development kit）是java语言得软甲开发工具包（SDK）,面向java开发者发布的java套件。JDK包含得基本组件包括：编译器/jar打包工具/javadoc文档生成器/debug调试器/头文件生成器/反汇编器/监控工具等。*

### 五. 数据类型初阶
1. java定义了基本数据类型、引用数据类型和自定义数据类型。
![java基本数据类型][1]
2. 本主题将介绍java的八种基本数据类型和引用数据类型中String类型
3. 栈空间：
    a. 栈空间存取数据的效率搞。
    b. 栈中的数据按“先进后出”的方式管理。
    c. 栈空间存储空间较小，不能存放大量的数据。
    d. JVM将基本类型的数据存放在栈空间。
![java栈空间][2]
4. 堆空间：
    a. 堆空间存取数据的效率最低；
    b. 数据存放的位置随机分配；
    c. 堆空间存储数据的空间大，能存放大容量的数据。
![java堆空间][3]
### 六.  自动类型转换
（1） byte->short->int->long->float->double
（2） int和char类型的数据在某种情况下可以自动相互转换。

### 七. 通过Scanner从控制台获取数据
（1） String next();
作用：接受控制台输入的一个字符串，空格或回车作为一次输入数据的结束，所以不能将空格作为字符串接受。
（2） String nextLine();
作用：接受控制台输入的一个字符串，以回车作为输入数据的结束。
（3） int nexInt();
作用：接受控制台输入的一个int类型的数据。
（4） double nextDouble();
（5） boolean nextBoolean();
（6） 从控制台输入char类型的数据
Scanner类没有提供直接输入char类型的方法，可以通过charAt()方法从next()或nextLine()获取输入的字符。

char String.charAt(int index);
作用：从字符串中获取指定下表的字符，下标从0开始。

### 八. 数组学习（实例：冒泡排序）

```java
        /**
		 * 正宗的冒泡排序
		 * 1.比较相邻的元素。如果第一个比第二个大，就交换他们两个。
		 * 2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
         * 3.针对所有的元素重复以上的步骤，除了最后一个。
		 * 4.持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
		 */
		int a[] = {78,34,12,64,5,4};
		int temp = 0;
		for (int i = 0; i < a.length-1; i++) {
			for (int j = 0; j < a.length-1-i; j++) {
			//第i轮排序过后，最大数都会相应的放到后面，所以次数相应的减少i+1次
				if (a[j]>a[j+1]) {
					temp = a[j];
					a[j] = a[j+1];
					a[j+1] = temp;
				}
			}
		}
		for (int i = 0; i < a.length; i++) {
			System.out.println(a[i]);
		}
```

### 九. String字符串
1. 实例化String对象
    1）直接赋值的方式；
    2）使用关键字new
推荐使用直接赋值的方式，因为使用关键字new，会在堆内存中开辟空间存储字符串本身，另外开辟空间存储栈空间指向堆空间的对象。（可能表达不大准确，可看图）。
![String的实例化][4]

2. 字符串的比较
    “==” 比较的是地址
    “equals”比较的是内容

3. 字符串常用方法
    a. toCharArray();字符串转换成数组
    b. charAt();从字符串中取出指定位置的字符
    c. getBytes();字符串与byte数组的转换
    d. indexOf();过滤字符串中存在的字符，返回字符的当前位置
    e. trim();去掉字符串的前后空格
    f. subString()；从字符串中取出子字符串
    g. toLowerCase(),toUpperCase();大小写转换
    h. endsWith(),startWith();判断字符串的开头结尾字符
    i. replace();替换String字符串中的一个字符

### 十. StringBuffer
缓冲区，本身也是操作字符串的，但是与String不同，StringBuffer是可以更改的，而String内容是不可修改的。

```java
    StringBuffer stringBuffer = new StringBuffer();
    stringBuffer.append("hello world!");
    for (int i = 0; i < 100; i++){
        stringBuffer.append(i);
    }
    System.out.print(stringBuffer.toString());
```

同样的如果用String添加

```java
    String str = "hello world!";
    for(int i = 0; i < 100; i++){
        str = str + i;
    }
    System.out.print(str);
```

说明：两种方法追加字符串输出的结果是相同的，但是执行的速度是不同的，相对来说，StringBuffer的执行速度更快一些，因为他只是在原先的字符位置进行修改，而String则需要每次改变都要开辟新的内存空间。

### 十一. StringBuilder
1. 一个可变的字符序列，该类被设计作用StringBuffer的一个简易替换，用在字符串缓冲区被单个线程使用的时候。建议优先考虑该类，速度比StringBuffer要快。
2. 但是如果涉及到线程安全方面，建议使用StringBuffer。
3. 常用方法：
    append()
    insert()

### 十二. 异常处理
1. 异常的格式

```java
    //伪代码
    try{
        异常的语句；
    }catch(Exception e){
        异常的处理；
    }finally{
        一定会执行的代码；
    }
```

实例：

```java
    int a = 10, b = 0 , temp = 0;
    try {
        temp = a/b;
    }catch (Exception e){
        System.out.println(e);
    }
    System.out.println(temp);
```

输出为：java.lang.ArithmeticException: / by zero
        0
2. 常见异常
    a. 数组越界异常：ArrayIndexOutOfBoundsException
    b. 数字格式化异常：NumberFormatException
    c. 算数异常：ArithmeticException
    d. 空指针异常：NullPointerException

### 十三. java面向对象中类和对象
1. 方法的定义
    static（静态方法）就是没有this的方法。
2. 方法的重载：方法名称相同，返回类型，但是参数的类型和个数不同，通过传递参数的个数和类型不同来完成不同的功能。每个重载方法都必须有独一无二的参数列表。
3. 对象的创建,如下所示

```java
Class Person{
    String name = null;
    int age = 0;
}
//声名并实例化对象
Person per = new Person();
```

说明：Person per 创建栈内存per，使用new Person()开辟堆内存空间，栈内存的per指向对应的堆内存空间，堆内存空间存储name=null；age=0；
对象创建的内存划分，如图：
![java对象实例化][5]

<br>
4. 构造器
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;构造器没有任何返回值，如果类中没有构造器，则编译器会自动帮你常见一个默认的构造器，如果已经定义了构造器（无论是否有参数），编译器都不会帮你自动创建默认的构造器。
a. 格式：

```
    访问修饰符 类名称（）{
        程序语句
    }
```
<br>
b. 注意点：
（1）构造方法名称必须与类名一致
（2）构造方法没有返回值

<br>   
5. 面向对象三大特征
    a. 封装性
对外部不可见
    b. 继承
扩展类的功能
    c. 多态性
方法的重载
对象的多态

<br>
6. 方法的递归调用 实例如下：

```java
public static void main(String[] args){
    /**
     * 递归方法的调用
     * 100+99+...+1
     * 输出的值为5050
     */
    System.out.print(addNum(100));
}
//静态方法
public static int addNum(int num) {
    if (num == 1) {
        return 1;
    } else {
        return num + addNum(num - 1);
    }
}
```
<br>
7. static关键字

- 由static修饰的变量成为静态变量，也称为类变量。
- 静态变量定义的位置时在方法之外。
- 静态变量与静态方法都是在类从磁盘加载至内存后被创建的，与类同时存在，同时消亡。
- 静态变量又称类的成员变量，在类中时全局变量，可以别类中的所有方法调用。
- 静态变量的值由jvm自动初始化。
- 使用static声名全局属性
- 使用static是声名的方法可以直接通过类名进行调用
- 使用static方法的时候，只能访问static声名的属性和方法，而非static声名的属性和方法时不能访问的。

<br>      
8. 匿名对象
    匿名对象就是没有名字的对象，如果程序中只是用一次该对象，就可以使用匿名对象的方式。
    实例:

```java
//学生类
class Student{
    public void tell(){
        System.out.print("Hello World!");
    }
}
public class test{
    public static void main(String[] args){
        /**
         * 匿名对象的使用
         * 输出：Hello world!
         */
        new Student().tell();
    }
}
```
<br>
9. this关键字

- 表示类中的属性和调用方法
- 调用本类中的构造方法
- 表示当前对象

### 十四. java面向对象的基本特征：继承
1. 继承的基本概念
- 扩展父类的功能
2. java中使用extends关键字完成继承
- class 子类 extends 父类 {}
3. 继承的限制
- 在java中只允许单继承
- 子类不能直接访问父类的私有成员
4. 子类对象的实例化过程
    a. 在子类对象实例化之前，必须先调用父类中的构造方法，之后调用子类构造方法
 示例图如下：   
```graphLR
A(实例化子类对象) -->|1.先调用父类构造| B(调用父类构造)
A -->|2.再调用子类构造| C(调用子类构造)
```
<br>
5. java方法重写与super关键字

- 在继承中，也存在这重写的概念，起始就是子类定义了和父类同名的方法
- 定义：
    方法名称相同，返回值类型相同，参数也相同。
- 重写的限制：
    被子类重写的方法不能拥有比父类方法更加严格的访问权限
- 访问权限：
    private<default<protected<public
    private只能在当前类中进行访问，default在同一包下进行访问，public在整个工程下进行访问。
- super关键字
    强行调用父类的方法的执行
- 重写与重载区别

|NO|区别点|重载|重写|
|--|------|----|----|
|1|单词|Overloading|Overriding|
|2|定义|方法名称相同，参数的类型或个数不同|方法名称、参数的类型、返回值类型全部相同|
|3|访问权限|对权限没有要求|被重写的方法不能拥有比父类更加严格的权限|
|4|范围|发生在同一个类中|发生在继承中|

### 十五. java面向对象-抽象类和接口
1. final关键字
- final关键字在java中被称为完结器，表示最终的意思
- final能声名类、方法、属性：
    1. 使用final声名的类不能被继承
    2. 使用final声名的方法不能别重写
    3. 使用final声名的变量变成常量，常量是不可以别修改的
2. 抽象类
- 抽象类概念：
    包含一个抽象方法的类就是抽象类
- 抽象方法：
    声名而未被实现的方法，抽象方法必须使用abstract关键字声名
- 抽象类被子类继承，子类（如果不是抽象类，必须重写抽象类中的所有抽象方法）
- 定义格式：

```
    abstract class className{
        属性
        方法
        抽象方法
    }
```
<br>
- 抽象类不能直接实例化，要通过其子类进行实例化
3. 接口
- 接口是java中最重要的概念，接口可以理解为一种特殊的类，里面全部是有全局常量和公共的抽象方法组成。
- 接口的格式：

```
    interface interfaceName{
        全局常量
        抽象方法
    }
```
<br>
- 接口的实现也必须通过子类，使用关键字implements，而且接口是可以多实现的。
- 一个子类可以同时继承抽象类和实现接口
- 一个接口不能继承一个抽象类，但是却可以通过extends关键字同时继承多个接口，实现接口的多继承。
实例：
```java
interface Inter3 extends Inter1,Inter2{}
```
<br>
4. 接口和抽象类的访问修饰符

- 接口可以使用public或者默认访问修饰符，接口的方法只能使用public，属性可以使用public、static、final；
- 抽象类可以使用public或者默认的访问修饰符，抽象类的方法可以使用public、protected、默认的或private，属性可以是public、static、final、protected、private。

### 十六. java面向对象多态性
1. 多态性
    a. 多态性的体现：
    - 方法的重载和重写
    - 对象的多态性

    b. 对象的多态性：
    - 向上转型：程序会自动完成
        父类 父类对象 = 子类实例
    - 向下转型：强制类型转换
        子类 子类对象 = （子类）父类实例

```java
class A {
    public void tell1() {
        System.out.println("A====tell1");
    }

    public void tell2() {
        System.out.println("A====tell2");
    }
}

class B extends A {
    public void tell1() {
        System.out.println("B====tell1");
    }

    public void tell3() {
        System.out.println("B====tell3");
    }
}


public class Test1 {
    public static void main(String[] args) {
        /**
         * 向上转型
         * 输出：B====tell1
         *      A====tell2
         */
//        B b = new B();
//        A a = b;
//        a.tell1();//tell1重写,调用被重写之后的方法
//        a.tell2();

        /**
         * 向下转型
         * 输出：B====tell1
         *      A====tell2
         *      B====tell3
         */
        A a = new B();//注意向下转型之前，先要向上转型
        B b = (B) a;
        b.tell1();
        b.tell2();
        b.tell3();
    }
}
```

 c. 对象的多态的应用

```java
class A1{
    public void tell1(){
        System.out.println("A1====tell1");
    }
}
class B1 extends A1{
    public void tell2(){
        System.out.println("B1====tell2");
    }
}
class C1 extends A1{
    public void tell3(){
        System.out.println("C1====tell3");
    }
}
class D1 extends A1{
    public void tell4(){
        System.out.println("D1====tell4");
    }
}

public class Test2 {
    public static void main(String[] args){
        /**
         * 多态的应用
         * 输出：A1====tell1
         *      A1====tell1
         *      A1====tell1
         */
        say(new B1());
        say(new C1());
        say(new D1());
    }
    public static void say(A1 a1){
        a1.tell1();
    }
}
```
<br>
2. instanceof关键字
    在java中可以使用instanceof关键字判断一个对象到底是不是一个类的实例
3. 抽象类的应用
4. 接口的应用

```java
interface USB {
    void start();

    void stop();
}

class C {
    public static void work(USB u) {
        u.start();
        System.out.println("工作中");
        u.stop();
    }
}

class USBDisk implements USB {

    @Override
    public void start() {
        System.out.println("u盘开始工作");
    }

    @Override
    public void stop() {
        System.out.println("u盘停止工作");
    }
}

class Printer implements USB {

    @Override
    public void start() {
        System.out.println("打印机开始工作");
    }

    @Override
    public void stop() {
        System.out.println("打印机停止工作");
    }
}

public class Test3 {
    public static void main(String[] args) {
        /**
         * 接口的应用
         * 输出：u盘开始工作
         *      工作中
         *      u盘停止工作
         *      打印机开始工作
         *      工作中
         *      打印机停止工作
         */
        C.work(new USBDisk());
        C.work(new Printer());
    }
}
```

### 十七. java面向对象之泛型
1. 知识泛型
    a. 泛型是在JDK1.5之后增加的新功能，泛型（Generic）
    b. 泛型可以解决数据类型的安全性问题，他主要的原理，是在类声名的时候通过一个标识标识类中某个属性的类型或者是某个方法的返回值及参数类型。
    c. 格式：

```
        访问权限 class 类名称<泛型，泛型...>{
            属性
            方法
        }
```
<br>
    d. 对象的创建
> 类名称<具体类型> 对象名称 = new 类名称<具体类型>();

2. 构造方法中使用泛型
    构造方法可以为类中的属性初始化，那么如果类中的属性通过泛型指定，而又需要通过构造方法设置属性内容的时候，那么构造方法的定义与之前并无不同，不需要向声名类那样指定泛型。

3. 设置多个泛型
```java
class Gen<T,K>{
    private T take;
    private K key;
}
//实例化
Gen<Integer,String> g = new Gen<Integer,String>();

```
<br>
4. 通配符

- 可以使用？作为通配符

<br>
5. 泛型接口

- 格式：
interface 接口名称<泛型标识>{}

<br>
6. 泛型方法

- 泛型方法中可以定义泛型参数，此时，参数的类型就是传入数据类型。
- 格式：
    访问权限 <泛型标识> 泛型标识 方法名称（[泛型标识 参数名称]）

<br>
7. 泛型数组

```java
public class Test3{
    public static void main(String[] args){
        Integer arr[] = {1,2,3,4};
        tell(arr);
    }
    public static <T>void tell(T arr[]){
        for(int i = 0; i < arr.length; i++){
            System.out.println(arr[i]);
        }
    }
}
```

### 十八. 常用javaAPI详解
- java本地文件操作
    1. 文件和文件夹的创建、删除、重命名
    2. 文件属性的读取
    3. 文件属性的设置
    4. 遍历文件夹
实例如下：
```java
public class Test5 {

    public static void main(String[] args){
        printFiles(new File("E:\\workspace\\interlIDEA\\JavaStudy"),1);
    }

    public static void printFiles(File dir,int tab){
        if(dir.isDirectory()){
            File next[] = dir.listFiles();
            for (int i = 0; i < next.length; i++) {
                for (int j = 0; j < tab; j++) {
                    System.out.print("|--");
                }
                System.out.println(next[i].getName());
                if (next[i].isDirectory()) {
                    printFiles(next[i],tab + 1);
                }
            }
        }
    }

}
```

文件的简单读取

```java
public class Test6 {
    public static void main(String[] args){
        File file = new File("text.txt");
        if (file.exists()) {
            System.out.println("exist");

            try {
                FileInputStream fis = new FileInputStream(file);
                InputStreamReader isr = new InputStreamReader(fis,"UTF-8");
                BufferedReader br = new BufferedReader(isr);

                String line;
                while ((line = br.readLine())!=null){
                    System.out.println(line);
                }
                br.close();
                isr.close();
                fis.close();


            }catch (FileNotFoundException e){
                e.printStackTrace();
            }catch (UnsupportedEncodingException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        try {
            File newFile = new File("newtext.txt");
            FileOutputStream fos = new FileOutputStream(newFile);
            OutputStreamWriter osw = new OutputStreamWriter(fos,"UTF-8");
            BufferedWriter bw = new BufferedWriter(osw);

            bw.write("我深爱这你\n");
            bw.write("我深深的爱着\n");

            bw.close();
            osw.close();
            fos.close();

            System.out.println("写入完成！");
        }catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }


    }
}

```

### 十九. java的日期与时间处理
实例：

```java
public class Test8 {
    public static void main(String[] args) throws ParseException {
        /**
         * 时间实例：
         * 设定女朋友的生日，并在提前2个星期的星期六提醒
         */

        //1.设定生日，String
        String birthday = "2015-05-30";

        //2.将String类型转换为日期
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd");
        Date date = simpleDateFormat.parse(birthday);

        //3.对日期进行计算
        Date spec = prepareBirthday(date);

        //4.将计算后的结果，转换为String类型，输出
        String str2 = simpleDateFormat.format(spec);
        System.out.println(birthday + "提前2周的周六为：" + str2);
    }

    /**
     * 传入一个日期，计算出该日期的2个星期前的周六的日期
     *
     * @param birthdayDate
     * @return
     */
    public static Date prepareBirthday(Date birthdayDate) {
        Calendar calendar = new GregorianCalendar();
        calendar.setTime(birthdayDate);//传入的date日期，转换为calendar
        calendar.add(Calendar.WEEK_OF_MONTH, -2);//提前2周
        calendar.set(Calendar.DAY_OF_WEEK, Calendar.SATURDAY);//调整为当前星期的周六
        return calendar.getTime();
    }

}
```

### 二十. java工程结构管理
- Build Path事指定java工程所包含的额资源属性集合，在一个成熟的java工程中，不仅仅有自己编写的源代码，还需要引用系统运行库（JRE），第三方的功能扩展库，工作空间中的其他工程，甚至外部的类文件，所有这些资源都是被这个工程所依赖的，并且背引用后，才能够将工程编译成功，而build path就是用来配置和管理对这些资源的引用的。
Build Path一般包括：
1. JRE运行时库
2. 第三方功能扩展库（`*.jar`格式文件）
3. 其他工程
4. 其他的源代码或class文件


### 二十一. jsp基础
1. 基本介绍
    - jsp起源
    - jsp是一门脚本语言
    - jsp拥有java语言的所有特性
    - jsp运行于jsp容器中（jsp容器有：Tomcat，jetty）
    - jsp会被转换成servlet
2. web开发基础
    - HTML
        1.HTML==HyperText Markup Language
        2.由服务器返回，由浏览器呈现
    - URI/URL/URN
        1. URL==Uniform Resource Locator
        2. 代表资源的地址信息
        3. <协议>//<主机>:<端口>/<路径>

        1. URN==Uniform Resource Name
        2. 代表某个资源独一无二的名称

        1. URI==Uniform Resource Identifier
        2. 用于标识某一互联网资源名称的字符串
    - HTTP协议简介
        1. HTTP==HyperText Transfer Protocol
        2. 1990年提出
        3. 特点：
            - 支持客户/服务器模式
            - 灵活
            - 无连接
            - 无状态
        4. 方法
|方法名|对应规范|
|-|-|
|GET|向特定的资源发出请求|
|POST|向指定资源提交数据进行处理请求|

<br>
3. jsp基本语法

- jsp程序段定义

```jsp
  <!--jsp表达式输出-->
  输出：<%="hello woWorld!"%>
  <br/>

  <%!
    //jsp声名使用，相当于全局变量，可以再jsp的其他地方使用该变量。
    String str2 = "Hello newWorld!";
  %>

  <%
    //jsp程序段中定义的变量相当于局部变量，不同请求之间都会有一份独立的变量定义
    String str1 = "Hello World";
    out.println(str1);//jsp内置对象out
  %>
  <br/>

  <%
    out.println(str2);
  %>
```

jsp代码注释

```jsp
    <!-- 1.Html注释   说明：此注释会被发送到客户端，用户是可以看到的，不安全 -->

    <%--
        2.jsp代码段注释，不会发送到客户端，相对安全
    --%>

    <%
        //3.java程序段中的注释如下
        //java程序段中的单行注释
        /**
         *多行注释，和在纯java代码中的注释相同
         */
    %>

```
<br>
4. jsp编译指令和动作指令

- 说明：WEB-INF中的jsp就是无法通过地址栏访问的，所以安全。
- 访问web-inf下jsp资源的几种方式：

    方法一：
如果说你要访问这个文件夹中的jsp文件需要在项目的web.xml文件中去配置servlet格式差不多的配置就ok了 如下:

```xml
<servlet>  
<servlet-name>runtain</servlet-name>  
<jsp-file>/WEB-INF/INF.jsp</jsp-file>  
</servlet>  
<servlet-mapping>  
<servlet-name>runtain</servlet-name>  
<url-pattern>/XXX</url-pattern>  
```

访问地址:http://localhost:8080/runtain/xxx  即可访问jsp页面内容

方法二：
```
<jsp:forward page = "/WEB-INF/jsp/test/test.jsp" />
```     

方法三:
```
request.getRequestDispatcher("/WEB-INF/a.jsp").forward(request, response);
```

怎么样让servlet访问web-inf下的网页或jsp文件呢？

> 因为web-inf下,应用服务器把它指为禁访目录，即直接在浏览器里是不能访问到的。
因些，可以让servlet进行访问，如web-inf下有a.jsp，则可以用request.getRequestDispatcher("/WEB-INF/a.jsp").forward(request,response);进行派遣访问
但如果web-inf下有a.htm,则用request.getRequestDispatcher("/WEB-INF/a.htm").forward(request,response);则不能访问。
一开始想不通，觉得怪。后来想想，jsp其实也是servlet,会自动编译的，于是work目录下会有/web-inf/a$jsp.class类型，于是有头绪了,让应用服务器能够编译.htm,如a$htm.class.抱有这个想法，开始动手

在tomcat下的conf/web.xml，找到jsp的访问方式

```xml
<servlet-mapping>  
<servlet-name>jsp</servlet-name>  
<url-pattern>*.jsp</url-pattern>  
</servlet-mapping>
```

于是在下面添加
```xml
<servlet-mapping>  
<servlet-name>jsp</servlet-name>  
<url-pattern>*.htm</url-pattern>  
</servlet-mapping>  
<servlet-mapping>  
<servlet-name>jsp</servlet-name>  
<url-pattern>*.html</url-pattern>  
</servlet-mapping>
```

随后，一切OK，此时可访问a.htm。
a.html在work/web-inf/下者有`a\$htm.class`, `a\$html.class` 生成

编译指令：

```
<%@ include file=""%>
```

动作指令：

```
<jsp:forward page="login.jsp"></jsp:forward>
```

说明：forward指令下面的内容不会被执行

```
<jsp:include page="">
    <jsp:param value="red" name="bgcolor"/>
</jsp:include>
<jsp:useBean id="user" class="com.william.entity.User"></jsp:useBean>
<jsp:setProperty name="user" property="userName"/>
<jsp:setProperty name="user" property="passWord"/>
```

说明：注意区分编译指令的include和动作指令的include的区别
    对于静态包含，<%@include%>，中包含的文件，只是简单的嵌入到主文件中，就是在jsp页面转化成Servlet时才嵌入到主文件中，因为运行的结果是只生成了一个Servlet。
而对于动态包含<jsp:incude>，如果被包含文件是动态的，那么就会生成两个Servlet，也就是被包含文件也要经过jsp引擎编译执行生成一个Servlet，两个Servlet通过request和reponse进行通信。如果被包含的文件是静态的，那么这种情况和<%@include>就很相似，只生成了一个Servlet，但是他们之间没有进行简单的嵌入，而依然是通过request和reponse进行的通信。

<br>
5. jsp内置对象

- out对象

```
    <%
        out.print("william");
        out.newLine();
        out.flush();//强制刷新服务器缓冲区中的数据
        out.clearBuffer();//清空缓冲区数据
        out.clear();//
        out.println("获取当前缓冲区大小："+out.getBufferSize());
        out.println("获取缓冲区剩余字节数目："+out.getRemaining());
    %>
```

- request对象
```
    <form action="" method="post">
        <input type="text" name="userName"/>
        <input type="submit" value="提交">
    </form>

    请求的方法名：<%= request.getMethod() %><br/>
    请求的资源：<%= request.getRequestURI() %><br/>
    请求使用的协议：<%= request.getProtocol() %><br/>
    请求的服务器IP：<%= request.getServerName() %><br/>
    请求的服务器端口：<%= request.getServerPort() %><br/>
    客户端IP地址：<%= request.getRemoteAddr() %><br/>
    客户端主机名：<%= request.getRemoteHost() %><br/>
    表单提交来的值：<%= request.getParameter("userName") %><br/>

    <!--
        输出：

        请求的方法名：GET
        请求的资源：/Web01/jsps/Test05/request.jsp
        请求使用的协议：HTTP/1.1
        请求的服务器IP：localhost
        请求的服务器端口：8080
        客户端IP地址：127.0.0.1
        客户端主机名：127.0.0.1
        表单提交来的值：null
    -->
```

- response对象
```
    <%
        response.setHeader("Cache-Control","no-cache");
        response.setIntHeader("Refresh",2);
        out.println("date is" + new java.util.Date().toString() + "<br/>");
    %>
    <%
        //response实例
        Cookie myCookie = new Cookie("william","123456");
        myCookie.setMaxAge(3600);
        response.addCookie(myCookie);
    %>
```

- exception对象
```
    异常描述信息：<br/>
    <%
        out.println(exception.getMessage());
    %>
    <br/>

    exception对象的字符串描述：<br/>
    <%
        out.println(exception.toString());
    %>
    <br/>

    <%
        exception.printStackTrace();
    %>
```

- config对象
    在web.xml中添加配置：
```xml
    <servlet>
        <servlet-name>config</servlet-name>
        <jsp-file>/jsps/Test08/config.jsp</jsp-file>
        <init-param>
            <param-name>username</param-name>
            <param-value>william</param-value>
        </init-param>
        <init-param>
            <param-name>password</param-name>
            <param-value>123456</param-value>
        </init-param>
    </servlet>
```

jsp中使用config获取：
```
用户名：<%= config.getInitParameter("username")%><br/>
密码：<%= config.getInitParameter("password")%>
<%--
    浏览器中输出：用户名：william
                  密码：123456
--%>

```

- page对象
```
<%
    out.println("page对象字符串"+page.toString());
    page.getClass();
    page.hashCode();
    //page.equals(obj);
%>
```

- session对象
```
    sessionId:<%= session.getId()%><br/>
    session的创建时间：<%= new java.util.Date(session.getCreationTime())%><br/>
    session的最后访问时间：<%= new java.util.Date(session.getLastAccessedTime())%><br/>
    session的失效时间：<%= session.getMaxInactiveInterval()%><br/>
```

- application对象
```
服务器信息：<%= application.getServerInfo()%><br/>
应用名称：<%= application.getServletContextName()%><br/>
主机名称：<%= application.getVirtualServerName()%><br/>
<%
    //页面访问计数器实例
   Object obj = application.getAttribute("counter");
    if (obj == null) {
        application.setAttribute("counter",new Integer(1));
        out.println("该页面被访问了1次<br/>");
    }else{
        int counterValue = Integer.parseInt(obj.toString());
        counterValue++;
        out.println("该页面被访问了 " + counterValue + "次<br/>");
        application.setAttribute("counter",counterValue);
    }
%>
```

- pageContext对象
```
<%
    JspWriter myOut = pageContext.getOut();
    myOut.println("Hello world!");

    pageContext.setAttribute("userName","william",pageContext.SESSION_SCOPE);

    String value = session.getAttribute("userName").toString();
    out.println(value);
    out.println("<br/>");

%>
```

### 二十二. JDBC相关知识
1. 数据库基础知识
    - 数据库简介
    - 关系数据模型
        **特点：**
        1. 概念单一
        2. 规范化
        3. 二维表

        **术语：**
        1. 关系
        2. 元祖
        3. 属性
        4. 属性域
        5. 主键
        6. 外键
    - 数据库范式
        1NF（原子性）
        2NF（唯一性）
        3NF（冗余行判断）
2. mysql入门
    sql功能：DDL、DML、DCL
3. JDBC编程
- JDBC（Java Data Base Connectivity）
- JDBC的组成：JDBC API/JDBC Driver API
- JDBC API：DriverManager/Connection/Statement/PreparedStatement/ResultSet
- JDBC Driver API；JDBC-ODBC bridge/部分java技术的本地API驱动程序/全部基于java技术的本地API驱动程序/全部基于java技术的本地协议驱动程序

    JDBC程序编写步骤：
```graphLR
A(JDBC编程流程) -->B(1.加载驱动)
A -->C(2.打开连接)
A -->D(3.执行查询)
A -->E(4.处理结果)
A -->F(5.清理环境)
```

实例：
```java
public static void main(String[] args){
        String sql = "select * from tbl_user";
        Connection conn = null;
        Statement st = null;
        ResultSet rs = null;

        try {
            //获取数据库连接
            Class.forName("com.mysql.jdbc.Driver");
            conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/jsp_db","root","");
            st = conn.createStatement();
            rs = st.executeQuery(sql);

            while(rs.next()){
                System.out.print(rs.getInt("id")+" ");
                System.out.print(rs.getString("name")+" ");
                System.out.print(rs.getString("password")+" ");
                System.out.print(rs.getString("email")+" ");
                System.out.println();
            }

        }catch (Exception e){
            e.printStackTrace();
        }finally{
            try {
                rs.close();
            }catch (Exception e2){}
            try {
                st.close();
            }catch (Exception e3){}
            try {
                conn.close();
            }catch (Exception e4){}
        }

    }
```
<br>
4. 事务处理

- 事务的四个特性：原子性/一致性/隔离性/持久性

事务实例：
```java
public class TransactionTest {
    public static Connection getConnection(){
        Connection conn = null;
        try {
            Class.forName("com.mysql.jdbc.Driver");
            conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/jsp_db","root","");
        }catch (Exception e){
            e.printStackTrace();
        }
        return conn;
    }

    public static void insertUserData(Connection conn) throws SQLException{
            String sql = "insert into tbl_user(id,name,password,email) values (10,'Tom','123456','tom@gmail.com')";
            Statement st = conn.createStatement();
            int count = st.executeUpdate(sql);
            System.out.println("向用户表中插入了" + count + "条记录");
            //conn.close();
    }

    public static void insertAddressData(Connection conn) throws SQLException{
            String sql = "insert into tbl_address(id,city,country,user_id) values (1,'shanghai','China','10')";
            Statement st = conn.createStatement();
            int count = st.executeUpdate(sql);
            System.out.println("向地址表中插入了" + count + "条记录");
            //conn.close();
    }

    public static void main(String[] args){
        Connection conn = null;
        try {
            conn = getConnection();
            conn.setAutoCommit(false);

            insertUserData(conn);
            insertAddressData(conn);

            conn.commit();
        } catch (SQLException e) {
            System.out.println("=========捕获到sql异常==========");
            e.printStackTrace();

            try {
                conn.rollback();
                System.out.println("=========事务回归==========");
            } catch (Exception e1) {
                e1.printStackTrace();
            }
        }finally{
            try {
                if (conn!=null) {
                    conn.close();
                }
            } catch (Exception e2) {
                e2.printStackTrace();
            }
        }

    }

}
```

<br>
5. JDBC编程优化

### 二十三. Servlet概述

```graphLR
A(Servlet) --> B(Server+Applet)
A --> C(特殊的java类)
A --> D(Servlet与HTTP)
```

- servlet处理流程分析
    1. 生命周期：加载类->调用init()方法初始化->处理请求->销毁
    2. 有关servlet的详细信息：http://www.cnblogs.com/xuekyo/archive/2013/02/24/2924072.htm
- servlet过滤器
    1. 编码转换过滤器
    2. 权限校验过滤器


### 二十四. java基础知识面试指导
本课时巩固知识点：

- java关键字及功能
- java数据类型
- java基本运算符
- java基本程序控制语句
- java数组

1. java关键字
    - 熟知java常用关键字的拼写及功能
    - 所有的ajva关键字都是小写的
    - goto和const时保留关键字，在java中没有使用
    - true，false，null不是严格意义上的关键字，而是文字常量（literals）
    - 程序遇到return语句将不会执行finally语句

2. java数据类型
    - 8种数据类型：byte，short，int，long，float，double，char，boolean
    - 8种基本数据类型占用的字节长度
    - 3种引用数据类型：类，接口，数组
    - 8种基本数据类型对应的包装类，被final修饰，不可被继承
    - String和StringBuffer类也是被final修饰

3. java基本运算符
    - java基本运算符的种类
    - java基本运算符的优先级
    - 单目，双目，三目运算符的划分
    - 运算符操作过程种的类型转换问题

4. java程序流程控制语句
    - 三种执行方式：顺序结构，选择结构和循环结构
    - 条件选择语句：if...else,switch...case
    - 循环语句：while,do...while,for
    - 注意while和do...while的区别，for的三个循环条件
    - switch支持的数据类型有：byte，short，char，int以及枚举类型

5. java数组
    - java数组的概念和特点
    - 一维数组和二位数组的声名
    - 数组初始化的两种方式：静态初始化和动态初始化
    - 动态初始化数组必须给出长度，否则将报"缺少数组维数"的错误
    - 动态初始化二维数组时，可以只指定第一位的长度而不指定第二维的
    - 当数组包含的元素时引用数据类型时，必须为每个元素实例化，否则会出现空指针异常


常见java基础知识陷阱

1. 浮点数运算陷阱
- float和double不能进行精确运算
- 不能简单的使用四舍五入的方法解决上述问题
- 可以使用BigDecimal类解决
2. 自增、自减运算符陷阱
- ++和--运算符的规则
- i++和++i的区别
- 进行增量或减量运算常见错误
3. 字符和字符串陷阱
- 字符串与字符拼接规则
- 转义字符使用规则
4. 返回与退出陷阱
- return与try...catch语句
- exit()函数与try...catch语句

实例：
谈谈final，finally，finalize的区别？
答：final---修饰符（关键字）
    finally---再异常处理时提供finally块来执行任何清除操作
    finalize---方法名

### 二十五. java面向对象面试指导
- java面向对象必会知识点
    1. 面向对象的特点
        - 封装
        - 继承
        - 多态
    面向对象程序涉及方法的优点：可重用性，可扩展性，可管理性
    2. 类与对象知识点
        - 类与对象的概念
        - 类方法的特点
        - 匿名对象
        - 构造函数与构造代码块
        - 接口
        - Object
    3. 变量相关知识点：
        - 成员变量与局部变量
        - 实例变量与类变量
        - 静态变量
        - 变量的声名周期

---

- java面向对象知识点精华
    1. 抽象、封装、继承、多态是面向对象程序设计中的四个特点。
    2. 面向对象的软件开发大体分为：面向对象的分析，面向对象的设计，面向对象的实现。
    3. 面向对象程序设计方法的优点是：可重用性，可扩展性，可管理性。
    4. 类的定义：class前的修饰符分为访问控制修饰符和非访问控制修饰符两大类。访问控制修饰符包括public和private，非访问控制符包括abstract（抽象），final（最终）。
    5. final类是最终类，是不能有子类的类，abstract和final不能同时修饰一个类，因为抽象类本身是没有具体对象的，需要派生出子类后在创建子类对象，而最终类不可能有子类。
    6. 创建对象的格式：类名 对象名 = new 构造方法（参数）；注意前面是类名后面是构造方法。
    7. 如果class前面由public修饰符，则默认的构造方法的前面也应该有public修饰符。
    8. 类中有static修饰的域或方法，可用类名或对象名访问，否则只能用对象名访问。
    9. 修饰域的访问控制符可以是：public，private，protected，private protected。非访问控制符可以是：static，final，volatile（易失域）。
    10. 类变量的最本质的特点是：他们是类的域，不属于任何一个类的具体对象实例。
    11. 局部变量是方法体内声名的，只有当方法被调用时他们才存在，因而只能在本方法内使用，不存在访问控制符，也不能声名为静态变量（static），但可以声名为final变量，局部变量必须初始化。
    12. 修饰方法的访问控制符可以是：public，private，protected，private protected；修饰方法的非访问控制符可以是：static，final，abstract，native（本地方法），synchronized（同步方法）。
    13. 用static修饰的变量或方法都为类成员，类成员可以用类名或实例访问，实例成员只能用实例名来访问。
    14. 如果一个类中含有抽象方法，则此类为抽象类，如果抽象类的子类不为抽象类，则子类必须实现父类的所有抽象方法。抽象方法不能用静态方法和最终方法。抽象方法只有函数头的声名，而用分号来替代方法体，没有大括号。如abstract void abstractmethod();
    15. this变量用在一个方法内部，指向当前对象，当前对象值得是调用当前正在执行的方法的那个对象，super变量是直接指向父类的构造方法，用来引用父类中的变量和方法。
    16. 如果要引用一个保重的多个类，可以用星号来代替。使用星号只能标识本层次的所有类，而不包括子层次下的类。经常需要用两条语句来引入两个层次的类：import java.awt.*;improt java.awt.event.*;
    17. 关于访问修饰符：
        - 类中限定为public的成员可以被所有的类访问。
        - 类中限定为private的成员只能被这个类本身访问。
        - 类中限定为protected的成员可以被这类本身，他的子类，以及同一个包中的其他类访问。
        - 用private protected修饰的成员可以被该类本身访问，也可以被类中的所有子类访问。
        - 默认梵文控制符规定只能被同一个保重的类访问和引用，不能被其他包中的类访问。
    18. 注意：
        - abstract和private，static，final，native不能并列修饰同一个方法。
        - abstract类中不能有private修饰的域和方法。
        - static方法不能处理非static的域。
    19. 重载方法的参数必须不同，或者是参数个数不同，或者是参数类型不同，重载的多个方法必须返回相同的数据类型。
    20. 在java中，一个类获取某个接口定义的功能并不是通过直接继承这个接口的属性和方法实现的，因为接口中的属性都是常量，接口的方法都是没有方法体的抽象方法，没有具体定义操作。
- java面向对象面试案例解析
    实例：接口是否可以继承接口？抽象类是否可以实现接口？抽象类是否可以继承实体类？
**答：接口可以继承接口。抽象类可以实现接口，抽象类可继承实体类，但前提是实体类必须有明确的构造函数。**


### 二十六. jsp和servlet面试指导
1. jsp与servlet必会知识点
    http://www.jikexueyuan.com/course/1340.html
2. jsp知识精华
3. Servlet知识点精华
4. jsp和servlet面试案例

### 二十七. mysql初级面试指导
http://www.jikexueyuan.com/course/1362_3.html

1. mysql初级必会知识
- sql语句
    1. sql的增删查改基本操作
    2. sql的条件查询
    3. 查询中的order by
    4. 查询中group by和having子句
    5. 子查询
2. JDBC必会知识点
3. mysql与jdbc知识点精华
4. mysql与jdbc面试案例

[1]: http://img.willhappy.cn/18-5-3/61655971.jpg
[2]: http://img.willhappy.cn/18-5-3/61298771.jpg
[3]: http://img.willhappy.cn/18-5-3/51931414.jpg
[4]: http://img.willhappy.cn/18-5-3/55532878.jpg
[5]: http://img.willhappy.cn/18-5-3/26533636.jpg
