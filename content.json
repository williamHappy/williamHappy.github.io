{"meta":{"title":"WillHappy","subtitle":"水火","description":"Know the world, Find yourself","author":"Will","url":"http://blog.willhappy.cn"},"pages":[{"title":"404 Not Found：听首歌，稍作休息！","date":"2024-06-01T13:17:35.404Z","updated":"2024-06-01T13:17:35.404Z","comments":false,"path":"/404.html","permalink":"http://blog.willhappy.cn//404.html","excerpt":"","text":".article-title { font-size: 2.1em; } strong a { color: #747474; } .share { display: none; } .player { margin-left: -10px; } .sign { text-align: right; font-style: italic; } #page-visit { display: none; } .center { text-align: center; height: 2.5em; font-weight: bold; } .search2 { height: 2.2em; font-size: 1em; width: 50%; margin: auto 24%; color: #727272; opacity: .6; border: 2px solid lightgray; } .search2:hover { opacity: 1; box-shadow: 0 0 10px rgba(0, 0, 0, 0.3) }; .article-entry hr { margin: 0; } .pic { text-align: center; margin: 0; } .pic br { display: none; } 回主页 · 所有文章 · 留言板"},{"title":"about me","date":"2016-11-26T22:16:23.000Z","updated":"2024-06-01T13:17:35.412Z","comments":true,"path":"about/index.html","permalink":"http://blog.willhappy.cn/about/index.html","excerpt":"","text":""},{"title":"friends","date":"2019-08-16T22:15:56.000Z","updated":"2024-06-01T13:17:35.412Z","comments":true,"path":"friends/index.html","permalink":"http://blog.willhappy.cn/friends/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-08-16T22:13:54.000Z","updated":"2024-06-01T13:17:35.412Z","comments":true,"path":"categories/index.html","permalink":"http://blog.willhappy.cn/categories/index.html","excerpt":"","text":""},{"title":"tagsCloud","date":"2016-11-26T22:05:23.000Z","updated":"2024-06-01T13:17:35.412Z","comments":true,"path":"tags/index.html","permalink":"http://blog.willhappy.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"docker安装必备软件","slug":"37_2024_05_12_docker安装","date":"2024-05-12T00:39:00.000Z","updated":"2024-06-01T13:17:35.408Z","comments":true,"path":"2024/05/12/37-2024-05-12-docker-an-zhuang/","link":"","permalink":"http://blog.willhappy.cn/2024/05/12/37-2024-05-12-docker-an-zhuang/","excerpt":"docker 安装软件踩坑。","text":"docker 安装软件踩坑。 [toc] Docker安装MySQL并使用Navicat连接用docker search mysql命令来查看可用版本 拉取最新版本的MySQL镜像：注意：tag是可选的，tag表示标签，多为软件的版本，默认是latest版本（最新版） $ docker pull mysql:latest 验证MySQL镜像是否成功拉取到本地:使用以下命令来查看mysql镜像是否成功拉取到本地： $ docker images 创建并运行一个MySQL容器：$ docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root -v /Users/ctwang/home/docker/mysql/data:/var/lib/mysql -v /Users/ctwang/home/docker/mysql/config:/etc/mysql/conf.d -d mysql:latest 参数说明： --name：指定了容器的名称，方便之后进入容器的命令行。\\ -p：指在本地生成一个随机端口，用来映射mysql的3306端口。 -e：设置环境变量 MYSQL_ROOT_PASSWORD=root：指定了MySQL的root密码 -v: 指定数据文件和配置文件 -d mysql：指运行mysql镜像，设置容器在在后台一直运行。 验证MySQL容器是否创建并运行成功：$ docker ps -a 1、进入MySQL容器： $ docker exec -it mysql /bin/bash 2、进入MySQL： mysql -uroot -p Enter password：root MySQL开启远程访问权限：1、切换数据库 注意：默认应该就是这个，不切换也行，保险起见还是切换一下 2、给root用户分配远程访问权限mysql> use mysql; mysql> GRANT ALL PRIVILEGES ON *.* TO root@'%' WITH GRANT OPTION; mysql> flush privileges; 参数说明： GRANT：赋权命令 ALL PRIVILEGES：当前用户的所有权限 ON：介词 *.*：当前用户对所有数据库和表的相应操作权限 TO：介词 ‘root’@’%’：权限赋给root用户，所有ip都能连接 WITH GRANT OPTION：允许级联赋权 3、强制刷新权限 踩坑：Navicat 连接 MySQL8 报错：2059 - Authentication plugin ‘caching_sha2_password’ cannot be loaded:xxxx； 参考：传送 错误问题原因： 这是因为MySQL8之前密码加密规则为mysql_native_password，而 MySQL8 之后的加密规则为caching_sha2_password，也就是说，如果要用Navicat连接MySQL，其实只需要将密码规则改回 mysql_native_password 即可； 解决方法：1.进入MySQL数据库docker exec -it mysql-test /bin/bash mysql -uroot -p Enter password：root 2.选择数据库3.更改密码加密方式mysql> ALTER USER 'root'@'%' IDENTIFIED BY 'root' PASSWORD EXPIRE NEVER; 4.更新用户密码mysql> ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY 'root'; mysql> ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'root'; 报错：ERROR 1524 (HY000): Plugin ‘mysql_native_password’ is not loaded 问题原因参考：传送 /mysql/config/my.cnf文件添加配置项mysql_native_password=ON 完整配置： [mysqld] lower_case_table_names=1 mysql_native_password=ON 说明：lower_case_table_names=1 大小写不敏感 5.刷新权限 Navicat连接MySQL测试成功","categories":[{"name":"运维","slug":"运维","permalink":"http://blog.willhappy.cn/categories/运维/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://blog.willhappy.cn/tags/mysql/"},{"name":"docker","slug":"docker","permalink":"http://blog.willhappy.cn/tags/docker/"}]},{"title":"部署相关小记","slug":"36_2019_06_20_分布式部署问题小记","date":"2019-06-20T00:39:00.000Z","updated":"2024-06-01T13:17:35.408Z","comments":true,"path":"2019/06/20/36-2019-06-20-fen-bu-shi-bu-shu-wen-ti-xiao-ji/","link":"","permalink":"http://blog.willhappy.cn/2019/06/20/36-2019-06-20-fen-bu-shi-bu-shu-wen-ti-xiao-ji/","excerpt":"一次项目分布式部署，遇到相关问题的总结笔记。","text":"一次项目分布式部署，遇到相关问题的总结笔记。 [toc] 服务器结构图： springboot jar启动应用这个主要是在部署上层业务平台时遇到配置文件反复修改时需要重新打包，比较麻烦，所以建议，将配置文件外置，可直接服务器上修改。 配置文件加载顺序、原则SpringBoot项目启动会去扫描以下目录位置的application.yml或application.properties配置文件来加载bean。 配置文件优先级从高到低： file:./config/ - 优先级最高（项目根路径下的config，即和jar包同级目录的/config/） file:./ - 优先级第二 -（项目根路径下, 即jar包所在目录） classpath:/config/ - 优先级第三（项目resources/config下，即jar包内/classes/config/） classpath:/ - 优先级第四（项目resources根目录, 即jar包内/classes/） --- |-- springboot-demo.jar |-- BOOT-INF |-- classes |-- config |-- ③application.yml |-- ④application.yml |-- config |-- ①application.yml |-- ②application.yml 原则： 高优先级配置会覆盖低优先级配置 多个配置文件互补 小总结： 使用： > java -jar demo.jar --spring.config.location=/opt/config/application.properties 使用命令指定jar外部的配置文件或者直接配置jar包的配置文件，可以在测试或生产环境中快速地修改配置参数值，而不需要重新打包和部署应用。 另安利几篇干货： 官方springboot配置api Spring Boot 多环境配置最佳实践 Spring Boot 2.x基础教程：配置文件详解 史上最全的Spring Boot配置文件详解 内网服务器间共享挂载要实现集群之间共享的文件（静态资源）的操作，可以通过挂载方式实现。即将共享文件统一放到一台共享文件的服务器上，通过挂载的形式，访问这些共享文件。具体实现操作，参考文章 使用到的命令： // 查看磁盘挂载情况 $ df –h // 挂载 $ mount ­t nfs 192.168.0.199:/upload /home/web/upload // 取消挂载 $ umount /home/web/upload https混合http请求的问题这个问题是在视频都是使用http的，当https网站去使用http请求拉流时出现，出报错。 像这种，HTTPS页面混合不安全的HTTP请求，如何解决呢？那就是把不安全的http请求升级为https请求。方法参考文章 cdn防盗链拦截静态资源这个是在使用cdn中，去拉取flash资源存在跨域，会触发请求跨域策略文件crossdomain.xml的情况, 而在请求类似这种静态资源时，cdn如果设置了比较高级的防盗链措施，则这种请求会被拦截掉，所以，解决方案就是，在cdn防盗链配置中过滤掉对这种文件的拦截，这样就可以正常的请求到flash资源了。 进程管理Supervisor使用Supervisor是一个客户端/服务器系统，采用 Python(2.4+) 开发的，它是一个允许用户管理，基于 Unix 系统进程的 Client/Server 系统，提供了大量功能来实现对进程的管理。 安装和基本使用// 安装 $ yum install supervisor // 启动并设置开机自启 $ systemctl start supervisord.service $ systemctl enable supervisord.service 应用配置yum安装完成之后，会生成/etc/supervisord.conf主配置文件和一个/etc/supervisord.d 自配置文件目录. (1) 我们可以先在自定义配置目录创建两个文件夹conf和log来存放我们各个应用的配置和日志。 // 创建文件夹 $ cd /etc/supervisord.d && mkdir conf log // 比如创建一个manager.conf的配置 $ cd /etc/supervisord.d/conf $ vim manager.conf (2) 各应用配置自定义配置 我们现在创建一个使用springboot构建的java应用配置。 [program:manager] directory = /home/web ; 程序的启动目录 command = java -jar manager.jar ; 启动命令，与命令行启动的命令是一样的 autostart = true ; 在 supervisord 启动的时候也自动启动 startsecs = 5 ; 启动 5 秒后没有异常退出，就当作已经正常启动了 autorestart = true ; 程序异常退出后自动重启 startretries = 3 ; 启动失败自动重试次数，默认是 3 user = root ; 用哪个用户启动 redirect_stderr = true ; 把 stderr 重定向到 stdout，默认 false stdout_logfile_maxbytes = 20MB ; stdout 日志文件大小，默认 50MB stdout_logfile_backups = 20 ; stdout 日志文件备份数 ; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件） stdout_logfile = /etc/supervisord.d/log/manager.log ;日志统一放在log目录下 ; 可以通过 environment 来添加需要的环境变量，一种常见的用法是修改 PYTHONPATH ; environment=PYTHONPATH=$PYTHONPATH:/path/to/somewhere 当然，这都是一些我们基本的配置，更多配置，我们可以在官网查看。 (3) 修改主配置文件 修改主配置文件，使其包含我们自定义的应用配置文件。 $ vim /etc/supervisord.conf 在最后一行 [include] files = supervisord.d/conf/*.conf (4) 加载自定义配置文件使其生效 // 重新加载配置文件 $ supervisorctl reread // 将配置文件里新增的子进程加入进程组，如果设置了autostart=true则会启动新新增的子进程 $ supervisorctl update 其他常用命令： // other $ supervisorctl status $ supervisorctl stop $ supervisorctl start $ supervisorctl restart $ supervisorctl remove 当然，也可以输入命令 supervisorctl 进入 supervisorctl 的 shell 交互界面（还是纯命令行😓），就可以在下面输入命令了。 参考文章： 官网 Supervisor 为服务创建守护进程 Supervisor使用教程 Spring Boot 项目自动发布与Supervisor","categories":[{"name":"运维","slug":"运维","permalink":"http://blog.willhappy.cn/categories/运维/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.willhappy.cn/tags/Linux/"},{"name":"java","slug":"java","permalink":"http://blog.willhappy.cn/tags/java/"},{"name":"https","slug":"https","permalink":"http://blog.willhappy.cn/tags/https/"}]},{"title":"深入了解java虚拟机","slug":"36_2019_04_01_深入了解java虚拟机","date":"2019-04-01T22:10:10.000Z","updated":"2024-06-01T13:17:35.408Z","comments":true,"path":"2019/04/01/36-2019-04-01-shen-ru-liao-jie-java-xu-ni-ji/","link":"","permalink":"http://blog.willhappy.cn/2019/04/01/36-2019-04-01-shen-ru-liao-jie-java-xu-ni-ji/","excerpt":"系统记录jvm相关知识点，形成系统性知识结构。","text":"系统记录jvm相关知识点，形成系统性知识结构。 [toc] jvm是什么Java虚拟机（英语：Java Virtual Machine，缩写为JVM），一种能够运行Java bytecode的虚拟机，以堆栈结构机器来进行实做。Java虚拟机有自己完善的硬体架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java 虚拟机在执行字节码时,实际上最终还是把字节码解释成具体平台上的机器指令执行。 我的理解： jvm其实就是一个软件，运行于操作系统之上，当我们输入信息（字节码文件）时，它就帮我们解释成当前操作系统能理解的机器指令，由机器执行完，输出结果。这就是java程序执行的过程。 jvm的组成java虚拟机主要有四部分组成：类装载子系统（ClassLoader）、运行时数据区、执行引擎、垃圾收集. 其中我们最为关注的运行时数据区，也就是JVM的内存部分则是由方法区（Method Area）、JAVA堆（Java Heap）、虚拟机栈（JVM Stack）、程序计数器、本地方法栈（Native Method Stack）这几部分组成。 先看张详细的总图，各部分之间的联系，这张图是结合下面这段简单代码来绘制的jvm工作流程。当然，想要更进一步的理解jvm工作流程，也要学会理解分析jvm指令码（javap生成的），有必要的话，之后会总结一片分析指令码的文章（//todo）现在也可以自己使用javap命令生成下，然后对照jvm字节码指令表分析一下下面程序。 class Math { public static final Integer CONSTANT = 666; public static void main(String[] args) { Math math = new Math(); int c = math.compute(); System.out.println(c); Math math2 = new Math(); int c2 = math2.compute(); System.out.println(c2); } public int compute() { int a = 1; int b = 2; int c = (a + b) * 10; return c; } } 下面分开理解jvm各个部分。 程序计数器（Program Counter Register）也叫PC寄存器，是一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令、分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 –《深入理解Java虚拟机》 特点： 线程私有内存，每条线程都要有一个独立的程序计数器 如果线程正在执行 Java 方法，则计数器记录的是正在执行的虚拟机字节码指令的地址；如果执行 native 方法，则计数器为空 唯一一个不会出现 OutOfMemoryError 的内存区域 虚拟机栈区(JVM Stack）虚拟机栈描述了Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至完成的过程，都对应一个栈帧从入栈到出栈的过程。 –《深入理解Java虚拟机》 特点： 线程私有内存，它的生命周期与线程相同（随线程而生，随线程而灭） 在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。 –《深入理解Java虚拟机》 这部分结构最好结合代码来理解一下，比较抽象。 栈帧：执行main()方法时，创建一个栈帧，压入栈，我们称其为main()-栈帧吧，同样的，执行到compute(), 会有一个compute()-栈帧被压入栈。当compute()执行完成，那么，就伴随着compute()-栈帧出栈，main()是同样的道理。这也就符合了栈先进后出（FILO）数据结构特点。 局部变量表：一组局部变量值存储空间，用于存放方法参数和方法内部定义的局部变量。比如本例中：a=1, a=2, math, math2, …… 操作数栈：当方法刚开始执行时，这个方法的操作数栈是空的，在方法执行的过程中，会有各种字节码指向操作数栈中写入和提取值，也就是入栈与出栈操作。如：(a + b) * 10, 即是先将a的值1，压入操作数栈，将b的值2压入栈，指令执行相加变为值3（其实是2，1出栈执行相加指令得到3，把3重新压入操作数栈），再把把数值10压入栈，同样的操作，出栈相乘，把相乘的值压入栈，最后，把数值赋给局部变量，存入局部变量表。通过这样的一系列操作看，操作数栈其实就是一个进行计算操作的临时中转存储区域。 动态链接：Java虚拟机栈中，每个栈帧都包含一个指向运行时常量池中该栈所属方法的符号引用，持有这个引用的目的是为了支持方法调用过程中的动态连接(Dynamic Linking)。这些符号引用一部分会在类加载阶段或者第一次使用时就直接转化为直接引用，这类转化称为静态解析。另一部分将在每次运行期间转化为直接引用，这类转化称为动态连接。我的理解：当执行到调用方法处时，jvm是是如何找到对应的方法代码的呢？其实就是在动态链接区域存储着方法对应jvm指令码的内存地址，方法执行时，通过这个内存地址，去方法区中找到方法对应的代码指令执行（理解可能不完全准确，比较抽象，最好结合jvm指令码文件自己分析一下） 解释一：符号引用和直接引用在运行时进行解析和链接的过程，叫动态链接。 一个方法调用另一个方法，或者一个类使用另一个类的成员变量时，需要知道其名字；符号引用就相当于名字，这些被调用者的名字就存放在Java字节码文件里（.class 文件）；名字是知道了，但是Java真正运行起来的时候，如何靠这个名字（符号引用）找到相应的类和方法。 需要解析成相应的直接引用，利用直接引用来准确地找到。 方法出口：两种方式退出该方法，正常完成出口和异常完成出口。方法退出过程实际上就等同于把当前栈帧出栈，因此退出可以执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值(如果有的话)压如调用者的操作数栈中，调整PC计数器的值以指向方法调用指令后的下一条指令。 附加信息：虚拟机规范允许具体的虚拟机实现增加一些规范中没有描述的信息到栈帧之中，例如和调试相关的信息，这部分信息完全取决于不同的虚拟机实现。在实际开发中，一般会把动态连接，方法返回地址与其他附加信息一起归为一类，称为栈帧信息。 具体的关于通过javap命令生成的指令码的分析方法，可以参考：文章 本地方法栈(Native Method Stack)本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法服务（也就是字节码）服务，而本地方法栈为虚拟机使用到的Native方法服务。 –《深入理解Java虚拟机》 特点: Java虚拟机规范对本地方法栈使用的语言、使用方法与数据结构并没有强制规定，因此可以由虚拟机自由实现。例如：HotSpot虚拟机直接将本地方法栈和虚拟机栈合二为一。 同虚拟机栈相同，Java虚拟机规范对这个区域也规定了两种异常情况StackOverflowError 和 OutOfMemoryError异常。 Java堆（Java Heap）Java堆是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。 –《深入理解Java虚拟机》 特点: 线程共享内存，所有线程共享的一块内存区域 所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。参考文章 Java堆是垃圾收集器管理的主要区域，也称为GC堆.从内存回收的角度看，由于现在收集器基本都采用分代收集算法，所以Java堆可以细分为：新生代、老生代 如果在堆中没有内存完成实例分配，并且堆上也无法再扩展时，将会抛出OutOfMemoryError异常 //todo Java堆涉及到垃圾收集，会单独写文章来分析垃圾收集相关知识。 方法区（Method Area）方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆 ），目的应该是与Java堆区分开来。 –《深入理解Java虚拟机》 特点: 线程共享内存，各个线程共享的内存区域 Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样 不需要连续的内存和可以选择固定大小或者可扩展之外，还可以选择不实现垃圾回收。 这区域的内存回收目标主要是针对常量池的回收和类型的卸载，一般而言，这个区域的内存回收比较难以令人满意，尤其是类型的回收，条件相当苛刻，但是这部分区域的内存回收确实是必要的 当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常 永久代与元空间 这里区分两个概念, 有时会看到方法区被称为永久代，其实两者有着本质的区别。方法区是 JVM 规范中的定义，而永久代是 JVM 规范的一种实现，并且只有在 HotSpot 虚拟机中如此，其他虚拟机中没有永久代的说法。 在 JDK1.6 之前，HotSpot 虚拟机把 GC 分代收集扩展至方法区，或者说使用永久代实现方法区。不过永久代有 -XX:MaxPermSize 的上限，很容易遇到内存溢出问题。 所以在 JDK1.7 中，将部分数据已经转移 Java Heap 或 Native Heap 中，例如：将原本放在永久代中的字符串池和类的静态变量移出到 Java Heap 中，将符号引用转移到 Native Heap 中。但永久代仍然存在，并没有移除。 在 JDK1.8 中，取消了永久代，代替为元空间实现，它也是 JVM 规范中方法区的一种实现。不过它与永久代最大的不同是：元空间并不在虚拟机中，而是将元空间放到本地内存中。所以默认情况下，它只受本地内存的限制，可以通过 -XX:MetaspaceSize 参数设置初始空间大小，默认没有最大空间限制。 why 取消永久代 移除永久代是为融合HotSpot JVM与 JRockit VM而做出的努力，因为JRockit没有永久代，不需要配置永久代。 运行时常量池(Runtime Constant Pool)运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。 –《深入理解Java虚拟机》 特点: 动态性是运行时常量池相对于 Class 文件常量池的一个重要特征，即不要求常量一定只有编译期才能产生，运行期间也可能将新的常量放入池中，比如String类的intern()方法 运行时常量池受到方法区内存的限制，如果常量池无法再申请内存，就会抛出 OutOfMemoryError 异常。 直接内存直接内存不是运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域, 是利用 Native 函数库在 Java 堆外申请分配的内存区域.比如 NIO 中的 DirectByteBuffer 就可以作为这块内存的引用进行操作直接内存. 特点: 避免在 Java 堆和 Native 堆中复制数据以提高性能 这一部分内存也被频繁使用，而且也有可能导致OutOfMemoryError异常出现 内存的分配不受Java堆大小的限制，但是他还是会收到服务器总内存的影响","categories":[{"name":"后端","slug":"后端","permalink":"http://blog.willhappy.cn/categories/后端/"}],"tags":[{"name":"interview","slug":"interview","permalink":"http://blog.willhappy.cn/tags/interview/"},{"name":"jvm","slug":"jvm","permalink":"http://blog.willhappy.cn/tags/jvm/"}]},{"title":"mysql全文索引","slug":"35_2018-09-13_mysql全文索引","date":"2018-09-13T00:00:00.000Z","updated":"2024-06-01T13:17:35.408Z","comments":true,"path":"2018/09/13/35-2018-09-13-mysql-quan-wen-suo-yin/","link":"","permalink":"http://blog.willhappy.cn/2018/09/13/35-2018-09-13-mysql-quan-wen-suo-yin/","excerpt":"由前面倒排索引延申过来，做一个学习记录，方便以后使用到对大规模文档的关键字搜索服务。","text":"由前面倒排索引延申过来，做一个学习记录，方便以后使用到对大规模文档的关键字搜索服务。 [toc] 前言mysql索引类型 primary 唯一索引，不允许为null NORMAL 普通非唯一索引 UNIQUE 表示唯一的，不允许重复的索引，可以为null FULLTEXT 表示全文搜索的索引。 FULLTEXT用于搜索很长一篇文章的时候，效果最好。用在比较短的文本，如果就一两行字的，普通的INDEX 也可以 SPATIAL 只有MyISAM引擎支持，并且支持的不好。可以忽略 mysql索引方法 HASH BTREE 区别详见文章1, 文章2 全文索引我们应用里面经常要用到搜索功能，一般简单的搜索功能我们使用MySQL的关键字Like实现模糊查询即可，但使用Like语句一般不会使用到索引，在数据量大的时候效率会大大降低，亦或我们需要全文搜索的时候，这个时候索引就变得特别重要。 更多… MySQL支持三种模式的全文检索模式： 自然语言模式（IN NATURAL LANGUAGE MODE） 布尔模式（IN BOOLEAN MODE） 查询扩展模式 （WITH QUERY EXPANSION） 参考文档： 官方文档 MySql全文索引详解 全文检索 关于索引使用的注意事项参考： mysql索引需要了解的几个注意 总结关于一点，全文检索，对于我们需求，也就是刚开始提到的根据视频名称或文章名称模糊查询，有没有必要使用全文检索呢? 个人看法： 前期项目数据量不大，可以使用普通索引，like模糊查询解决 后期数据量上来了，可以自己去维护倒排索引，定时维护，查询去查倒排索引，至于分词可能有些疑惑 小规模文本（像文章名称这些），尽量避开全文索引，可能全文索引对大规模文本，效果较好 关于一个查询，可以引出一系列的知识点，这仅仅是大数据量查询的起点基础而已，后面还需要再进行知识的深入，基础知识只做备忘处理，关键在与后期在基础上的深入理解学习，才能达到融会贯通。","categories":[{"name":"后端","slug":"后端","permalink":"http://blog.willhappy.cn/categories/后端/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://blog.willhappy.cn/tags/mysql/"}]},{"title":"搜索引擎算法-倒排索引","slug":"34_2018-09-12_搜索引擎算法-倒排索引","date":"2018-09-12T00:00:00.000Z","updated":"2024-06-01T13:17:35.408Z","comments":true,"path":"2018/09/12/34-2018-09-12-sou-suo-yin-qing-suan-fa-dao-pai-suo-yin/","link":"","permalink":"http://blog.willhappy.cn/2018/09/12/34-2018-09-12-sou-suo-yin-qing-suan-fa-dao-pai-suo-yin/","excerpt":"由于公司需要从海量的视频资源中快速搜索到相关性高的视频，中间考虑过like的使用，由于需要取得多张表的资源并集，并进行like匹配还有其他条件的匹配，但是这样如果数据量上去的话，查询效率是极低的；然后，后面有同学提到使用维护倒排索引的方案解决，所以，特此查看此解决方案；在这个过程中，也有看到过使用mysql的全文索引解决mysql大数据量搜索的方案，但是，mysql全文索引针对大篇幅文档的搜索效果是好的，比较简短的文档，搜索效果可能一般，但是，秉着举一反三地思想，我们后面会开一篇mysql全文索引的文章。","text":"由于公司需要从海量的视频资源中快速搜索到相关性高的视频，中间考虑过like的使用，由于需要取得多张表的资源并集，并进行like匹配还有其他条件的匹配，但是这样如果数据量上去的话，查询效率是极低的；然后，后面有同学提到使用维护倒排索引的方案解决，所以，特此查看此解决方案；在这个过程中，也有看到过使用mysql的全文索引解决mysql大数据量搜索的方案，但是，mysql全文索引针对大篇幅文档的搜索效果是好的，比较简短的文档，搜索效果可能一般，但是，秉着举一反三地思想，我们后面会开一篇mysql全文索引的文章。 [toc] 前言介绍倒排索引是一种索引方法，被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射，常被应用于搜索引擎和关键字查询的问题中。 见名知其意，有倒排索引（inverted index），就有正排索引（forward index），我们主要举例来看区别，加深理解。 以英文为例，下面是要被索引的文本： T0 = \"it is what it is\" T1 = \"what is it\" T2 = \"it is a banana\" 我们就能得到下面的反向文件索引： \"a\": {2} \"banana\": {2} \"is\": {0, 1, 2} \"it\": {0, 1, 2} \"what\": {0, 1} 正向索引是用来存储每个文档的单词列表，即通过文档编号可以查询到关键字的集合；而反向索引则是通过关键词来找到关键词所在的文档，可以迅速定位到关键字对应的文档列表。 单词——文档矩阵单词-文档矩阵是表达两者之间所具有的一种包含关系的概念模型| 关键字/文档 | 文档1 | 文档2 | 文档3 | 文档4 ||:———-:|:—–:|:—–:|:—–:|:—–:|| 关键字1 | √ | | √ | || 关键字2 | | √ | | || 关键字3 | | √ | √ | || 关键字4 | √ | | | √ || 关键字5 | | √ | √ | || 关键字6 | √ | √ | | √ | 从纵向即文档维度来看，是每个文档包含了哪些关键字，即是正常的我们查询文档，可以查看关键字列表，如文档1中有关键词1，4，6；从横向即关键字维度来看，是每个关键字在哪些文档中出现过，即是我们通过关键字快速查询到相关的文档，如关键字4在文档1，4中出现，快速定位到文档列表。 搜索引擎的索引其实就是实现“单词-文档矩阵”的具体数据结构。可以有不同的方式来实现上述概念模型，比如“倒排索引”、“签名文件”、“后缀树”等方式。但是各项实验数据表明，“倒排索引”是实现单词到文档映射关系的最佳实现方式。 总结来看： 正排索引：文档编号到关键字的关联关系倒排索引：关键字到文档编号的关联关系 倒排索引-查询过程查询包含某关键字的文档 通过倒排索引获得某关键字对应的文档id列表 通过正排索引查询id列表对应文档的完整内容 返回最终结果 倒排索引-重要组成部分 单词词典(Term Dictionary) 倒排列表(PostingList) 单词词典：单词词典是倒排索引中非常重要的组成部分，它用来维护文档集合中出现过的所有单词的相关信息，同时用来记载某个单词对应的倒排列表在倒排文件中的位置信息。在支持搜索时，根据用户的查询词，去单词词典里查询，就能够获得相应的倒排列表，并以此作为后续排序的基础。 倒排列表:倒排列表记载了出现过某个单词的所有文档的文档列表及单词在该文档中出现的位置信息，每条记录称为一个倒排项(Posting)。根据倒排列表，即可获知哪些文档包含某个单词。倒排列表的更多，参考文章中关于倒排列表的部分。 单词词典-常用数据结构 哈希加链表结构 树形词典结构 对于一个规模很大的文档集合来说，可能包含几十万甚至上百万的不同单词，能否快速定位某个单词，这直接影响搜索时的响应速度，所以需要高效的数据结构来对单词词典进行构建和查找. 关于这两种数据结构的介绍，请查看文章，在这里就不再重复了。 如何得到单词列表-分词如何通过一篇大规模的文档得到我们的关键字词典，就需要用到分词技术，通常在创建文档和更新文档时来进行分词的操作。 关于分词的知识点请关注文章,介绍的很详细，关键是中文和英文分词的区别。 声明：感谢学习期间，各位博主文章的启发，特此声明本文章只做学习记录使用。参考文档： 什么是倒排索引？ Elasticsearch 6.x 倒排索引与分词","categories":[{"name":"大数据","slug":"大数据","permalink":"http://blog.willhappy.cn/categories/大数据/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://blog.willhappy.cn/tags/算法/"}]},{"title":"gitlab搭建端口配置踩坑和ssh多账户配置解读","slug":"31_2018-07-03_gitlab搭建踩坑和ssh多账户配置解读","date":"2018-07-03T00:00:00.000Z","updated":"2024-06-01T13:17:35.408Z","comments":true,"path":"2018/07/03/31-2018-07-03-gitlab-da-jian-cai-keng-he-ssh-duo-zhang-hu-pei-zhi-jie-du/","link":"","permalink":"http://blog.willhappy.cn/2018/07/03/31-2018-07-03-gitlab-da-jian-cai-keng-he-ssh-duo-zhang-hu-pei-zhi-jie-du/","excerpt":"因为公司刚开展新项目，之前都是使用的svn,现在转成git进行版本控制，虽然自己之前很久开始使用git，但是对于git的https和ssh两种传输方式只是一知半解，也造就了今天发时间去搞清楚这个东西，时间搭了，搞清楚也是值得的，对以后自己工作的顺利开展还是有帮助的，所以也在此记录，可能主要记录过程，以参考别人文章为主，都是有用文章，避免以后查看费劲，长时间的资料过滤，不划算。","text":"因为公司刚开展新项目，之前都是使用的svn,现在转成git进行版本控制，虽然自己之前很久开始使用git，但是对于git的https和ssh两种传输方式只是一知半解，也造就了今天发时间去搞清楚这个东西，时间搭了，搞清楚也是值得的，对以后自己工作的顺利开展还是有帮助的，所以也在此记录，可能主要记录过程，以参考别人文章为主，都是有用文章，避免以后查看费劲，长时间的资料过滤，不划算。 [toc] 一. 关于gitlab搭建gitlab搭建是由同事搭建完成，所以并未参与，这里只附比较高质量的教程。下面教程都是基于docker搭建的gitlab. gitlab官方教程：GitLab Docker images掘金：通过 docker 搭建自用的 gitlab 服务 ❗注：教程中在做端口映射的时候，都将容器的22端口映射到宿主机的22端口，但是很可能这个docker容器是创建不成功的，为什么呢？ 因为22端口是被占用的，我们登陆远程主机是通过22端口的，所以不会创建成功的。至于解决方案，参考一下文章： Docker 部署 GitLab#2.修改ssh和nginx端口 但是这样又有一个比较恶心的问题，重启docker服务后，再登陆gitlab你会发现，ssh地址上出现:2222加上端口访问的地址，看着很恶心。解决方案，参考下面文章（可以自己测试，我没测试，比较麻烦，原谅我比较懒）： Gogs与Linux共享SSH22端口Docker运行Gitlab与Host共享22端口 📌总结： 关于使用docker搭建gitlab整体过程相对简单，可能坑就在端口号的处理上，特别是22端口； 如果不在docker中搭建gitlab的话，对于22端口来说，如果host开放了，就不需要格外配置了，gitlab使用默认配置即可。 二. ssh多账户配置解读使用场景❓why: 我们可能有自己的github，公司的gitlab等都需要ssh key, 当然我们都可以使用同意公钥来进行配置，但是，为了安全，我们对每个账户来分别配置公钥私钥。 ssh原理及必要说明阮一峰：SSH原理与运用简书：图解SSH原理 ❗注：文章中有关于各个关于ssh的名词解释，仔细阅读。 ssh多账户配置说明及实践知乎：ssh、git与多账户掘金：https://juejin.im/post/5a8fe5d4f265da4e710f7042多个 git 账号的 ssh 配置 ❗注：知乎的那篇文章要重点度，写的很好，因为网上大部分关于git多账户的解释都是模糊的，或者说有问题的。 📌总结： 重点说下~/.ssh/conf文件，自己测试： Host: 我们任意起名，但不可重复，尽量和Hostname保持一致，方便git clone等操作，不用修改地址，针对gitlab,github等，如果连接的是远程主机，可起简单点的名字，方便链接 Hostname: 真实的主机域名或者IP地址，要与Host区分开来 User: 登陆主机用户名, 像github,gitlab等服务提供商固定为git,默认为git 参考知乎那篇文章，充分理解这几个字段的意思，很重要 配置git本地的用户名和email # 取消全局 用户名/邮箱 配置 $ git config –global –unset user.name $ git config –global –unset user.email # 查看全局用户名/email $ git config –global user.name $ git config –global user.email # 单独设置每个repo 用户名/邮箱 $ git config user.name 'xxxx' $ git config user.email 'xxxx@xx.com' ok, 在此记录，感觉各位作者带来的高质量文章，丰富了我的知识，再次感谢！","categories":[{"name":"cvs","slug":"cvs","permalink":"http://blog.willhappy.cn/categories/cvs/"}],"tags":[{"name":"git","slug":"git","permalink":"http://blog.willhappy.cn/tags/git/"}]},{"title":"【转】2018文章分享","slug":"32_2018-07-01_share","date":"2018-07-01T00:00:00.000Z","updated":"2024-06-01T13:17:35.408Z","comments":true,"path":"2018/07/01/32-2018-07-01-share/","link":"","permalink":"http://blog.willhappy.cn/2018/07/01/32-2018-07-01-share/","excerpt":"自己查资料阅读到写的比较好的文章分享出来大家一起看。也欢迎大家支持原创！同时也方便自己以后查阅翻看。","text":"自己查资料阅读到写的比较好的文章分享出来大家一起看。也欢迎大家支持原创！同时也方便自己以后查阅翻看。 [toc] 前言 分享页分为几大类：项目构建,框架,前端,后端等 可在本页面使用Ctrl+F按日期搜索，也可以按主题搜索，ex: 2018/07/01, java 每大类按日期降序排列 项目构建2018/07/01-Maven Maven实战——多模块项目的POM重构2018/09/04-url 从输入 URL 到页面加载完成的过程中都发生了什么事情？ 框架2018/07/01-spring spring中bean配置和bean注入2018/07/01-RabbitMQ RabbitMQ的应用场景以及基本原理介绍2018/07/01-SpringWorld SpringBoot+zk+dubbo架构实践2018/09/03-日志 slf4j log4j logback关系详解和相关用法2018/09/04-日志 Spring Boot干货系列：（七）默认日志logback配置解析 前端2018/07/01-前端 一起理解 Virtual DOM2018/07/01-前端 单页应用开发权威指南2018/07/01-vue 搭建 vue2 vue-router2 webpack3 多入口工程2018/07/13-兼容性 Chrome 中 scrollingElement 的变化2018/08/30-跨域 CORS 跨域 实现思路及相关解决方案 后端2018/07/01-java Java内存模型(需科学上网)2018/08/16-Java多线程系列 Java多线程系列–“JUC锁”09之 CountDownLatch原理和示例 测试2018/12/03-单元测试 单元测试之旅：预见优秀 API2018/12/03-java8新特性 Java 8新特性终极指南2018/12/03-java8新特性 深入理解Java 8 Lambda 工具2018/07/23-git Git 撤销合并2018/07/23-git Git使用revert命令撤销合并2018/07/23-git 解决Git Revert操作后再次Merge代码被冲掉的问题2018/07/26-git master、origin master 与 origin/master 有什么区别","categories":[{"name":"分享","slug":"分享","permalink":"http://blog.willhappy.cn/categories/分享/"}],"tags":[{"name":"articles","slug":"articles","permalink":"http://blog.willhappy.cn/tags/articles/"}]},{"title":"前端基础知识工作归结","slug":"33_2018-06-15_前端基础归结","date":"2018-06-15T00:00:00.000Z","updated":"2024-06-01T13:17:35.408Z","comments":true,"path":"2018/06/15/33-2018-06-15-qian-duan-ji-chu-gui-jie/","link":"","permalink":"http://blog.willhappy.cn/2018/06/15/33-2018-06-15-qian-duan-ji-chu-gui-jie/","excerpt":"","text":"[toc] 前言由于工作需要，所以巩固一下前端的基础知识，因为不是专职前端coder，所以补的都是基础的基础，勿喷…😭 1. jquery给动态生成的元素添加绑定事件$(parentSelector).on('event', childSelector, function(){ ... }) 说明：选择动态元素的某个父级静态元素来绑定，父级元素必须为静态的，否则不效果 2. append,prepend,after,before区分Ex: &lt;script type=\"text/javascript\" src=\"http://common.jb51.net/jslib/jquery/jquery.min.js\">&lt;/script> &lt;div class=\"testdiv\"> &lt;ul> &lt;li>第一个li标签&lt;/li> &lt;/ul> &lt;/div> &lt;script> //append $('.testdiv ul').append('&lt;li>append 插入的li&lt;/li>'); //prepend $('.testdiv ul').prepend('&lt;li>prepend 插入的li&lt;/li>'); //after $('.testdiv ul').after('&lt;li>after 插入的li&lt;/li>'); //before $('.testdiv ul').before('&lt;li>before 插入的li&lt;/li>'); &lt;/script> 运行结果： &lt;div class=\"testdiv\"> &lt;li>before 插入的li&lt;/li> &lt;ul> &lt;li>prepend 插入的li&lt;/li> &lt;li>第一个li标签&lt;/li> &lt;li>append 插入的li&lt;/li> &lt;/ul> &lt;li>after 插入的li&lt;/li> &lt;/div> 3. js中的 || 与 &amp;&amp; 运算符这个都不会，是不是该打脸… 公式表达式a &amp;&amp; 表达式b :计算表达式a（也可以是函数）的运算结果，如果为 True, 执行表达式b（或函数），并返回b的结果；如果为 False，返回a的结果； 表达式a || 表达式b :计算表达式a（也可以是函数）的运算结果，如果为 Fasle, 执行表达式b（或函数），并返回b的结果；如果为 True，返回a的结果； 转换规则对象为true；非零数字为true；零为false;非空字符串为true；空字符串为法false;undefined为false其他为false； Ex: var a = obj || \" \" ; //如果 obj 为空，a就赋值为 “ ” ； var a = check() &amp;&amp; do(); //如果check()返回为真，就执行do()，并将结果赋值给 a; ||和&amp;&amp; 运算符的优先级参考文章 4. js匿名函数的使用实际上这两种写法都是匿名函数的写法。第一种写法 var x = ( function( ){ … })( … ); 比较常见，它是先声明匿名函数，再执行。第二种写法 var x = ( function( ){ … }( … ) ); 它是先强制执行表达式。（在js中，圆括号运算符与[]、.运算符具有最高的优先级）其实你调试一下就知道了 var x = (function(){ alert(\"你看不见我执行\"); return 1; }) console.log(x); var x = (function(){ alert(\"竟然被你看见了\"); return 1; })(); console.log(x); var x = (function(){ alert(\"竟然又被你看见了\"); return 1; }()) console.log(x); 5. onlick onsubmit submit 的执行顺序&lt;form action=\"#\" method=\"POST\" name=\"A\" onsubmit=\"return X();\"> &lt;input type=\"text\" value=\"\" /> &lt;input onclick=\"Y()\" type=\"submit\" value=\"提交\" /> &lt;/form> 自己写X()、Y()函数，我们会发现，这几个函数的执行顺序 1) onclick: Y()2) onsubmit: X()3) submit() 只要 onclick 未 return false 那么就继续执行 onsubmit只要 onsubmit 未return false 那么表单就被提交出去了另外一点写法上注意一定要 “return X();” 才能取得函数的返回值，否则只是调用函数，返回值未被传递 正确写法： &lt;!-- X() 返回false后，form的submit会被终止 --> &lt;input type=submit onclick=”return X();”> 6. JavaScript 之 回调函数的返回值给全局变量赋值问题jQuery 中，会遇到$.get(url,data,callback,type) 或 $.post(url,data,callback,type) 返回值给全局变量赋值的问题： 例如: &lt;script language=\"JavaScript\"> var count= 1; $.post( \"&lt;%=path%>/AdminCenter/SysFunction/GetOrderNo\", { parentCode: pc }, function (data) { count = data.result; }, \"json\"); alert(count); &lt;/script> 问题：想用JavaScript 取testController中GetIsExist的值，赋给test.aspx中的全局变量 count，可是返回的值只在$.getJSON中起作用count为8,在全局中显示时仍为1,请问该问题如何解决？ 问题原因：Ajax是默认都是异步JavaScript&amp;XML，浏览器解析页面时，JS只管执行当前代码，顺序执行。发送请求了，那是请求响应的事，它不管这些，只管继续执行在它面前的代码，所以不等Ajax响应返回，便会继续向下执行，这时你的全局 count 仍然是初始值（在这里为1），如果你在回调函数function(data){}内部alert的话，就会是8了。 方法一：直接在回调函数中实现操作 &lt;script language=\"JavaScript\"> var count= 1; $.post( \"&lt;%=path%>/AdminCenter/SysFunction/GetOrderNo\", { parentCode: pc }, function (data) { count = data.result; alert(count); }, \"json\"); &lt;/script> 方法二：在回调函数外实现,把异步改为同步 async: false &lt;script language=\"JavaScript\"> var count= 1; $.ajax({ url: \"&lt;%=path%>/AdminCenter/SysFunction/GetOrderNo\", async: false, //改为同步方式 type: \"POST\", data: { parentCode: pc }, success: function (data) { count = data.result; }, dataType:\"json\" }); alert(count); &lt;/script> 7. jQuery中$.fn的用法示例介绍$.fn是指jquery的命名空间，加上fn上的方法及属性，会对jquery实例每一个有效，如扩展$.fn.abc(),即$.fn.abc()是对jquery扩展了一个abc方法,那么后面你的每一个jquery实例都可以引用这个方法了.那么你可以这样子：$(“#div”).abc(); jQuery为开发插件提拱了两个方法，分别是： jQuery.extend(object);为扩展jQuery类本身.为类添加新的方法。jQuery.fn.extend(object);给jQuery对象添加方法。 fn是什么东西呢。查看jQuery代码，就不难发现。复制代码 代码如下: jQuery.fn = jQuery.prototype ={ init: function( selector, context ){//.... //...... }; 原来 jQuery.fn =jQuery.prototype.对prototype肯定不会陌生啦。jQuery便是一个封装得非常好的类，比如我们用语句 $(“#btn1”) 会生成一个 jQuery类的实例。 jQuery.extend(object); 为jQuery类添加添加类方法，可以理解为添加静态方法。如：复制代码 代码如下: $.extend({ add:function(a,b){return a+b;} }); 便为 jQuery 添加一个为add 的“静态方法”，之后便可以在引入 jQuery 的地方，使用这个方法了， $.add(3,4); //return 7 jQuery.fn.extend(object);对jQuery.prototype进得扩展，就是为jQuery类添加“成员函数”。jQuery类的实例可以使用这个“成员函数”。比如我们要开发一个插件，做一个特殊的编辑框，当它被点击时，便alert当前编辑框里的内容。可以这么做： jQuery代码复制代码 代码如下: $.fn.extend({ alertWhileClick: function(){ $(this).click(function(){ alert($(this).val()); }); } }); 参考： jQuery.fn和jQuery.prototype区别jQuery.prototype的含义.extend()方法和(function(){})(jQuery)详解$(function(){})和(function(jq){})(jQuery)区别 8. JavaScript unshift() 方法9. form表单提交,ajaxForm()提交,ajaxSubmit()提交区别参考另一篇文章 10. avalon.mix(),$.extend(),Ojbect.assign(),js合并两个对象的不同点参考: 关于$.extend()深拷贝和浅拷贝Ojbect.assign()","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.willhappy.cn/categories/前端/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://blog.willhappy.cn/tags/基础/"}]},{"title":"主页部署docker+ng+tomcat+https","slug":"30_2018-06-13_主页部署docker+ng+tomcat+https","date":"2018-06-13T00:00:00.000Z","updated":"2024-06-01T13:17:35.408Z","comments":true,"path":"2018/06/13/30-2018-06-13-zhu-ye-bu-shu-docker-ng-tomcat-https/","link":"","permalink":"http://blog.willhappy.cn/2018/06/13/30-2018-06-13-zhu-ye-bu-shu-docker-ng-tomcat-https/","excerpt":"上一章docker初识结合docker的文档，将博客主页所需的生产环境镜像及容器准备好了，这一章主要是写一些在博客部署到线上时出现的一些问题，从而对使用容器部署有一个更深层次的理解。","text":"上一章docker初识结合docker的文档，将博客主页所需的生产环境镜像及容器准备好了，这一章主要是写一些在博客部署到线上时出现的一些问题，从而对使用容器部署有一个更深层次的理解。 [toc] 前言之前想着是使用一个纯净的linux镜像，然后使用dockerfile构建一个自己博客环境镜像的，但是自己的水平有限，目前就使用拉去官方镜像，进行一些配置，已达到自己的生产环境需求。后面有机会学习的话，会构建一个自己的镜像出来，期待ing。 另外，我是使用的服务器是google平台，搭建的服务器环境是基于debian(stretch 9.4)，所以很多相关的服务器操作和centos有所不同，比如包管理工具apt-get,vim(需要安装,iptables) 一. 博客部署到tomcat容器这个还是比较简单的，前面一章, 我们已经将主机中目录下的/usr/lcoal/docker/tomcat/apps挂载到容器的/apps, 那么我们可以直接将war包放到/usr/local/docker/tomcat/apps目录下，即可进入容器内部，然后进行相关配置。 $ cd /usr/local/docker/tomcat/apps # 上传博客war包 # 进入tomcat 容器 $ docker exec -it tomcat_will /bin/bash # tomcat容器shell操作，进入容器后，直接是在/usr/local/tomcat/目录下 # 进入webapps/apps/目录下，会发现我们刚刚上传到宿主机的war包，把他移动到webapps目录下，会自动解压缩 # 进入/usr/local/tomcat/conf/目录下，配置server.xml文件 配置server.xml文件： &lt;Host name=\"localhost\" appBase=\"webapps\" unpackWARs=\"true\" autoDeploy=\"true\" xmlValidation=\"false\" xmlNamespaceAware=\"false\"> &lt;Context path=\"\" docBase=\"/usr/local/tomcat/webapps/XX你的项目名\" reloadable=\"true\" /> &lt;/Host> 推出tomcat容器，回到宿主机 # 重启tomcat容器 $ docker resatrt tomcat_will 测试访问：http://35.197.142.179:8080/ ，如果访问到你的项目说明部署成功。如果出现无法访问的情况，请查看是否开放服务器端口号。可使用站长工具的端口扫描工具来查看是否真正开放。google平台的话，可在vpc网路中创建防火墙规则来开放端口号。 二. nginx+https相关配置如果单纯只是http配置的话，相对简单，可参考文章, 这里我们重点介绍结合配置https. 说明docker的nginx容器，配置文件在/etc/nginx目录下，有nginx.conf主配置文件，会加载conf.d/*.conf目录的所有配置文件，通过nginx.conf可以看出。 http { ... include /etc/nginx/conf.d/*.conf; ... } 这也就是为什么我们在运行容器的时候，挂载server.conf到conf.d/目录下，这样可以通过主配置文件将其加载进来，我们就可直接在宿主机上目录下更改server.conf.当然，这仅限于更改http块里面的内容。 另外参考我的另一篇文章来配置https,因为知道在哪里配置，配置的内容自然就差不多了。 上传证书通过我们挂在目录，我们将证书上传docker容器，挂载文件主要是方便容器和宿主机的文件共享，避免了频繁的在宿主机和容器间进行文件的拷贝。 # 进入daocker nginx容器 $ docker exec -it nginx_will_v2 /bin/bash # 为了方便，我们把证书文件统一放到/etc/nginx/cert目录下 修改配置配置挂载文件/etc/nginx/conf.d/server.conf，当然可在容器内修改，也可在宿主机上修改，文件是共享的（我的理解，没有完全实践）。server.conf添加内容如下： # 和我们前面文章中的https配置基本一致，需要更改的就是upstream中的server,更改为你的ip地址，因为容器的隔离技术，再使用localhost可能转发失败（可自己尝试）。 server { listen 80; listen 443; server_name willhappy.cn; #拦截的域名 ssl on; root html; index index.html index.htm; ssl_certificate cert/XX.pem; #你自己申请的证书文件 ssl_certificate_key cert/XX.key; #私钥文件 ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / { proxy_pass http://whome; #提供数据服务的服务器 proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } } upstream whome{ server ip地址:8080; } 访问测试通过 https://willhappy.cn/ ，访问到自己的项目即表示配置成功。 自己挖的坑通过nginx容器名称（nginx_will_v2）可以看到，这是我运行的第二个容器，第一个容器，我在创建时只开放了80端口，所以当一切都配置好之后，发现通过443端口（也就是通过https方式）访问，怎么都无法访问。第一时间想到的时宿主机没有开放443端口，没想到容器的443端口没有映射到443端口上，通过在google云平台配置防火墙，开放443端口，但是，依然无效，这时就陷入了一个巨大的坑，难道云平台上配置无效？那就去服务器上手动开放443端口。鉴于服务器是debian版本，iptables配置有所不同，结果去单独配置443端口时，把其他的端口全都抹掉了，其中包括docker和宿主机的防火墙设置都清除掉，导致容器都无法启动。这中间经历艰辛，无从言起，记录下，避免下次再出现。 不明原理，贸然根据网上教程更改服务器（debian）的iptables配置。更改参考文章1,文章二, 根据这两篇文章修改，虽然没有最终完成修改，但是依然更改了端口号的配置。发现情况不妙；发现情况不妙后，准备恢复防火墙设置，参考iptables配置, 因为不知道哪个是原来防火墙的最终配置，所以选择了/etc/iptables.up.rules进行恢复。从文件恢复IPtables规则： sudo iptables-restore < iptables.up.rules 这样虽然挽回了部分端口规则，但是docker的防火墙规则被破坏，出现了问题2. docker 启动容器报”No chain/target/match by that name”错误，无法启动容器。同样参考了几篇文章：文章，但是都是基于centos修改防火墙规则的，但是已经不敢再去动debian的规则了，怕再出问题。所以继续找。google搜索最终看到一种解决方法,即重启docker服务，即可自动恢复docker关于防火墙的配置，测试，最终解决，QAQ。 # 重启docker服务，须在所有容器停止后重启 $ sudo systemctl restart docker 至此，debian防火墙规则恢复到原来的状态，冷静下来后，恍然发现，是因为nginx容器的443端口没有映射到宿主机上，再次泪奔，问题忽然这么明朗、容易，或许，总是要经历些什么，才能成长吧！ # 重新创建运行开放80和443端口的容器，这才有了nginx_will_v2这个容器 $ docker run -p 80:80 -p 443:443 --name nginx_will_v2 -v $PWD/conf/server.conf:/etc/nginx/conf.d/server.conf -v $PWD/www:/www -v 访问 https://willhappy.cn/ 测试成功。 解决过程艰辛，关于debian系统的各种骚操作，还得要深入学习，传送debian官网, 不然，随便一操作，那都是一个坑啊，泪奔。 more关于nginx, 可参考nginx中文文档,查看相关参数说明。通过nginx配置更多负载均衡，动静分离，参考文章 后记相关命令 lsb_release -a #查看debian版本信息 sudo systemctl restart docker #重启docker服务（debian）须在所有容器停止后重启 相关工具 站长工具: 本章所用功能-&gt;端口扫描 debian官网: 关于iptables部分","categories":[{"name":"运维","slug":"运维","permalink":"http://blog.willhappy.cn/categories/运维/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.willhappy.cn/tags/Linux/"},{"name":"https","slug":"https","permalink":"http://blog.willhappy.cn/tags/https/"},{"name":"docker","slug":"docker","permalink":"http://blog.willhappy.cn/tags/docker/"},{"name":"nginx","slug":"nginx","permalink":"http://blog.willhappy.cn/tags/nginx/"}]},{"title":"docker初识（博客环境准备）","slug":"29_2018-06-11_docker初识","date":"2018-06-11T00:00:00.000Z","updated":"2024-06-01T13:17:35.408Z","comments":true,"path":"2018/06/11/29-2018-06-11-docker-chu-shi/","link":"","permalink":"http://blog.willhappy.cn/2018/06/11/29-2018-06-11-docker-chu-shi/","excerpt":"为什么要开始学习docker呢？主要是自己博客home页部署在同事的阿里云上，但是，目前他的服务器已经快到期，所以我要对我的主页迁移，但是想到重现搭建生产环境的不确定性，决定研究下docker,同时也方便以后博客主页的迁移，也没必要为生产环境的不确定性承担风险。","text":"为什么要开始学习docker呢？主要是自己博客home页部署在同事的阿里云上，但是，目前他的服务器已经快到期，所以我要对我的主页迁移，但是想到重现搭建生产环境的不确定性，决定研究下docker,同时也方便以后博客主页的迁移，也没必要为生产环境的不确定性承担风险。 [toc] 一. docker安装关于docker的大部分学习来源docker实践,安装方法参考此pdf文档, 也可参考在线文档。 二. docker web环境搭建此生产环境的搭建是基于我的blog的，所需的软件java,tomcat,nginx,mysql等；另外软件的安装方法大概有两种，一是通过dockerfile去构建，二就是通过拉去dockerHub的官方镜像来构建，因为刚开始学习，所以主要通过拉去官方镜像来构建。 安装 MySQL查找Docker Hub上的mysql镜像 $ docker search mysql NAME DESCRIPTION STARS OFFICIAL AUTOMATED mysql MySQL is a widely used, open-source relation… 6349 [OK] mariadb MariaDB is a community-developed fork of MyS… 1993 [OK] mysql/mysql-server Optimized MySQL Server Docker images. Create… 456 [OK] percona Percona Server is a fork of the MySQL relati… 343 [OK] zabbix/zabbix-server-mysql Zabbix Server with MySQL database support 101 [OK] hypriot/rpi-mysql RPi-compatible Docker Image with Mysql 87 ... 这里我们拉取官方的镜像,标签为5.7.22 docker pull mysql:5.7.22 等待下载完成后，我们就可以在本地镜像列表里查到REPOSITORY为mysql,标签为5.7.22的镜像。 使用镜像 运行容器MySQL(5.7.19)的默认配置文件是 /etc/mysql/my.cnf 文件。如果想要自定义配置，建议向 /etc/mysql/conf.d 目录中创建 .cnf 文件。新建的文件可以任意起名，只要保证后缀名是 cnf 即可。新建的文件中的配置项可以覆盖 /etc/mysql/my.cnf 中的配置项。具体操作：首先需要创建将要映射到容器中的目录以及.cnf文件，然后再创建容器 $ pwd /opt $ mkdir -p docker_v/mysql/conf $ cd docker_v/mysql/conf $ touch my.cnf $ docker run -p 3306:3306 --name mysql -v /opt/docker_v/mysql/conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456 -d imageID 命令说明： -p 3306:3306：将容器的3306端口映射到主机的3306端口 -v /opt/docker_v/mysql/conf:/etc/mysql/conf.d：将主机/opt/docker_v/mysql/conf目录挂载到容器的/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456：初始化root用户的密码 -d: 后台运行容器，并返回容器ID imageID: mysql镜像ID 查看容器运行情况 $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 1d7dd4ffba73 mysql:5.7.22 \"docker-entrypoint.s…\" 46 hours ago Up 46 hours 0.0.0.0:3306->3306/tcp mysql_will 使用navicat连接mysql 类似，首先在云服务器控制面板上开放mysql端口号，然后进行连接测试，如果还是连接不上，查看mysql是否开启远程访问权限。 安装 nginx并配置查找Docker Hub上的nginx镜像 $ docker search nginx NAME DESCRIPTION STARS OFFICIAL AUTOMATED nginx Official build of Nginx. 8785 [OK] jwilder/nginx-proxy Automated Nginx reverse proxy for docker con… 1346 [OK] richarvey/nginx-php-fpm Container running Nginx + PHP-FPM capable of… 547 [OK] jrcs/letsencrypt-nginx-proxy-companion LetsEncrypt container to use with nginx as p… 377 [OK] kong Open-source Microservice &amp; API Management la… 192 [OK] ... 这里我们拉取官方的镜像, 标签为stable, 即稳定版。 docker pull nginx:stable 等待下载完成后，我们就可以在本地镜像列表里查到REPOSITORY为nginx的镜像。 使用镜像 运行容器 docker run -p 80:80 -p 443:443 --name nginx_will_v2 -v $PWD/conf/server.conf:/etc/nginx/conf.d/server.conf -v $PWD/www:/www -v $PWD/logs:/wwwlogs -d nginx:stable 注：这里开放了两个端口号，是因为后面会配置https, 后面使用docker搭建生产环境一节也会介绍，自己掉坑了。 命令说明： -p 80:80：将容器的80端口映射到主机的80端口 -p 443:443: 将容器的443端口映射到主机的443端口 –name mynginx：将容器命名为mynginx -v $PWD/www:/www：将主机中当前目录下的www挂载到容器的/www -v $PWD/conf/server.conf:/etc/nginx/conf.d/server.conf：将主机中当前目录下的server.conf挂载到容器的/etc/nginx/conf.d/server.conf （后面重点讲为啥） -v $PWD/logs:/wwwlogs：将主机中当前目录下的logs挂载到容器的/wwwlogs 查看容器运行情况 $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 5b22ae556d53 nginx:stable \"nginx -g 'daemon of…\" 14 hours ago Up 14 hours 0.0.0.0:80->80/tcp, 0.0.0.0:443->443/tcp nginx_will_v2 通过浏览器访问测试： http://35.197.142.179/ ,出现nginx欢迎界面成功。 安装 tomcat并配置查找Docker Hub上的tomcat镜像 $ docker search tomcat NAME DESCRIPTION STARS OFFICIAL AUTOMATED tomcat Apache Tomcat is an open source implementati… 1879 [OK] tomee Apache TomEE is an all-Apache Java EE certif… 51 [OK] dordoka/tomcat Ubuntu 14.04, Oracle JDK 8 and Tomcat 8 base… 49 [OK] davidcaste/alpine-tomcat Apache Tomcat 7/8 using Oracle Java 7/8 with… 24 [OK] consol/tomcat-7.0 Tomcat 7.0.57, 8080, \"admin/admin\" 16 [OK] bitnami/tomcat Bitnami Tomcat Docker Image 16 [OK] cloudesire/tomcat Tomcat server, 6/7/8 15 [OK] ... 这里我们拉取官方的镜像, 标签为8.5.31 docker pull tomcat:8.5.31 等待下载完成后，我们就可以在本地镜像列表里查到REPOSITORY为tomcat的镜像。 使用镜像 运行容器 docker run --name tomcat_will -p 8080:8080 -v $PWD/apps:/usr/local/tomcat/webapps/apps -d tomcat:8.5.31 命令说明： -p 8080:8080：将容器的8080端口映射到主机的8080端口 -v $PWD/apps:/usr/local/tomcat/webapps/apps：将主机中当前目录下的apps挂载到容器的/apps 查看容器运行情况 $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES dd2e4a1e03c3 tomcat:8.5.31 \"catalina.sh run\" 19 hours ago Up 14 hours 0.0.0.0:8080->8080/tcp tomcat_will 通过浏览器访问测试：http://35.197.142.179:8080/ ，出现tomcat页面成功启动。 至此，关于博客的生产环境准备工作完成，后面一章介绍生产环境的项目部署。","categories":[{"name":"运维","slug":"运维","permalink":"http://blog.willhappy.cn/categories/运维/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.willhappy.cn/tags/Linux/"},{"name":"docker","slug":"docker","permalink":"http://blog.willhappy.cn/tags/docker/"}]},{"title":"git进阶历程","slug":"28_2018-05-09_git进阶历程","date":"2018-05-29T00:00:00.000Z","updated":"2024-06-01T13:17:35.408Z","comments":true,"path":"2018/05/29/28-2018-05-09-git-jin-jie-li-cheng/","link":"","permalink":"http://blog.willhappy.cn/2018/05/29/28-2018-05-09-git-jin-jie-li-cheng/","excerpt":"前面的git养成日记中已经学习了git的基本的操作了，关键是养成使用git的习惯，那为什么还会有这篇文章呢？是因为我在使用git的过程中，也遇到了问题，所以写这篇文章是记录下自己的问题解决和需求的解决。","text":"前面的git养成日记中已经学习了git的基本的操作了，关键是养成使用git的习惯，那为什么还会有这篇文章呢？是因为我在使用git的过程中，也遇到了问题，所以写这篇文章是记录下自己的问题解决和需求的解决。 [toc] 前言git高阶教程参考指南，git-recipes 一. 小知识点开发分支 git clone #克隆下来的代码只做本地master分支和远程分支的关联 想要需要在其他分支上开发（存在其他远程分支）,两种方式： git checkout -b dev origin/dev #checkout远程的dev分支，在本地起名为dev分支，并切换到本地的dev分支 或者： git checkout -b dev #新建并切换分支git branch –set-upstream dev origin/dev #本地分支关联远程分支 其实下面两条命令合并起来就是上面一条。可通过下面的命令查看分支的关联情况 git branch -vv 仓库关联如果在本地初始化的git仓库，在远程新建了远程仓库，通过下面的命令进行关联： git remote add origin https://github.com/willhappy/will.git #origin 别名 二. git HEAD 游离问题错误： 解决方案，参考文章:D,感谢，不想重复造轮子了，就记录下，下次解决参考方便。 三. git 子模块why?关于为什么折腾git子模块呢，因为最近博客折腾的比较多，包括主题，在原来的主题上更改了很多，想着以后可以造福他人（QAQ完全臆想吖），想把主题单独从hexo的git仓库中给拿出来，单独管理，同时也方便他人使用更新过的主题。 解决给予上面的需求，我开始查找解决方案，目前呢，git有两种解决方案： git submodule #这是Git官方以前的推荐方案 git subtree #从 Git 1.5.2 开始，Git 新增并推荐使用这个功能来管理子项目 通过git submodule方式来解决，参考文章传送门，另外关于git子模块的管理查看传送门通过git subtree方式解决，可参考文章传送门，发现这是有赞的帖子，很高兴，好好学习。也可以参考文章，这篇文章中也对比了这两种方式,可以好好看一下。 四. git-flow 的工作流程关于git-flow,查看文章 五. 关于git分支管理策略关于如何利用git进行team项目分支管理，参考阮一峰老师的Git分支管理策略 六. git命令常见问题及场景1. master、origin master 与 origin/master 有什么区别？（参考） master 这个很好理解，它代表本地的某个分支名。 origin master 代表着两个概念，前面的 origin 代表远程名，后面的 master 代表远程分支名。 origin/master 只代表一个概念，即远程分支名，是从远程拉取代码后在本地建立的一份拷贝（因此也有人把它叫作本地分支）。 2. git revert和git reset理解。（参考）（科学上网） git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit。(git revert是撤销某次提交，不影响要撤销提交后面的提交；git reset是回滚到某次提交，会影响这次提交后面的提交，个人觉得这样理解比较好) 在回滚这一操作上看，效果差不多。但是在日后继续merge以前的老版本时有区别。因为git revert是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，导致这部分改变不会再次出现，但是git reset是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入。 git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。 3. git rebase和git merge 形象理解变基，参考这里(科学上网)，解释很有意思，相信你会开心。 搞清楚git rebase和git merge的区别，谨记git rebase的黄金法则，参考这里或者这里(科学上网). 关于git merge --squash和git rebase区别，了解一下. 最后，如何保证主干分支的提交历史的简洁可追溯可回滚，一般操作，了解下. 4. git revert撤销合并请求 git revert为撤销一次提交操作，git reset为回滚到某次提交的操作，再次重申。 当使用git revert来撤销一次合并的提交时，会报错，需要使用-m来指定一下要恢复的版本线。 git revert fcd8a10 -m 1 #撤回提交的commit id:fcd8a10 1代表当前分支 2代表在当前分支 merge的分支 参考文章一和文章二 说明 虽然上面贴出了解决方案，但是，比较遗憾的是自己还没有把我的需求整理处理，后期有机会会把博客的主题模块独立出来，进行单独的管理。 文章众多引用，首先感谢原作者，然后，本文仅供用于学习笔记，有助以后回顾，切勿用于商业用途。 other学习git比较好的可视化操作项目learnGitBranching 更多git学习内容持续更新中…","categories":[{"name":"cvs","slug":"cvs","permalink":"http://blog.willhappy.cn/categories/cvs/"}],"tags":[{"name":"git","slug":"git","permalink":"http://blog.willhappy.cn/tags/git/"}]},{"title":"hexo主题配置再升级--插件配置","slug":"27_2018-05-06_hexo主题配置升级","date":"2018-05-06T00:00:00.000Z","updated":"2024-06-01T13:17:35.408Z","comments":true,"path":"2018/05/06/27-2018-05-06-hexo-zhu-ti-pei-zhi-sheng-ji/","link":"","permalink":"http://blog.willhappy.cn/2018/05/06/27-2018-05-06-hexo-zhu-ti-pei-zhi-sheng-ji/","excerpt":"关于hexo博客搭建的知识请移步GitHub+Hexo搭建个人博客, 主题样式等相对简单，中间也有几次对主题的更改更换，\b也在版本更新里面做了相应的记录，博客的实用性在于他不断地完善， 对读者更加的友善， 让读者也更感兴趣， 此节就是博客的插件配置上介绍。","text":"关于hexo博客搭建的知识请移步GitHub+Hexo搭建个人博客, 主题样式等相对简单，中间也有几次对主题的更改更换，\b也在版本更新里面做了相应的记录，博客的实用性在于他不断地完善， 对读者更加的友善， 让读者也更感兴趣， 此节就是博客的插件配置上介绍。 [toc] 前言\b在此\b申明， 我博客使用的主题为hexo-theme-miho, \b之前使用的主题是yelee 基础配置，在主题文档中都有介绍，我\b是在此基础上，对主题的样式进行了小的优化\b使其符合我的风格，对于\b主题样式的\b修改，在我的版本更新说明中都有介绍，可点击查看，所以，在本节中所有的插件安装配置等，都是基于该主题的，如你使用其他主题，大同小异，\b好好研究以下即可。 一. DaoVoice实现在线联系用于用户之间的沟通插件。 注册登陆官方网站注册登陆，\b注册登陆后创建团队，填写邀请码ab5cf222, 即可创建完成 安装代码在themes/hexo-theme-miho/layout/layout.ejs文件中追加js代码： &lt;% if (theme.daovoice) { %> &lt;script> (function(i,s,o,g,r,a,m){ i[\"DaoVoiceObject\"]=r; i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date(); a=s.createElement(o),m=s.getElementsByTagName(o)[0]; a.async=1;a.src=g;a.charset=\"utf-8\"; m.parentNode.insertBefore(a,m)} )(window,document,\"script\",('https:' == document.location.protocol ? 'https:' : 'http:') + \"//widget.daovoice.io/widget/\" + \"&lt;%- theme.daovoice.app_id %>\" + \".js\",\"daovoice\") &lt;/script> &lt;script> daovoice('init', { app_id: \"&lt;%- theme.daovoice.app_id %>\", user_id: \"&lt;%- theme.daovoice.user_id %>\", email: \"&lt;%- theme.daovoice.email %>\", name: \"&lt;%- theme.daovoice.name %>\", signed_up: &lt;%- theme.daovoice.signed_up %> }); daovoice('update'); &lt;/script> &lt;script> daovoice('init', { app_id: \"&lt;%- theme.daovoice_app_id %>\" }); daovoice('update'); &lt;/script> &lt;% } %> ⚠️注意\bejs文件的\b\b中\b对变量的引用，同时区别于swing文件， 不清楚的自行google 修改主题配置文件\b主题配置文件：MyBlog/_config.yml,添加配置： # 在线联系 | DaoVoice daovoice: enable: true app_id: user_id: # 必填: 该用户在您系统上的唯一ID email: # 选填: 该用户在您系统上的主邮箱 name: # 选填: 用户名 signed_up: 1449821660 # 选填: 用户的注册时间，用Unix时间戳表示 测试至此，代码安装修改完成， 重新部署博客， daovoice后台ping一下，看是否安装成功。 二. live2d安装配置单调的\b博客主题可能产生审美疲劳，那我们就增加点\b二次元元素。 \b安装一条命令解决了: npm install -save hexo-helper-live2d 添加代码在themes/hexo-theme-miho/layout/layout.ejs文件中追加： &lt;%- live2d() %> 修改配置文件\b主题配置文件：MyBlog/_config.yml,添加配置： # Live2D live2d: model: Epsilon2.1 width: 200 # The width of your model. default: 150 height: 350 # The height of your model. default: 300 position: left opacityDefault: 1 更多配置参考官方文档 三. 鼠标点击♥️♥️效果 \b下载love.js代码, \b点击下载 在themes/hexo-theme-miho/source/js/下面新建love.js,将上面下载的代码copy进去。 在themes/hexo-theme-miho/layout/layout.ejs文件中追加代码： &lt;% if (theme.love) { %> &lt;script type=\"text/javascript\" src=\"/js/love.js\">&lt;/script> &lt;% } %> 主题配置文件MyBlog/_config.yml中添加配置： # 鼠标点击桃心效果 love: true 四. 博客字数时长统计插件在博客底部添加博客全站字数统计， 文章标题下方添加文章字数和阅读时长的统计。 installation npm i –save hexo-wordcount 代码在themes/hexo-theme-miho/layout/_partial/post/title.ejs相应位置添加： &lt;% if (theme.wordcount.enable){ %> &lt;ul> &lt;li> &lt;i class=\"fa fa-file-word-o\">&lt;/i> 字数统计&lt;span class=\"post-count\">&lt;%= wordcount(post.content) %>&lt;/span>字 &lt;/li> &lt;li> &lt;span> | &lt;/span> &lt;/li> &lt;li> &lt;i class=\"fa fa-clock-o\">&lt;/i> 阅读时长&lt;span class=\"post-count\">&lt;%= min2read(post.content) %>&lt;/span>分钟 &lt;/li> &lt;/ul> &lt;% } %> ⚠️特别注意，博客主题的不同，可能添加的位置不同，找到合适的位置，使用的合适的样式，将代码添加进去即可。 配置文件\b在根目录MyBlog/_config.yml主题配置文件中添加配置： # Post wordcount display settings字数统计插件 # Dependencies: https://github.com/willin/hexo-wordcount # 打开之后，会同时打开文章文字统计， 阅读时长和全站文字统计 wordcount: enable: true 关于wordcount的详细说明查看 五. 添加rss订阅添加博客订阅功能。 安装安装插件hexo-generator-feed $ npm install hexo-generator-feed –save 配置配置根目录下的_config.yml： ## Plugins: http://hexo.io/plugins/ #RSS订阅 plugin: - hexo-generator-feed #Feed Atom feed: type: atom path: atom.xml limit: 20 配置主题目录下的_config.yml链接： rss: title: Rss url: /atom.xml 运行测试点击rss图标测试。 六. SEO优化把个人网站站点地图交给搜索引擎，搜索引擎收录后就可以索引你的网站了。可参考elem一小姐姐的文章，😍hexo高阶教程, 前端妹子奥。 install安装和配置和rss的安装配置方法类似，可参考： $ npm install hexo-generator-sitemap –save $ npm install hexo-generator-baidu-sitemap –save #baidu 更多插件相关可查看官网 添加配置配置根目录下的_config.yml： # sitemap生成插件配置 Plugins: - hexo-generator-baidu-sitemap - hexo-generator-sitemap baidusitemap: path: baidusitemap.xml sitemap: path: sitemap.xml 配置好之后，hexo d就会生成相关的站点地图了。关于插件可查看 https://hexo.io/plugins/ 站点收录好了，上面一节我们可以生成站点地图了，那如何让我们的站点地图被搜索引擎收录呢？那么，百度提供给我们3种方式，google好像只提供了一种即提交sitemap.xml的方式。 那么，关于百度链接提交的三种方式和google的链接提交，在这里不再重复写了，参考文章1，文章二 这里重点说一些在配置链接提交方式时踩过的坑。 坑一:在链接提交之前，我们都要在相应的搜索引擎的管理平台去验证一下我们的网站，都采用的是下载html文件的方式验证。如果我们是每次都把验证文件放在编译好的目录下，那倒是没有问题，但是，每次编译好博客，还要把这两个验证文件放进去，就太麻烦了，我们要的效果是，把验证文件放在用户资源目录下，编译生成后，就直接出现在博客的目录下，这样就不用每次去copy再粘贴进去了。但是，这样问题又来了，把验证文件放在源码包里，hexo g编译生成好了之后，我们会发现我们的html验证文件改变了，那是因为hexo编译时，对html文件也进行了渲染， 这就导致了验证无法通过，因为验证文件改变了。 上面其实描述太复杂，简单总结一点： 直接copy到public目录下（每次生成都copy,太麻烦）–&gt;直接放在source目录下（生成输出后被渲染，文件改变，验证不通过） 说明一下hexo目录结构 |-- node_modules |-- public #hexo g之后生成的目录，也是我们的网站源码，hexo clean会清楚该目录 |-- scaffolds #脚手架 |-- source #用户资源目录，除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会 被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 |-- _data #数据文件 |-- _posts #markdown文章存放目录，会被编译成html文件，放到 public |-- themes #主题 |-- _config.yml #全局配置文件,网站的很多信息都在这里配置，诸如网站名称，副标题，描述，作者，语言，主题，部署等等参数 |-- package.json #hexo框架的参数和所依赖插件 关于目录的更多介绍，可以查看官方文档 好了，其实上面的问题描述的解决思路已经很清晰，也就是配置hexo不让其渲染验证的html文件,其实找到思路了，解决就很简单了。凡事都是一样。 # hexo渲染排除 | 路径是相对于source目录的路径 skip_render: '*.html' 更多配置方法查看 坑二：百度链接提交，使用hexo-baidu-url-submit来进行百度链接的主动推送, 使用这个插件，是要在使用hexo d部署时进行推送的，但是，由于之前使用了travisCI的自动化构建工具，就用不到了hexo d对博客进行部署到github了，travisCI配置的构建流程是：hexo生成网站源码后，由travis直接使用git推送到github。那么，既然baidu_url_submit又使用到了hexo d进行推送，所以，我们还要更改一下travisCI的构建流程。生成源码之后，不使用git进行推送，继续使用hexo d进行推送部署。具体可查看我的配置. 也可以参考文章。 至于我踩到的坑呢，可能就是.travis.yml文件的配置问题，经过不断的搜索比对，发现可能是因为该配置文件的注释中出现了特殊的字符，导致的travisCI无法去解析配置文件。去掉特殊字符后，构建成功。 more参考文章，插件还是配置了比较多的。 更多配置优化持续更新中… 番外篇（TravisCI自动化构建）关于博客配置TravisCI自动化构建工具，可参考文章, 非常方便，我们只需要写完md文件，提交到相应的分支，travisCi会帮我们构建部署到github的。travisCI完整学习，关注官方网站. travisCI自动化构建工具的使用学习，这也是个重点，也挺有意思的，有机会的话，以后可能也会出一篇文章记录一下，欢迎关注:D","categories":[{"name":"通用","slug":"通用","permalink":"http://blog.willhappy.cn/categories/通用/"}],"tags":[{"name":"Github","slug":"Github","permalink":"http://blog.willhappy.cn/tags/Github/"},{"name":"hexo","slug":"hexo","permalink":"http://blog.willhappy.cn/tags/hexo/"}]},{"title":"私人定制--mac配置篇","slug":"26_2018-05-04_私人定制--mac配置篇","date":"2018-05-04T00:00:00.000Z","updated":"2024-06-01T13:17:35.408Z","comments":true,"path":"2018/05/04/26-2018-05-04-si-ren-ding-zhi-mac-pei-zhi-pian/","link":"","permalink":"http://blog.willhappy.cn/2018/05/04/26-2018-05-04-si-ren-ding-zhi-mac-pei-zhi-pian/","excerpt":"为什么讲是私人定制呢？ 因为mac从入手， 大部分的软件和环境等都需要自己\b不断的去更新配置， \b可以看到的是， 我们\b可能后面的环境配置会更新掉前面的环境配置，像本节接下来要说的关于原装vim的配置， 会在后面安装了macvim后， 环境配置得到了重新的配置， 当前的\b配置永远不可能固定下来， 可能后面配置就会颠覆之前的配置， 以得到功能更大的升华， 就是这样不断的去颠覆之前， 才能更好的为自己所用， 才能达到私人化的定制。 所以， 本章只是做一个指导， 并不完全要这个套路来做， 可以有更多私人化的定制在里面，才能更适合自己。","text":"为什么讲是私人定制呢？ 因为mac从入手， 大部分的软件和环境等都需要自己\b不断的去更新配置， \b可以看到的是， 我们\b可能后面的环境配置会更新掉前面的环境配置，像本节接下来要说的关于原装vim的配置， 会在后面安装了macvim后， 环境配置得到了重新的配置， 当前的\b配置永远不可能固定下来， 可能后面配置就会颠覆之前的配置， 以得到功能更大的升华， 就是这样不断的去颠覆之前， 才能更好的为自己所用， 才能达到私人化的定制。 所以， 本章只是做一个指导， 并不完全要这个套路来做， 可以有更多私人化的定制在里面，才能更适合自己。 [toc] 一. mac关于环境变量初探先简单了解下macOS\b系统额目录结构， 文章参考 \b关于mac环境变量详细介绍，参考文章：传送门 🏁勾画重点 查看环境变量命令： [root@localhost u-boot-sh4]#echo $PATH/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin 说明：PATH的格式为：PATH=$PATH::::——: ，中间用冒号隔开。 添加PATH环境变量 [root@localhost u-boot-sh4]#export PATH=/opt/STM/STLinux-2.3/devkit/sh4/bin:$PATH 环境变量文件的优先级 /etc/profile /etc/paths ~/.bash_profile ~/.bash_login ~/.profile ~/.bashrc 说明：/etc/profile: 此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行.并从/etc/profile.d目录的配置文件中搜集shell的设置./etc/bashrc: 为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取.~/.bash_profile: 每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件.~/.bashrc: 该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该该文件被读取.~/.bash_logout: 当每次退出系统(退出bash shell)时,执行该文件. 另外,/etc/profile中设定的变量(全局)的可以作用于任何用户,而~/.bashrc等中设定的变量(局部)只能继承/etc/profile中的变量,他们是”父子”关系. ~/.bash_profile 是交互式、login 方式进入 bash 运行的~/.bashrcv 是交互式 non-login 方式进入 bash 运行的通常二者设置大致相同，所以通常前者会调用后者。 Mac配置环境变量 /etc/profile （建议不修改这个文件 ） 全局（公有）配置，不管是哪个用户，登录时都会读取该文件。 /etc/bashrc （一般在这个文件中添加系统级环境变量） 全局（公有）配置，bash shell执行时，不管是何种方式，都会读取此文件。 ~/.bash_profile （一般在这个文件中添加用户级环境变量） 每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次! 查看 MacOS使用的shell类型命令： echo $SHELL 说明： 如果输出的是：csh或者是tcsh，那么你用的就是C Shell。 如果输出的是：bash，sh，zsh，那么你的用的可能就是Bourne Shell的一个变种。 Mac OS X 10.2之前默认的是C Shell。 Mac OS X 10.3之后默认的是Bourne Shell。 那么你可以把你要添加的环境变量添加到你主目录下面的.profile或者.bash_profile，如果存在没有关系添加进去即可，如果没有生成一个。 mac默认的shell为bash，切换命令： chsh -s /bin/bash #切换默认终端bash chsh -s /bin/zsh #切换终端shell为zsh ⚠️注意当mac机器上安装了zsh后 .bash_profile 文件中的环境变量就无法起到作用。 解决方案： （1） cd ~ （2） open .zshrc （3） 在.zshrc文件末尾增加.bash_profile的引用: source ~/.bash_profile \b原因：linux和macOS默认的shell为bash，加载的环境变量配置文件为～/.bash_profile，使用zsh的shell时，默认加载的环境变量配置文件为～/.zshrc，所以造成.bash_profile 文件中的环境变量就无法起到作用，解决只需在将.bash_profile文件加到.zshrc文件中即可。 二. mac必备软件安装配置homebrew安装为什么先安装homebrew呢？ 因为后面很多安装软件都使用到了homebrew去安装，所以先来安装homebrew为好。非常简单，参考文章：官方\b网站文章 终端神器–iterm2安装配置其中包括\bbrew安装iterm2， 配置\bsolarized， 配置oh my zsh，还有配置一些字体，插件等等。详细，请参考文章： 传送门 命令行工具–Oh My \bZsh上面安装iterm2时， 安装\b了oh my zsh。关于更多oh my zsh的使用配置， 请关注以下文档：官方仓库文章 🏁勾画重点lib 提供了核心功能的脚本库tools 提供安装、升级等功能的快捷工具plugins 自带插件的存在放位置templates 自带模板的存在放位置themes 自带主题文件的存在放位置custom 个性化配置目录，自安装的插件和主题可放这里 zsh配置代理终端使用git、brew等安装软件或者clone代码，会出现速度慢，或者443等情况，采用设置代理处理。使用不同的科学上网工具设置的代理端口不同，看具体配置。 # 查看代理 $ env | grep -I proxy https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890 # 取消代理 $ unset http_proxy $ unset https_proxy $ unset all_proxy 也可以配置环境变量，灵活开启管理代理, 在.zshrc文件中添加以下内容 proxyon () { export http_proxy=Socks5://127.0.0.1:1086 export https_proxy=Socks5://127.0.0.1:1086 echo \"http/https proxy on.\" curl ip.gs } proxyoff () { unset http_proxy unset https_proxy echo \"http/https proxy off.\" curl ip.gs } 执行source ~/.zshrc生效，即可以使用命令proxyon和proxyoff即可在当前终端开启和关闭代理。 终端vim配色上面，安装iterm2时，我们配置了solarized主题，那么，在终端或者iterm2中vim的配色方案，我们也使用solarized的配色方案，保持一致，美观。参考文章：solarized官方网站solarized官方仓库vim使用solarized配色1vim使用solarized配色2 ⚠️注意预警： vim使用solarized配色， 要配置文件.vimrc, 而后面安装macvim的完整配置方案.vim_runtime时，会覆盖该配置文件，导致失效， 如何解决， \b请查看编辑器IDE–vim的第五节 mac of vim。 macVim编辑器请移步我的另一篇文章编辑器IDE–vim的第五节 mac of vim, 里面有详细的介绍， 不再做赘述。 效率神器–alfred安装使用参考： 文章 python3安装mac系统自带python2.7, 现在安装python3版本。参考： 文章 ⚠️注意文章中提到为避免系统的python和brew中安装的python打架，所以要修改环境变量， 我们在这就没有修改， 应为我们安装python3的版本，他适合python版本独立的， 我们使用python -v, 读到的就是系统原装的python， 使用python3 -v， 读到的就是brew安装的python3， 互不影响，也就不做更改了。当然，这是我自己的观点， 如要了解更多， 还请自己google之。 git安装因为之前安装xcode， 自动安装了git，但是版本不是\b最新的， 而下面文章介绍了使用brew安装或者更新git版本。参考：文章 tomcat， maven等安装web环境的搭建， 都使用到homebrew来安装， 比较简单， 不做赘述。自行学会homebrew， 软件安装管理起来就很方便了。 定制化持续更新中… 三. 操作技巧查看应用安装路径命令： which git","categories":[{"name":"tools","slug":"tools","permalink":"http://blog.willhappy.cn/categories/tools/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://blog.willhappy.cn/tags/mac/"}]},{"title":"征途之路--linux","slug":"25_2018-05-03_征途之路--linux","date":"2018-05-03T00:00:00.000Z","updated":"2024-06-01T13:17:35.408Z","comments":true,"path":"2018/05/03/25-2018-05-03-zheng-tu-zhi-lu-linux/","link":"","permalink":"http://blog.willhappy.cn/2018/05/03/25-2018-05-03-zheng-tu-zhi-lu-linux/","excerpt":"可能作为coder这么一类人， 总会有多少接触Linux， 并且有一份想拿下它，并凌驾于它之上的野心， 但是， 现实的骨感的， 从入门到放弃的， 也是比比皆是， 那如何才能有章程由规划的一步步进行呢， 那是需要我们有方向， 并有持之以恒的决心， 才能有所建树。 本文便是作为自己方向指导， 有侧重点的去涉猎学习积累， 慢慢构筑linux基础城墙。：D","text":"可能作为coder这么一类人， 总会有多少接触Linux， 并且有一份想拿下它，并凌驾于它之上的野心， 但是， 现实的骨感的， 从入门到放弃的， 也是比比皆是， 那如何才能有章程由规划的一步步进行呢， 那是需要我们有方向， 并有持之以恒的决心， 才能有所建树。 本文便是作为自己方向指导， 有侧重点的去涉猎学习积累， 慢慢构筑linux基础城墙。：D [toc] 一. linux阶段规划要学习一门知识，就要清楚哪个阶段，该学什么，不该学什么，稳扎稳打，才能把底层建设稳固。附带了解在了解下操作系统的概念 二. FHS(文件系统目录标准)了解linux各目录文件的结构含义，有利于自己的合理规划和使用。 我们需要特别关注的目录： 三. linux 内核学习路线这个属于难点知识，可以了解下： 四. Linux Security Coaching此模块也属于了解内容，不做重点学习。 五. linux命令使用*这节是一个重点内容， 使用linux， 更多的是使用命令操作linux， 所以，应多加练习，切勿死记硬背。以下重点在于辅助理解使用。 重点来了， 好看又好用的脑图来了。理解辅助记忆，理解辅助记忆，理解辅助记忆，重要的事情说三遍。重点多家练习。 还不过瘾？ 那就再来一张。源文件下载 当然，也可以通过命令大全查看。","categories":[{"name":"System","slug":"System","permalink":"http://blog.willhappy.cn/categories/System/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.willhappy.cn/tags/Linux/"}]},{"title":"编辑器IDE--vim","slug":"24_2018-05-02_编辑器IDE--vim","date":"2018-05-02T00:00:00.000Z","updated":"2024-06-01T13:17:35.408Z","comments":true,"path":"2018/05/02/24-2018-05-02-bian-ji-qi-ide-vim/","link":"","permalink":"http://blog.willhappy.cn/2018/05/02/24-2018-05-02-bian-ji-qi-ide-vim/","excerpt":"","text":"[toc] 一. Emacs or vim?素有的两大编辑器之争vim、emacs, 我们也就不再多说了，各具千秋，都值得我们学习，或许融入到他们之中，才能体会到他们的独特。说融入他们是容易， 可为什么平时我们还是很少的使用他们呢？ 这可能是他们两个的学习曲线，实在让人难啄， 大多数人是有学习的那份心， 却难在了坚持使用他们上面，一起来看看他们的学习曲线。（请允许我盗一张图） 另外，关于更多这两大编辑器学习曲线的介绍， 请关注这篇文章 传送门 介于我们文章的主题， 下面我们主要学习了解vim。 二. why vim?因为vim在我们初学者当中，其应用范围还是蛮广的，包括在一些类unix系统中默认的编辑器，都是vim，所以笔者先来学习vim。关于其他的vim的一些好处和特点，和为什么使用vim更多，请关注此贴的why vim 传送门，感谢作者，通过他的blog，学到很多东西，支持原创。 ：D 重点总结下， vim的好处： 扩展性 通用性 可定制化 三. How to do?关于vim的一些插件或者个性化配置，同样的也请移步此文章 传送门 四. vim相关操作关于vim的一些相关的操作，可以参考：传送1传送2 五. mac of vim\b在mac中，我们选择安装macVim，不使用mac原装的vim，安装macVim， 参考文章. ⚠️注意 使用homebrew安装完macVim之后， 可能会自动添加到环境变量中， 参考文章中提到的建立软连接什么的， 我认为作者的意图是在终端使用vim命令时，是直接调用macvim.app, 也可不用配置， 仍让原装vim可使用， 两者互不干扰， 即vim命令仍然调用原装vim， 而mvim命令调用macvim。 安装完成之后， 可能需要为macvim配置各种插件或者主题样式，这里我们为了方便， 使用github上一个比较完整且开源的配置仓库.vim_runtime, 安装配置，参考.vim_runtime的api 安装完.vim_runtime之后， 安装生效后，会返现原来的vim主题样式（solarized配色， 原来的配置可参考我的私人定制–mac配置篇）变了，不是我们喜欢的配色了，是因为安装.vim_runtime会重写.vimrc文件，将原来的配置覆盖掉了，所以样式vim主题样式会变。所以将原来配置在.vimrc中的样式重新写到自己的配置文件～/.vim_runtime/my_configs.vim中，没有该文件的话， 创建一个即。.vim_runtime会通过.vimrc读取my_configs.vim配置文件，就会重新生效。 自此，macvim安装完毕了，我们可以尽情的享受了。 六. ideaVim 应用可能我们更多的实在idea中开发代码, 那么，我们可以不断的练习使用vim的常用操作了，安装插件ideaVim, 关于ideaVim的应用技巧， 我们也不再重复造轮子了， 参考这篇文章， 介绍详细 传送门 . 特别注意： 就是在使用vim剪切板和系统剪切板之间的复制粘贴操作，系统剪切板上的内容可在任意程序中ctrl+v粘贴。&quot;+yy 复制当前行到系统剪切板&quot;+p 粘贴系统剪切板内容到vim&quot;ayy 复制当前行到寄存器 a&quot;ap 将寄存器 a 中的内容粘贴到光标后面 七. vim之于新同学建议可能有新同学下定决心学习vim， 并开始的初级阶段， 但是学着学着就产生的迷惑， 像我， 那我到底如何继续下去， 那么同样给出新同学学习中的建议和学习习惯养成 传送门 再次感谢这位大神。 八. vim命令脑图记忆脑图并不代表死记硬背， 关键在于多加练习。源文件下载地址 vim键盘图：","categories":[{"name":"tools","slug":"tools","permalink":"http://blog.willhappy.cn/categories/tools/"}],"tags":[{"name":"vim","slug":"vim","permalink":"http://blog.willhappy.cn/tags/vim/"}]},{"title":"java对象初始化问题--阿里🐮刨析","slug":"23_2018-05-02_java对象初始化问题--阿里刨析","date":"2018-05-02T00:00:00.000Z","updated":"2024-06-01T13:17:35.408Z","comments":true,"path":"2018/05/02/23-2018-05-02-java-dui-xiang-chu-shi-hua-wen-ti-a-li-bao-xi/","link":"","permalink":"http://blog.willhappy.cn/2018/05/02/23-2018-05-02-java-dui-xiang-chu-shi-hua-wen-ti-a-li-bao-xi/","excerpt":"","text":"[toc] 一. why引入因为java对象初始化问题是比较基础的java知识点，同时，也是众多面试中百问不厌的问题，所以，我们通过阿里工程师的例子和刨析来好好理解他。 二. 引发问题会触发Java object initialization order 问题，这种问题比较少见。 三. 举例package com.xn.web.budget; public class Test2 extends Test { public int a = 100; public Test2() { super(); System.out.println(a); a = 200; } public static void main(String[] args){ System.out.println(new Test2().a); } } package com.xn.web.budget; public class Test { public Test() { System.out.println(((Test2)this).a); } } 结果输出： 0 100 200 解析对象的初始化顺序： 为A类分配内存空间，初始化所有成员变量为默认值，包括primitive类型(int=0,boolean=false,…)和Reference类型。 调用A类构造函数。 调用B类构造函数。 调用Object空构造函数。（java编译器会默认加此构造函数，且object构造函数是个空函数，所以立即返回） 初始化B类成员变量，因为B类没有成员变量，跳过。 执行sysout输出子类A的成员变量小a。// 此时为0 初始化A类成员变量，将A类成员变量小a赋值100。 执行sysout输出当前A类的成员变量小a。// 此时为100 赋值当前A类的成员变量小a为200。 main函数中执行sysout，输出A类实例的成员变量小a。// 此时为200 加粗的那两行描述是重点，结论是成员变量初始化是在父类构造函数调用完后，在此之前，成员变量的值均是默认值。 其实这类问题，熟悉原理是一方面，本质上只要不在构造函数中插入过多的业务逻辑，出问题的概率也会低很多。 最后，我们再来看看JLS中给出的Java类对象初始化顺序定义，这是一个带条件分支的流程描述： Assign the arguments for the constructor to newly created parameter variables for this constructor invocation. If this constructor begins with an explicit constructor invocation of another constructor in the same class (using this), then evaluate the arguments and process that constructor invocation recursively using these same five steps. If that constructor invocation completes abruptly, then this procedure completes abruptly for the same reason; otherwise, continue with step 5. This constructor does not begin with an explicit constructor invocation of another constructor in the same class (using this). If this constructor is for a class other than Object, then this constructor will begin with an explicit or implicit invocation of a superclass constructor (using super). Evaluate the arguments and process that superclass constructor invocation recursively using these same five steps. If that constructor invocation completes abruptly, then this procedure completes abruptly for the same reason. Otherwise, continue with step 4. Execute the instance initializers and instance variable initializers for this class, assigning the values of instance variable initializers to the corresponding instance variables, in the left-to-right order in which they appear textually in the source code for the class. If execution of any of these initializers results in an exception, then no further initializers are processed and this procedure completes abruptly with that same exception. Otherwise, continue with step 5. (In some early implementations, the compiler incorrectly omitted the code to initialize a field if the field initializer expression was a constant expression whose value was equal to the default initialization value for its type.) Execute the rest of the body of this constructor. If that execution completes abruptly, then this procedure completes abruptly for the same reason. Otherwise, this procedure completes normally. 引用自：传送","categories":[{"name":"后端","slug":"后端","permalink":"http://blog.willhappy.cn/categories/后端/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.willhappy.cn/tags/java/"},{"name":"基础","slug":"基础","permalink":"http://blog.willhappy.cn/tags/基础/"}]},{"title":"git养成日记","slug":"22_2018-04-26_git养成日记","date":"2018-04-26T00:00:00.000Z","updated":"2024-06-01T13:17:35.408Z","comments":true,"path":"2018/04/26/22-2018-04-26-git-yang-cheng-ri-ji/","link":"","permalink":"http://blog.willhappy.cn/2018/04/26/22-2018-04-26-git-yang-cheng-ri-ji/","excerpt":"","text":"[toc] 前言基础入门，参考廖雪峰老师的git教程 一. git日常操作 git add fileName;git commit -m ‘提交说明’；git push -u;//提交到githubgit status -s//查看文件状态 git提交文件到github示意图： 二. git提交tag标签可以针对某一时间点的版本做标记，常用于版本发布。 也可以是某个重要版本的标识，可标识里程碑版本，可回溯可参考亦可纪念，哈哈。 git tag -a v1.0 -m “Release version 1.0″ 详解： git tag 是命令-a v1.0是增加 名为v1.0的标签-m 后面跟着的是标签的注释 git tag的操作发生在我们commit修改到本地仓库之后。 完整操作流程 提交 git add .git commit -m ‘add tags’git tag -a v1.0 -m ‘Release version 1.0’ 推送标签到远程服务器上 默认情况下，git push 并不会把标签传送到远端服务器上，只有通过显式命令才能分享标签到远端仓库。其命令格式如同推送分支，运行 git push origin [tagname] 即可： git push origin mastergit push origin v1.0 如果要一次推送所有本地新增的标签上去，可以使用 –tags 选项：git push origin --tags 后期追加标签你甚至可以在后期对早先的某次提交加注标签。比如在下面展示的提交历史中： $ git log --pretty=oneline 15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch 'experiment' a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support 0d52aaab4479697da7686c15f77a3d64d9165190 one more thing 我们忘了在提交 “updated rakefile” 后为此项目打上版本号 v1.2，没关系，现在也能做。只要在打标签的时候跟上对应提交对象的校验和（或前几位字符）即可： $ git tag -a v1.2 a6b4c97 切换已有tag git tag –list // 查看已有tag列表git checkout [tag/branch/commit] // 切换到指定tag/branch/commit都是此命令 删除tag git tag -d v1.0 删除远端服务器的标签 git push origin :refs/tags/v1.0 三. git分支分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。git可以在工作流程中频繁的使用分支与合并。关于分支的更多概念理解，参考git api, 这里我只关注常用操作。 创建分支那么，Git 又是如何创建一个新的分支的呢？答案很简单，创建一个新的分支指针。比如新建一个 testing 分支，可以使用 git branch 命令： git branch testing 切换分支要切换到其他分支，可以执行 git checkout 命令。我们现在转换到新建的 testing 分支： git checkout testing 当然，我们也可以新建并切换到该分支，运行 git checkout 并加上 -b 参数： $ git checkout -b iss53Switched to a new branch ‘iss53’ 分支的合并在问题 #53 相关的工作完成之后，可以合并回 master 分支。实际操作同前面合并 hotfix 分支差不多，只需回到 master 分支，运行 git merge 命令指定要合并进来的分支： $ git checkout master $ git merge iss53 Auto-merging README Merge made by the 'recursive' strategy. README | 1 + 1 file changed, 1 insertion(+) 查看分支合并情况： git log --graph --pretty=oneline --abbrev-commit 分支删除既然之前的工作成果已经合并到 master 了，那么 iss53 也就没用了。你可以就此删除它，并在问题追踪系统里关闭该问题。 $ git branch -d iss53 遇到冲突时的分支合并有时候合并操作并不会如此顺利。如果在不同的分支中都修改了同一个文件的同一部分，Git 就无法干净地把两者合到一起（译注：逻辑上说，这种问题只能由人来裁决。）。如果你在解决问题 #53 的过程中修改了 hotfix 中修改的部分，将得到类似下面的结果： $ git merge iss53 Auto-merging index.html CONFLICT (content): Merge conflict in index.html Automatic merge failed; fix conflicts and then commit the result. Git 作了合并，但没有提交，它会停下来等你解决冲突。要看看哪些文件在合并时发生冲突，可以用 git status 查阅： $ git status On branch master You have unmerged paths. (fix conflicts and run \"git commit\")\\ Unmerged paths: (use \"git add ...\" to mark resolution) both modified: index.html no changes added to commit (use \"git add\" and/or \"git commit -a\") 任何包含未解决冲突的文件都会以未合并（unmerged）的状态列出。Git 会在有冲突的文件里加入标准的冲突解决标记，可以通过它们来手工定位并解决这些冲突。可以看到此文件包含类似下面这样的部分： < HEAD > iss53 可以看到 ======= 隔开的上半部分，是 HEAD（即 master 分支，在运行 merge 命令时所切换到的分支）中的内容，下半部分是在 iss53 分支中的内容。解决冲突的办法无非是二者选其一或者由你亲自整合到一起。比如你可以通过把这段内容替换为下面这样来解决： &lt;div id=\"footer\"> please contact us at email.support@github.com &lt;/div> 这个解决方案各采纳了两个分支中的一部分内容，而且我还删除了 &lt;&lt;&lt;&lt;&lt;&lt;&lt;，======= 和 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 这些行。在解决了所有文件里的所有冲突后，运行 git add 将把它们标记为已解决状态（译注：实际上就是来一次快照保存到暂存区域。）。因为一旦暂存，就表示冲突已经解决。 利用分支进行开发的工作流程参考： git api 远程分支查看远程分支： git branch -a **查看本地分支关联（跟踪）的远程分支之间的对应关系： git branch -vv git关联本地与远程分支: git branch –set-upstream-to origin/devtest devtest 注意：git pull和git merge 区别?git pull = git fetch + git merge，fetch和push命令可以分别对远程分支进行fetch和push操作，而pull不是直接跟远程分支对话的。fetch同pull的区别在于：git fetch:是从远程获取最新版本到本地，不会自动merge，而git pull是从远程获取最新版本并merge到本地仓库。从安全角度出发，git fetch比git pull更安全，因为我们可以先比较本地与远程的区别后，选择性的合并。git push 默认推送到master，如果有多个分支，则多个分支一起推送到远程。 更多远程操作，查看文章 四. git开发一般流程上面说的是git的基本操作，那实际项目开发应用实例，我们的做法大致如下（转载，继续完善）： 情况一: 远程仓库有master和dev分支1.克隆代码 > git clone https://github.com/master-dev.git # 这个git路径是无效的，示例而已 2.查看所有分支 > git branch --all # 默认有了dev和master分支，所以会看到如下三个分支 # master[本地主分支] origin/master[远程主分支] origin/dev[远程开发分支] # 新克隆下来的代码默认master和origin/master是关联的，也就是他们的代码保持同步 # 但是origin/dev分支在本地没有任何的关联，所以我们无法在那里开发 3.创建本地关联origin/dev的分支 > git checkout dev origin/dev # 创建本地分支dev，并且和远程origin/dev分支关联，本地dev分支的初始代码和远程的dev分支代码一样 4.切换到dev分支进行开发 > git checkout dev # 这个是切换到dev分支，然后就是常规的开发 情况二: 假设远程仓库只有mater分支1.克隆代码 > git clone https://github.com/master-dev.git # 这个git路径是无效的，示例而已 2.查看所有分支 > git branch --all # 默认只有master分支，所以会看到如下两个分支 # master[本地主分支] origin/master[远程主分支] # 新克隆下来的代码默认master和origin/master是关联的，也就是他们的代码保持同步 3.创建本地新的dev分支 > git branch dev # 创建本地分支 > git branch # 查看分支 # 这是会看到master和dev，而且master上会有一个星号 # 这个时候dev是一个本地分支，远程仓库不知道它的存在 # 本地分支可以不同步到远程仓库，我们可以在dev开发，然后merge到master，使用master同步代码，当然也可以同步 4.发布dev分支发布dev分支指的是同步dev分支的代码到远程服务器 > git push origin dev:dev # 这样远程仓库也有一个dev分支了 5.在dev分支开发代码 > git checkout dev # 切换到dev分支进行开发 # 开发代码之后，我们有两个选择 # 第一个：如果功能开发完成了，可以合并主分支 git checkout master # 切换到主分支 git merge dev # 把dev分支的更改和master合并 git push # 提交主分支代码远程 git checkout dev # 切换到dev远程分支 git push # 提交dev分支到远程 # 第二个：如果功能没有完成，可以直接推送 git push # 提交到dev远程分支 # 注意：在分支切换之前最好先commit全部的改变，除非你真的知道自己在做什么 6.删除分支 > git push origin :dev # 删除远程dev分支，危险命令哦 # 下面两条是删除本地分支 git checkout master # 切换到master分支 git branch -d dev # 删除本地dev分支 五. git命令脑图记忆","categories":[{"name":"cvs","slug":"cvs","permalink":"http://blog.willhappy.cn/categories/cvs/"}],"tags":[{"name":"git","slug":"git","permalink":"http://blog.willhappy.cn/tags/git/"}]},{"title":"小绿🔒https的web容器配置","slug":"21_2018-04-25_小绿锁https的web容器配置","date":"2018-04-25T00:00:00.000Z","updated":"2024-06-01T13:17:35.408Z","comments":true,"path":"2018/04/25/21-2018-04-25-xiao-lu-suo-https-de-web-rong-qi-pei-zhi/","link":"","permalink":"http://blog.willhappy.cn/2018/04/25/21-2018-04-25-xiao-lu-suo-https-de-web-rong-qi-pei-zhi/","excerpt":"学习配置https,以及一些服务器安装部署流程，在tomcat和nginx中安装配置https。","text":"学习配置https,以及一些服务器安装部署流程，在tomcat和nginx中安装配置https。 [toc] 一. 阿里云免费证书的申请下载参考：https://common-buy.aliyun.com/?spm=5176.2020520163.cas.85.3b102b7arJW2wy&amp;commodityCode=cas#/buy 传送门购买成功后，按照对应流程下载配置。相关配置参考：https://help.aliyun.com/video_detail/54217.html?spm=5176.2020520163.cas.80.3b102b7arJW2wy 传送门 二. 配置注意问题 端口号的更改，https默认的端口号为443. 证书路径的修改 协议的修改 证书密码的修改 blog相关参考： http://imtianx.cn/2017/09/22/tomcat_set_https/ 传送门 三. 防火墙端口的开放vim /etc/sysconfig/iptables 在文件中添加： -A INPUT -p tcp -m state –state NEW -m tcp –dport 443 -j ACCEPT 当然，也可以在阿里云的后台管理系统，去设置安全组策略来开放端口。 四. 测试重启tomcat，使用https://willhappy.cn测试。 五. 番外(nginx + tomcat + https) 上面说了关于web项目单独在tomcat容器中配置https, 但是，现在现在大部企业都是采用nginx作为反向代理服务器，tomcat只做数据服务的提供者，所以，简单再说下关于nginx的https证书安装和配置。 1. 关于nginx安装网上已经相当多了，可参考传送门. 2. nginx配置https证书类似与tomcat的https配置，参考传送门, 视频参考传送门.我的配置文件nginx.conf： server { listen 443; server_name willhappy.cn; #拦截的域名 ssl on; root html; index index.html index.htm; ssl_certificate cert/XX.pem; #你自己申请的证书文件 ssl_certificate_key cert/XX.key; #私钥文件 ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / { proxy_pass http://whome; #提供数据服务的服务器 proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } } upstream whome{ server localhost:8080; } 配置tomcat的server.xml可直接通过ip进行项目的访问 &lt;Host name=\"localhost\" appBase=\"webapps\" unpackWARs=\"true\" autoDeploy=\"true\" xmlValidation=\"false\" xmlNamespaceAware=\"false\"> &lt;Context path=\"\" docBase=\"/usr/local/tomcat/webapps/whome\" reloadable=\"true\" /> &lt;/Host> 3. 启动测试启动nginx，可能会出现错误： [emerg] 10464#0: unknown directive “ssl” in /usr/local/nginx-0.6.32/conf/nginx.conf:74 这是因为没有将ssl模块编译进nginx，在configure的时候加上“–with-http_ssl_module”即可 [root@localhost nginx-1.4.4]# ./configure --prefix=/usr/local/nginx --user=www --group=www --with-http_stub_status_module --with-http_ssl_module nginx安装包中重新配置，编译。再次通过https://willhappy.cn,访问测试，配置成功。 注意：我们只能通过https://willhappy.cn 方式访问才是安全访问，通过willhappy.cn还是普通的http访问，所以，要通过两种方式都可以安全访问，还需要配置一下。 参考传送门，未做测试。可以自己尝试一下，嘻嘻","categories":[{"name":"后端","slug":"后端","permalink":"http://blog.willhappy.cn/categories/后端/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.willhappy.cn/tags/Linux/"}]},{"title":"centos7.0搭建web环境的坎","slug":"20_2017-12-23_centos7.0搭建web环境的坎","date":"2017-12-23T00:00:00.000Z","updated":"2024-06-01T13:17:35.408Z","comments":true,"path":"2017/12/23/20-2017-12-23-centos7.0-da-jian-web-huan-jing-de-kan/","link":"","permalink":"http://blog.willhappy.cn/2017/12/23/20-2017-12-23-centos7.0-da-jian-web-huan-jing-de-kan/","excerpt":"为了接下来能活的更好，再次埋头扎下了技术坑，一步一步来了，先从搭建生产环境走起，centos7.0 + tomcat8.5 + jdk1.8 + mysql5.7吧，简单的走流程的东西就不写了，只写一下在安装过程中走的坑,haha。","text":"为了接下来能活的更好，再次埋头扎下了技术坑，一步一步来了，先从搭建生产环境走起，centos7.0 + tomcat8.5 + jdk1.8 + mysql5.7吧，简单的走流程的东西就不写了，只写一下在安装过程中走的坑,haha。 [toc] 一. 阿里云ECS服务器二. mysql安装 官网下载，安装到/usr/local/mysql目录下官方地址：https://dev.mysql.com/downloads/mysql/选择要下载的版本，上传到服务器即可，然后进行一系列的安装操作，下面具体说遇到的问题。 启动服务服务时出错 service mysqld start 错误及解决方案： 应该是缺少库，所以yum安装一下即可。 三. java环境安装配置 环境变量的配置安装过程不多说，环境变量配置如下： [root@will ~]# vim /etc/profile # 在export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL下添加 export JAVA_HOME=/usr/local/java export JRE_HOME=$JAVA_HOME/jre export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar #保存后，执行source /etc/profile使其生效 安装配置完成，验证是否配置成功。 [root@will ~]# java -version java version \"1.8.0_151\" Java(TM) SE Runtime Environment (build 1.8.0_151-b12) Java HotSpot(TM) 64-Bit Server VM (build 25.151-b12, mixed mode) 成功，java环境配置完成。 四. tomcat安装配置 端口号开放使用iptables进行端口号的开放。详情如下： # 安装 yum install iptables-services #配置防火墙 vim /etc/sysconfig/iptables # 在 22端口号线面添加 如下端口，然后保存并退出 （：wq） -A INPUT -p tcp -m state --state NEW -m tcp --dport 8080 -j ACCEPT -A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEPT -A INPUT -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPT #重启防火墙 systemctl restart iptables.service #查看 开放端口 iptables -L -n 注：这里必须要在 22端口号下面添加，不能添加到最后. 设置tomcat服务，开机自启具体实现命令如下： [root@will ~]# vim /usr/lib/systemd/system/tomcat.service #添加如下内容 [unit] Description=Tomcat After=syslog.target network.target remote-fs.target nss-lookup.target [Service] Type=forking PIDFile=/usr/local/tomcat/tomcat.pid ExecStart=/usr/local/tomcat/bin/startup.sh ExecReload=/bin/kill -s HUP $MAINPID ExecStop=/bin/kill -s QUIT $MAINPID PrivateTmp=true [Install] WantedBy=multi-user.target #添加完成，:wq保存 然后，cd到/usr/local/tomcat/bin/目录下，添加setenv.sh文件，具体操作如下： [root@will bin]# cd /usr/local/tomcat/bin/ [root@will bin]# vim setenv.sh #setenv.sh文件添加内容如下 #add tomcat pid CATALINA_PID=\"$CATALINA_BASE/tomcat.pid\" #add java opts JAVA_OPTS=\"-server -XX:PermSize=256M -XX:MaxPermSize=1024m -Xms512M -Xmx1024M -XX:MaxNewSize=256m\" #添加完成，:wq保存完成 设置开机自启，重启tomcat服务： [root@will bin]# systemctl enable tomcat Created symlink from /etc/systemd/system/multi-user.target.wants/tomcat.service to /usr/lib/systemd/system/tomcat.service. [root@will bin]# systemctl restart tomcat 注：自己在设置tomcat开机启动时，还是遇到挺多问题的，不过写blog时，忘记了，以后有机会遇见还会再补充上的！ systemctl相关命令，操作服务相关指令如下： # 启动服务，stop停止 systemctl start tomcat # 查看服务状态 systemctl status name # 设置开机自启，disable删除 systemctl enable tomcat # 重启服务 systemctl restart tomcat 五. 测试访问至此，centos7web环境搭建完成，测试访问。浏览器访问： http://ip:8080/ 出现tomcat欢迎页面即搭建成功。如有其他问题，也可备注添加^_^. 基本安装参考blog地址：https://www.cnblogs.com/ystq/articles/5919114.html","categories":[{"name":"运维","slug":"运维","permalink":"http://blog.willhappy.cn/categories/运维/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.willhappy.cn/tags/Linux/"}]},{"title":"在Linux上搭建Nginx服务器","slug":"19_2017-06-14_在Linux上搭建Nginx服务器","date":"2017-06-14T00:00:00.000Z","updated":"2024-06-01T13:17:35.408Z","comments":true,"path":"2017/06/14/19-2017-06-14-zai-linux-shang-da-jian-nginx-fu-wu-qi/","link":"","permalink":"http://blog.willhappy.cn/2017/06/14/19-2017-06-14-zai-linux-shang-da-jian-nginx-fu-wu-qi/","excerpt":"同样是分布式系统中，需要使用nginx服务器，关于nginx的相关概念知识，百度google吧，就不多说了，主要说一下自己Linxu上搭建nginx服务器是遇到的问题，并且在此项目中，是使用虚拟机搭建一个专门的服务器来存放图片，在此服务器上安装一个nginx来提供http服务，安装一个ftp服务器来提供图片的上传服务。","text":"同样是分布式系统中，需要使用nginx服务器，关于nginx的相关概念知识，百度google吧，就不多说了，主要说一下自己Linxu上搭建nginx服务器是遇到的问题，并且在此项目中，是使用虚拟机搭建一个专门的服务器来存放图片，在此服务器上安装一个nginx来提供http服务，安装一个ftp服务器来提供图片的上传服务。 [toc] 一. 环境准备我自己的环境（可以自己选择版本）： 安装了CentOS7的VM虚拟机（如何安装，参考Linux学习 ） Xshell5安全终端模拟软件（下载地址：http://www.netsarang.com/download/free_license.html ） 在这多说一点，关于xshell连接CentOS时的问题，如果你的xshell可以连接到Linux，那直接跳到第三节，没有连接好，看第二节，当然你也可以直接登录centos，在终端进行操作，使用xshell主要是方便可以再Windows界面下访问不同系统下的服务器，从而较好的达到远端控制终端的目的。 二. Xshell连接CentOS下载好xshell，安装完成后，启动，首先，要保证centos，可以连接上网。不能上网的话，参考博客：http://www.linuxidc.com/Linux/2013-05/83803.htm然后就是使用xshell连接centos，参考：http://jingyan.baidu.com/article/36d6ed1f7520991bcf4883e6.html 关于Xshell连接Centos就说这么多了。以后多使用，应该就熟练了。 三. 安装Nginx nginx安装环境nginx是C语言开发，建议在linux上运行，本教程使用Centos6.5作为安装环境。 gcc安装nginx需要先将官网下载的源码进行编译，编译依赖gcc环境，如果没有gcc环境，需要安装gcc： yum install gcc-c++ PCREPCRE(Perl Compatible Regular Expressions)是一个Perl库，包括 perl 兼容的正则表达式库。nginx的http模块使用pcre来解析正则表达式，所以需要在linux上安装pcre库。 yum install -y pcre pcre-devel 注：pcre-devel是使用pcre开发的一个二次开发库。nginx也需要此库。 zlibzlib库提供了很多种压缩和解压缩的方式，nginx使用zlib对http包的内容进行gzip，所以需要在linux上安装zlib库。 yum install -y zlib zlib-devel opensslOpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。nginx不仅支持http协议，还支持https（即在ssl协议上传输http），所以需要在linux安装openssl库。 yum install -y openssl openssl-devel 编译安装 首先进入/usr/local cd /usr/local 从官网下载nginx（版本自己选择） wget http://nginx.org/download/nginx-1.9.8.tar.gz 解压nginx压缩包 tar -zxvf nginx-1.9.8.tar.gz 会产生一个nginx-1.9.8目录，进入这个目录 cd nginx-1.9.8 接下来安装，使用–prefix参数指定nginx安装目录 ./configure –help查询详细参数 ./configure \\ --prefix=/usr/local/nginx \\ --pid-path=/var/run/nginx/nginx.pid \\ --lock-path=/var/lock/nginx.lock \\ --error-log-path=/var/log/nginx/error.log \\ --http-log-path=/var/log/nginx/access.log \\ --with-http_gzip_static_module \\ --http-client-body-temp-path=/var/temp/nginx/client \\ --http-proxy-temp-path=/var/temp/nginx/proxy \\ --http-fastcgi-temp-path=/var/temp/nginx/fastcgi \\ --http-uwsgi-temp-path=/var/temp/nginx/uwsgi \\ --http-scgi-temp-path=/var/temp/nginx/scgi 注意：上边将临时文件目录指定为/var/temp/nginx，需要在/var下创建temp及nginx目录 编译安装 make make install 安装成功查看安装目录： 三. 启动Nginx 进入nginx安装目录，启动nginx cd /usr/local/nginx/sbin/ ./nginx 查看nginx进程： 停止nginx方式1，快速停止： cd /usr/local/nginx/sbin ./nginx -s stop 此方式相当于先查出nginx进程id再使用kill命令强制杀掉进程。 方式2，完整停止(建议使用)： cd /usr/local/nginx/sbin ./nginx -s quit 此方式停止步骤是待nginx进程处理任务完毕进行停止。 重启nginx 方式1，先停止再启动（建议使用）：对nginx进行重启相当于先停止nginx再启动nginx，即先执行停止命令再执行启动命令。如下： ./nginx -s quit ./nginx 方式2，重新加载配置文件：当nginx的配置文件nginx.conf修改后，要想让配置生效需要重启nginx，使用-s reload不用先停止nginx再启动nginx即可将配置信息在nginx中生效，如下： ./nginx -s reload 四. 测试nginx安装成功，启动nginx，即可访问虚拟机上的nginx：到这说明nginx上安装成功。 注：安装方法二：http://blog.csdn.net/oldguncm/article/details/78855000","categories":[{"name":"运维","slug":"运维","permalink":"http://blog.willhappy.cn/categories/运维/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.willhappy.cn/tags/Linux/"},{"name":"Nginx","slug":"Nginx","permalink":"http://blog.willhappy.cn/tags/Nginx/"}]},{"title":"安装Nginx和vsftpd的坑","slug":"18_2017-06-13_安装Nginx和vsftpd的坑","date":"2017-06-13T00:00:00.000Z","updated":"2024-06-01T13:17:35.408Z","comments":true,"path":"2017/06/13/18-2017-06-13-an-zhuang-nginx-he-vsftpd-de-keng/","link":"","permalink":"http://blog.willhappy.cn/2017/06/13/18-2017-06-13-an-zhuang-nginx-he-vsftpd-de-keng/","excerpt":"为了搭个图片服务器，在centos上安装配置Nginx和vsftpd服务，简直折腾了我一天的时间，最终得出结论，还是要好好学习Linux，不然真是折腾死个人！","text":"为了搭个图片服务器，在centos上安装配置Nginx和vsftpd服务，简直折腾了我一天的时间，最终得出结论，还是要好好学习Linux，不然真是折腾死个人！ [toc] 一. Nginx访问问题 nginx安装完成之后，启动起来了，发现在物理机中访问不到，这可能的原因是Linux防火墙的问题。解决方案：http://www.cnblogs.com/yomho/p/6074815.html谢谢博主，我就不写了//呲牙。 前一天装好了，第二天起来，再次启动，发现起不来了Nginx，错误信息如下： 实在没找到什么原因，怀疑是由于nginx停止的方式不对，因为前一天晚上因为机子卡，vm非正常关闭，导致了无法启动，果断重装了。以后再遇到就再说了，要不进行不下去了。 后来找到解决方案： [root@localhost var]# cd /var/run ###先cd到/var/run目录下 [root@localhost run]# mkdir nginx ###然后创建nginx目录 [root@TEST sbin]# sudo ./nginx -c /usr/local/nginx/conf/nginx.conf ###重新配置nginx配置文件 [root@TEST sbin]# ./nginx -s reload ###重新加载配置文件 虚拟机重启，需要重新配置文件即可 方案二：参考https://jingyan.baidu.com/article/f00622281858e2fbd3f0c81b.html 每次重启比较麻烦，可以设置nginx开机自启，https://www.cnblogs.com/piscesLoveCc/p/5867900.html 访问url： ip/images/123.jpg，正常访问 关于Nginx的配置文件访问路径问题。当使用vsftpd上传到相应目录文件后，怎么取访问呢？需要我们在nginx的安装目录中找到nginx.conf文件，我的配置文件所在目录：/usr/local/nginx/conf/nginx.conf,打开该文件修改： #gzip on; server { listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / { # root html;之前的配置 # 现在的配置在下面：访问路径：/home/ftpuser/wwww； root /home/ftpuser/www; index index.html index.htm; } 修改完成后，重新加载ngnix： [root@localhost sbin]# ./nginx -s reload 通过上面的一步，或许还会出现403 Forbidden的错误原因分析：权限问题解决方案：同样在nginx.conf的头部加入一行： user root; 同样的，重新加载配置文件，启动nginx，此时我们就可以正常访问了。 二. vsftpd的配置问题 需要注意的一个问题是，防火墙开启21端口，详细参考：前一章节 关于修改iptables和vsftpd.conf配置文件后，重启服务的命令，centos或者Fedora等高版本与其它版本有不通。 # /bin/systemctl start vsftpd.service 否则会报： Redirecting to /bin/systemctl restart vsftpd.service 关于使用FileZilla上传文件出现553 Could not create file错误原因分析：可能是linux文件的访问权限问题。解决办法：进去linux，找到访问文件的目录，找到相应的文件，鼠标右键点击属性，权限，设置权限为可写，重启一下vsftpd服务即可。然后重新使用FileZilla重新上传一下文件，即可。","categories":[{"name":"运维","slug":"运维","permalink":"http://blog.willhappy.cn/categories/运维/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.willhappy.cn/tags/Linux/"},{"name":"vsftpd","slug":"vsftpd","permalink":"http://blog.willhappy.cn/tags/vsftpd/"},{"name":"Nginx","slug":"Nginx","permalink":"http://blog.willhappy.cn/tags/Nginx/"}]},{"title":"windows下安装使用Redis","slug":"17_2017-06-12_windows下安装使用Redis","date":"2017-06-12T00:00:00.000Z","updated":"2024-06-01T13:17:35.408Z","comments":true,"path":"2017/06/12/17-2017-06-12-windows-xia-an-zhuang-shi-yong-redis/","link":"","permalink":"http://blog.willhappy.cn/2017/06/12/17-2017-06-12-windows-xia-an-zhuang-shi-yong-redis/","excerpt":"","text":"[toc] 1.redis介绍Redis是一个Key-value存储系统。在学习慕课网java高并发秒杀的高并发优化是接触到redis，顺便记录学习过程。 2.redis安装注：本文主要讲解在windows下安装 linux下安装 由于本人尚未学习linux，所以以后有机会可能会写，百度的意思是在linux环境下redis可以直接通过源码编译安装。 windows下安装 自行百度，google之。参考：redis安装使用 3.启动redis进入redis安装目录后，执行命令开启服务（可能会出现port占用情况） redis-server.exe redis.conf 同样在redis的安装目录下，执行命令链接redis进行测试 redis-cli 通过info命令查看redis的运行情况 info 4.使用java访问本地redis做缓存Jedis ：http://www.oschina.net/p/jedis （Redis的官方首选Java开发包） redis.clients jedis 2.7.3 测试例子原帖：http://flychao88.iteye.com/blog/1527163 package com.lujianing.utils; import org.junit.Before; import org.junit.Test; import redis.clients.jedis.Jedis; import redis.clients.jedis.JedisPool; import redis.clients.jedis.JedisPoolConfig; import java.util.HashMap; import java.util.Iterator; import java.util.List; import java.util.Map; /** * Created by lujianing on 14-2-28. */ public class JedisUtilTest { JedisPool pool; Jedis jedis; @Before public void setUp() { pool = new JedisPool(new JedisPoolConfig(), \"192.168.10.61\"); jedis = pool.getResource(); // jedis.auth(\"password\"); } @Test public void testGet(){ System.out.println(jedis.get(\"lu\")); } /** * Redis存储初级的字符串 * CRUD */ @Test public void testBasicString(){ //-----添加数据---------- jedis.set(\"name\",\"minxr\");//向key-->name中放入了value-->minxr System.out.println(jedis.get(\"name\"));//执行结果：minxr //-----修改数据----------- //1、在原来基础上修改 jedis.append(\"name\",\"jarorwar\"); //很直观，类似map 将jarorwar append到已经有的value之后 System.out.println(jedis.get(\"name\"));//执行结果:minxrjarorwar //2、直接覆盖原来的数据 jedis.set(\"name\",\"闵晓荣\"); System.out.println(jedis.get(\"name\"));//执行结果：闵晓荣 //删除key对应的记录 jedis.del(\"name\"); System.out.println(jedis.get(\"name\"));//执行结果：null /** * mset相当于 * jedis.set(\"name\",\"minxr\"); * jedis.set(\"jarorwar\",\"闵晓荣\"); */ jedis.mset(\"name\",\"minxr\",\"jarorwar\",\"闵晓荣\"); System.out.println(jedis.mget(\"name\",\"jarorwar\")); } /** * jedis操作Map */ @Test public void testMap(){ Map&lt;String,String> user=new HashMap&lt;String,String>(); user.put(\"name\",\"minxr\"); user.put(\"pwd\",\"password\"); jedis.hmset(\"user\",user); //取出user中的name，执行结果:[minxr]-->注意结果是一个泛型的List //第一个参数是存入redis中map对象的key，后面跟的是放入map中的对象的key，后面的key可以跟多个，是可变参数 List&lt;String> rsmap = jedis.hmget(\"user\", \"name\"); System.out.println(rsmap); //删除map中的某个键值 // jedis.hdel(\"user\",\"pwd\"); System.out.println(jedis.hmget(\"user\", \"pwd\")); //因为删除了，所以返回的是null System.out.println(jedis.hlen(\"user\")); //返回key为user的键中存放的值的个数1 System.out.println(jedis.exists(\"user\"));//是否存在key为user的记录 返回true System.out.println(jedis.hkeys(\"user\"));//返回map对象中的所有key [pwd, name] System.out.println(jedis.hvals(\"user\"));//返回map对象中的所有value [minxr, password] Iterator&lt;String> iter=jedis.hkeys(\"user\").iterator(); while (iter.hasNext()){ String key = iter.next(); System.out.println(key+\":\"+jedis.hmget(\"user\",key)); } } /** * jedis操作List */ @Test public void testList(){ //开始前，先移除所有的内容 jedis.del(\"java framework\"); System.out.println(jedis.lrange(\"java framework\",0,-1)); //先向key java framework中存放三条数据 jedis.lpush(\"java framework\",\"spring\"); jedis.lpush(\"java framework\",\"struts\"); jedis.lpush(\"java framework\",\"hibernate\"); //再取出所有数据jedis.lrange是按范围取出， // 第一个是key，第二个是起始位置，第三个是结束位置，jedis.llen获取长度 -1表示取得所有 System.out.println(jedis.lrange(\"java framework\",0,-1)); } /** * jedis操作Set */ @Test public void testSet(){ //添加 jedis.sadd(\"sname\",\"minxr\"); jedis.sadd(\"sname\",\"jarorwar\"); jedis.sadd(\"sname\",\"闵晓荣\"); jedis.sadd(\"sanme\",\"noname\"); //移除noname jedis.srem(\"sname\",\"noname\"); System.out.println(jedis.smembers(\"sname\"));//获取所有加入的value System.out.println(jedis.sismember(\"sname\", \"minxr\"));//判断 minxr 是否是sname集合的元素 System.out.println(jedis.srandmember(\"sname\")); System.out.println(jedis.scard(\"sname\"));//返回集合的元素个数 } @Test public void test() throws InterruptedException { //keys中传入的可以用通配符 System.out.println(jedis.keys(\"*\")); //返回当前库中所有的key [sose, sanme, name, jarorwar, foo, sname, java framework, user, braand] System.out.println(jedis.keys(\"*name\"));//返回的sname [sname, name] System.out.println(jedis.del(\"sanmdde\"));//删除key为sanmdde的对象 删除成功返回1 删除失败（或者不存在）返回 0 System.out.println(jedis.ttl(\"sname\"));//返回给定key的有效时间，如果是-1则表示永远有效 jedis.setex(\"timekey\", 10, \"min\");//通过此方法，可以指定key的存活（有效时间） 时间为秒 Thread.sleep(5000);//睡眠5秒后，剩余时间将为&lt;=5 System.out.println(jedis.ttl(\"timekey\")); //输出结果为5 jedis.setex(\"timekey\", 1, \"min\"); //设为1后，下面再看剩余时间就是1了 System.out.println(jedis.ttl(\"timekey\")); //输出结果为1 System.out.println(jedis.exists(\"key\"));//检查key是否存在 System.out.println(jedis.rename(\"timekey\",\"time\")); System.out.println(jedis.get(\"timekey\"));//因为移除，返回为null System.out.println(jedis.get(\"time\")); //因为将timekey 重命名为time 所以可以取得值 min //jedis 排序 //注意，此处的rpush和lpush是List的操作。是一个双向链表（但从表现来看的） jedis.del(\"a\");//先清除数据，再加入数据进行测试 jedis.rpush(\"a\", \"1\"); jedis.lpush(\"a\",\"6\"); jedis.lpush(\"a\",\"3\"); jedis.lpush(\"a\",\"9\"); System.out.println(jedis.lrange(\"a\",0,-1));// [9, 3, 6, 1] System.out.println(jedis.sort(\"a\")); //[1, 3, 6, 9] //输入排序后结果 System.out.println(jedis.lrange(\"a\",0,-1)); } } Redis会定时 保存数据到硬盘上在redis安装目录下，通过命令链接redis redis-cli 然后通过命令查看redis存储大小 dbsize 通过 keys * 查看存储的键值通过 get 键：值 拿到存储的二进制数据。","categories":[{"name":"运维","slug":"运维","permalink":"http://blog.willhappy.cn/categories/运维/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://blog.willhappy.cn/tags/Redis/"},{"name":"Database","slug":"Database","permalink":"http://blog.willhappy.cn/tags/Database/"}]},{"title":"Centos安装vsftpd组件","slug":"16_2017-06-11_Centos安装vsftpd组件","date":"2017-06-11T00:00:00.000Z","updated":"2024-06-01T13:17:35.408Z","comments":true,"path":"2017/06/11/16-2017-06-11-centos-an-zhuang-vsftpd-zu-jian/","link":"","permalink":"http://blog.willhappy.cn/2017/06/11/16-2017-06-11-centos-an-zhuang-vsftpd-zu-jian/","excerpt":"转载至vsftpd安装手册。。。","text":"转载至vsftpd安装手册。。。 [toc] 一. 安装vsftpd组件安装完后，有/etc/vsftpd/vsftpd.conf 文件，是vsftp的配置文件。 [root@bogon ~]# yum -y install vsftpd 二. 添加一个ftp用户此用户就是用来登录ftp服务器用的。 [root@bogon ~]# useradd ftpuser 这样一个用户建完，可以用这个登录，记得用普通登录不要用匿名了。登录后默认的路径为 /home/ftpuser. 三. 给ftp用户添加密码[root@bogon ~]# passwd ftpuser 输入两次密码后修改密码。 四. 防火墙开启21端口因为ftp默认的端口为21，而centos默认是没有开启的，所以要修改iptables文件 [root@bogon ~]# vim /etc/sysconfig/iptables 在行上面有22 -j ACCEPT 下面另起一行输入跟那行差不多的，只是把22换成21，然后：wq保存。 -A INPUT -p tcp -m multiport --dport 20,21 -m state --state NEW -j ACCEPT --开启20,21端口 -A INPUT -p tcp -m state --state NEW -m tcp --dport 21 -j ACCEPT --开启21主动端口 -A INPUT -p tcp --dport 30000:31000 -j ACCEPT --开启被动端口 还要运行下,重启iptables [root@bogon ~]# service iptables restart 五. 修改selinux外网是可以访问上去了，可是发现没法返回目录（使用ftp的主动模式，被动模式还是无法访问），也上传不了，因为selinux作怪了。修改selinux：执行以下命令查看状态： [root@bogon ~]# getsebool -a | grep ftp allow_ftpd_anon_write --> off allow_ftpd_full_access --> off allow_ftpd_use_cifs --> off allow_ftpd_use_nfs --> off ftp_home_dir --> off ftpd_connect_db --> off ftpd_use_passive_mode --> off httpd_enable_ftp_server --> off tftp_anon_write --> off [root@bogon ~]# 执行上面命令，再返回的结果看到两行都是off，代表，没有开启外网的访问 [root@bogon ~]# setsebool -P allow_ftpd_full_access on [root@bogon ~]# setsebool -P ftp_home_dir on 六. 关闭匿名访问修改/etc/vsftpd/vsftpd.conf文件： anonymous_enable=NO 重启ftp服务： [root@bogon ~]# service vsftpd restart 七. 开启被动模式默认是开启的，但是要指定一个端口范围，打开vsftpd.conf文件，在后面加上 pasv_min_port=30000pasv_max_port=30999 表示端口范围为30000~30999，这个可以随意改。改完重启一下vsftpd由于指定这段端口范围，iptables也要相应的开启这个范围，所以像上面那样打开iptables文件。也是在21上下面另起一行，更那行差不多，只是把21 改为30000:30999,然后:wq保存，重启下iptables。这样就搞定了。 八. 设置开机启动vsftpd ftp服务[root@bogon ~]# chkconfig vsftpd on 相关问题和踩过的坑，查看下一章节。","categories":[{"name":"运维","slug":"运维","permalink":"http://blog.willhappy.cn/categories/运维/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.willhappy.cn/tags/Linux/"},{"name":"vsftpd","slug":"vsftpd","permalink":"http://blog.willhappy.cn/tags/vsftpd/"}]},{"title":"使用Nexus搭建Maven私服","slug":"15_2017-01-09_使用Nexus搭建Maven私服","date":"2017-01-09T00:00:00.000Z","updated":"2024-06-01T13:17:35.408Z","comments":true,"path":"2017/01/09/15-2017-01-09-shi-yong-nexus-da-jian-maven-si-fu/","link":"","permalink":"http://blog.willhappy.cn/2017/01/09/15-2017-01-09-shi-yong-nexus-da-jian-maven-si-fu/","excerpt":"最近使用IDEA基于Maven开发项目，有些jar包在本地仓库找不到，要到中央仓库去下载，很慢，一天搞不成个啥事，想着可以搭建一个Maven私服。一来通过私服管理jar包插件，同时将自己的一些jar包放上去，供自己以后使用。二来就是能够加开一些自己的开发效率，要不真是弄不成个事。同时，也从网上了解到Maven私服，在公司内部同样非常实用，可以解决内网访问问题，jar包闭源问题，重复下载问题等等，也增加了写找工作前，增加知识储备的动力，总之，一步步来吧，呲呲。。。","text":"最近使用IDEA基于Maven开发项目，有些jar包在本地仓库找不到，要到中央仓库去下载，很慢，一天搞不成个啥事，想着可以搭建一个Maven私服。一来通过私服管理jar包插件，同时将自己的一些jar包放上去，供自己以后使用。二来就是能够加开一些自己的开发效率，要不真是弄不成个事。同时，也从网上了解到Maven私服，在公司内部同样非常实用，可以解决内网访问问题，jar包闭源问题，重复下载问题等等，也增加了写找工作前，增加知识储备的动力，总之，一步步来吧，呲呲。。。 [toc] 一. Nexus下载安装前提环境(我自己的)： Win10系统 JDK1.8 Maven3 哎，说来也头疼，网上关于私服搭建的知识，多的狠，可是，无奈，我下的最新版本nexus-3.2.0-01-win64.zip,他和网上介绍版本有所不同，网上大都是以Nexus1.x，Nexus2.x为例，而Nexus3.x和前两个版本的配置完全不同，其目录结构也不尽相同，这里以我下的版本为例，做介绍。 下载地址：https://www.sonatype.com/download-oss-sonatype 下载完，解压即可得到两个目录结构：nexus-3.2.0-01和sonatype-work nexus-3.2.0-01为Nexus的安装文件目录，sonatype-work为Nexus的工作（数据）目录，和以往版本的Nexus不同，nexus的启动文件不是通过nexus2.x/bin/nexus.bat来运行，现在nexus.bat文件压根就不存在，取而代之的是nexus.exe,所以真是折腾了半天都不知道怎么玩的。 二. Nexus的配置 修改数据存储的路径，文件目录为：\\nexus-3.2.0-01\\bin\\nexus.vmoptions 修改IP，端口，访问根目录，文件目录为：\\nexus-3.2.0-01\\etc\\nexus-default.properties修改之后重新启动，即可。 这一步注意几点，一是要注意各个配置文件的目录所在位置，二是，其实都可以实用默认的配置，直接运行，即可访问，嘻嘻，何必多次一举呢，对不对，但是毕竟是学习，可以搞下玩玩。 三. Nexus运行这里注意一下，关于Nexus3.x的运行和其它版本有所不同，首先，我们要进入命令行，通过命令来执行， 如果嫌一层层进入目录麻烦，可以直接粘贴nexus.exe所在目录，cd 到这个目录即可，也可以先进入nexus.exe所在目录，按住Shift，点鼠标右键，点击在此处打开命令窗口，可直接进入此目录。 出现下面的message，即表示nexus已运行， 启动后，可以使用浏览器通过http://localhost:8088/进行访问了（我自己修改的端口为8088，默认为8081），界面如下： 可以通过右上方的Sign in进行登录，默认的用户名admin，密码admin123 四. Nexus服务安装这个比较坑爹，搞了半天，要将Nexus安装成windows服务，首先要安装，嘻嘻，不是废话吗，这一步同样要使用nexus.exe这个可执行文件，所以首先要进入到这个文件的所在目录。这一步，你可能会出现下面的错误： 呵呵，那是因为我们没有使用管理员的身份进入命令行，我也犯错了，window安装服务可能是要用管理员的身份的，所以会出现错误。但是，运行nexus是没问题的。 好了下面我们正式以管理员的身份进入命令行执行nexus服务的安装：上面表示安装成功。可以查看一下我们电脑的所有服务当中，就有了Nexus服务。 说明一下Nexus关于服务的几个命令： nexus.exe /install //nexus服务的安装 nexus.exe /start //启动nexus服务 nexus.exe /stop //停止nexus服务 nexus.exe /uninstall //卸载nexus服务 &lt;optional-service-name&gt;自己取服务的名字，我取的是Nexus，默认的官网上说好像是nexus。 对于start，stop这两个命令，如果嫌命令行麻烦的话，就手动上windows服务中去设置。 至此，关于Nexus的安装下载配置，就完成了。喜欢的加个关注。。","categories":[{"name":"后端","slug":"后端","permalink":"http://blog.willhappy.cn/categories/后端/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"http://blog.willhappy.cn/tags/Maven/"},{"name":"Nexus","slug":"Nexus","permalink":"http://blog.willhappy.cn/tags/Nexus/"}]},{"title":"Linux学习笔记（初级）","slug":"14_2017-01-08_Linux学习笔记（初级）","date":"2017-01-08T00:00:00.000Z","updated":"2024-06-01T13:17:35.408Z","comments":true,"path":"2017/01/08/14-2017-01-08-linux-xue-xi-bi-ji-chu-ji/","link":"","permalink":"http://blog.willhappy.cn/2017/01/08/14-2017-01-08-linux-xue-xi-bi-ji-chu-ji/","excerpt":"","text":"[toc] 前言 学习之路参考：http://www.oschina.net/question/587367_156024文章参考：http://wiki.jikexueyuan.com/project/linux-in-eye-of-java/书籍参考：《Linux就是这个范儿》阿里巴巴Linux技术大拿赵鑫磊、支付宝高级专家Jie Zhang 著在此感谢以上技术贡献者。。。 一. 学习工具准备 VM ware workstation12虚拟机（百度下载） Linux系统镜像文件，iso文件 注：因为Linux为开源系统，所以版本众多，作为小白的我，刚开始都不知道去选择哪个版本比较好，当遇到选择障碍症的时候，我们可以百度，可以google啊。借鉴了百度的经验：http://jingyan.baidu.com/article/95c9d20da1045dec4e7561ee.html 二. 虚拟机和Linux的安装 百度，google一大堆了，也不想说了，自己也是照这上边操做，一步一步来吧。VMware workstation pro12安装详细参考： http://jingyan.baidu.com/article/215817f78879c21edb142379.html?qq-pf-to=pcqq.group Linux安装详细参考： Ubuntu安装： http://jingyan.baidu.com/article/4f7d5712d20a1b1a21192760.htmlElementary OS安装： http://jingyan.baidu.com/album/f3e34a12df6eddf5ea65357d.html?picindex=10CentOS安装： http://blog.csdn.net/alex_my/article/details/38142229 注：创建好虚拟机后，启动是“出现Intel VT-x 处于禁用状态”，通过进入blos进行设置Intel VT-x为Enabled状态，详细解决办法见：百度经验：http://jingyan.baidu.com/article/fc07f98976710e12ffe519de.html 三.Linux介绍 以后关于Linux相关知识是基于CentOS的Linux的发行版，可能各个版本的Linux版本有细微的差别，但是并不影响我们学习linux，因为毕竟他们都是基于Linux内核的，都属于类Unix。 关于这个介绍比较好的，引用： Linux 本质来源不是 Unix，但是它借鉴了 Unix 的设计思想，所以在系统业界上把这种和 Unix 是一致设计思想的系统归为：类 Unix 系统。类 Unix 系统的介绍：https://zh.wikipedia.org/wiki/%E7%B1%BBUnix%E7%B3%BB%E7%BB%9F类 Unix 系统，除了我们今天要讲的 Linux，还有大家熟知的 Mac OS X、FreeBSD（这两个是直接从 Unix 系发展过来的，所以相对 Linux 是比较地道的类 Unix 系统） Linux 和 Mac OS X 都是类 Unix 系统，所以这篇文章中基本上的理由都可以用到 Linux 上的。 为什么国外程序员爱用 Mac？http://www.vpsee.com/2009/06/why-programmers-love-mac/ 哎，废话不多说了，下面就开始进入主题，我是按照书的内容进行，做好相应的笔记，查阅相应的资料 四. 返朴归真的命令行 别叹气，存在另一个世界，那就是命令行，让你暂时远离鼠标。对于那些苦哈哈的程序猿来讲，这也许是另一种情调的工作放肆。 —《Linux就是这个范儿》 介绍 用户和系统不是直接打交道的，他们中间有个名字叫shell的联系人，我们从键盘中输入命令给shell，shell再把它交给操作系统去执行。 shell就是Linux系统提供的一个叫终端模拟器的程序。 打开终端，我们可以看到shell的命令提示符是$,这意味你是普通用户，而root用户的提示符则为#。 文本和图形的切换Crtl+Alt+F1快捷键是代表图形界面，Ctrl+Alt+F2-F6对应5个不同的文本终端。 基本的命令操作看图片吧，：），从书上拍的，也可以上网查，多的狠。。。 快捷键废话不多说，上图！ 联机帮助—man狠靠谱 终端输入：$ man 命令名 便可以查看帮助手册，但是你的英文要通关奥，反正我不怎么能看懂，我很内疚。：（ 五. 融于心而表与行 用户身份（澡堂子模型）作者把Linux的用户管理方式比喻成一个澡堂子模型，我感觉，还是相当形象的，毕竟我们可以想象一下的，对吧。所有非root用户，都是这个澡堂子的顾客；root用户则是这个澡堂的服务生；Linux系统就是个大澡堂了。 具体的描述，看书的作者的形象描述，写的非常活泼：） 理解用户角色 还是以书中的介绍为主，Linux中用到的是用户组的概念，可以生动的把他理解为用户的职业，比如澡堂子里，除了客人之外，还有搓澡的，搓背的，烧水的等好多职业。在Linux中，也是一样，一个用户组就相当于一个职业，当然一个用户可以属于多个用户组，相当于身兼多职吗，并且也要注意，一个用户至少应该属于一个用户组。 /etc/passwd文件查看用户 cat /etc/passwd 终端输出： root:x:0:0:root:/root:/bin/bash bin:x:1:1:bin:/bin:/sbin/nologin daemon:x:2:2:daemon:/sbin:/sbin/nologin adm:x:3:4:adm:/var/adm:/sbin/nologin lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin sync:x:5:0:sync:/sbin:/bin/sync shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown halt:x:7:0:halt:/sbin:/sbin/halt mail:x:8:12:mail:/var/spool/mail:/sbin/nologin 其基本机构如下： 用户名：密码：UID：GID：用户全名：home 目录：shell 同样的，还有/etc/group文件查看组，其机构如下: 祖名：用户组密码：GID：用户组内的用户名 注：详细的解释，去看书吧，再写下来，太多了，好累，所以要看的自己去书上看吧。。。《Linux就是这个范儿》 管理用户和组 # useradd william 注：adduser是一个脚本，而useradd是一个二进制程序，前者对后者进行了封装，更加智能！类似的命令还有用户的删除，userdel，用户的修改，usermod至于对用户组的管理，就是相应的将“user”的这个前缀换成“group”，即groupadd，groupmod和groupdel。 利用sudo假借身份 比如/etc/shadow文件，由于其特殊性，普通用户是不被允许查看其内容的，但是拥有sudo特权的用户，可以执行以下命令： sudo cat/etc/shadow 那么如何获得sudo特权呢，起始就是修改/etc/sudoers的文件中内容， ## Allow root to run any commands anywhere root ALL=(ALL) ALL ## Allows members of the 'sys' group to run networking, software, ## service management apps and more. # %sys ALL = NETWORKING, SOFTWARE, SERVICES, STORAGE, DELEGATING, PROCESSES, LOCATE, DRIVERS ## Allows people in group wheel to run all commands %wheel ALL=(ALL) ALL ## Same thing without a password # %wheel ALL=(ALL) NOPASSWD: ALL ## Allows members of the users group to mount and unmount the ## cdrom as root # %users ALL=/sbin/mount /mnt/cdrom, /sbin/umount /mnt/cdrom ## Allows members of the users group to shutdown this system # %users localhost=/sbin/shutdown -h now ## Read drop-in files from /etc/sudoers.d (the # here does not mean a comment) #includedir /etc/sudoers.d 照着葫芦，画个瓢，在： root ALL=(ALL) ALL 后面，添加一行： william ALL=(ALL) ALL 我是谁？ [root@localhost will]# whoami root [root@localhost will]# who am i will pts/0 2016-11-23 11:03 (:0) [root@localhost will]# who will :0 2016-11-23 10:59 (:0) will pts/0 2016-11-23 11:03 (:0) will tty2 2016-11-23 12:14 注意：仔细观察他们上面的不同点。 文件和目录和window不同，Linux是使用颜色来区分文件和目录，也适用于区分不同种类的文件，蓝色代表目录，其他颜色代表文件，如：绿色代表可执行文件，青色代表符号连接等。了解详细，可： man dir_colors 还要了解几个特殊的目录标记： .代表当前目录，比如cd .或者cd ./都是工作目录变更到当前目录，等于没变。 ..代表上级目录 ~代表用户的home目录 /代表系统的根目录 pwd命令用户显示当前目录的绝对路径 -代表前一目录 更多特殊符号含义，请看：http://www.jb51.net/article/51342.htm 文件的属性和权限 drwxr-xr-x. 2 will will 6 11月 20 14:36 公共 drwxr-xr-x. 2 will will 6 11月 20 14:36 模板 drwxr-xr-x. 2 will will 6 11月 20 14:36 视频 drwxr-xr-x. 2 will will 6 11月 20 14:36 图片 drwxr-xr-x. 2 will will 6 11月 20 14:36 文档 drwxr-xr-x. 2 will will 6 11月 20 14:36 下载 drwxr-xr-x. 2 will will 6 11月 20 14:36 音乐 drwxr-xr-x. 2 will will 6 11月 20 14:36 桌面 文件属性的展现结构： drwxr-xr-x. 2 will will 6 11月 20 14:36 桌面对应解释为： 文件类型和权限/连接数/拥有者/所属用户组/文件大小/最后修改时间/文件名对于文件的类型和权限属性单独来说： drwxr-xr-x.第一个字符描述文件的类型，取值有：-、d、l、b、c、s和p，具体代表啥，自己去查吧，太多了。r代表读，w代表写，x代表执行，r-x代表所属用户组的权限，最后一个r-x代表其他。通过命令： ls-al 输出： -rw-r--r--. 1 will will 193 11月 20 2015 .bash_profile -rw-r--r--. 1 will will 231 11月 20 2015 .bashrc drwx------. 17 will will 4096 11月 20 15:10 .cache 可以查看全部的属性和权限信息，包含所有隐藏的文件。其中文件名前边带“.”,的即为隐藏文件，而实际上文件的隐藏属性就是在文件的前边添加“.”。更多文档说明可查看：https://www.shiyanlou.com/courses/1/labs/3/document 文件链接 关于硬链接和软连接的不同，得出如下推断：（具体的概念问题，自己翻书） 输入删除文件连接的目标文件，则软连接会失效，而硬链接则仅是“连接数”-1. 软连接可以创建在任何位置，包括网络，而硬链接则不行，目标文件与连接文件必须在同一磁盘分区内。 软硬连接在使用的时候区别不大，都相当于是一个文件具有不同的路径和文件名。 注：软连接，跟window中的快捷方式是一样的东西，而硬链接则是可以使得同一个文件能够拥有不同的路径，还能防止恶意被删除 修改文件的属性和权限使用命令： chmod a-r test.txt //给所有用户减去读权限 chmod ugo-w test.txt //给所属用户，所属组，其他减去写权限 chmod +x test.txt //默认的给所有用户加上执行权限（默认的操作对象，根据自己的亲自体验，去记，不一定准确） 深入文件权限，起始Linux的文件权限不只是r，w和x，还包括s和t这两个特殊的，他们与系统的账号和系统的进程相关，详情请参考范儿P52 ：）。 文件的基本操作常用命令ls、cd、cp、rm和mv，详情，网上自己查看。。。推荐几篇博客文章，感谢博主，我可以不用写了，：）http://blog.csdn.net/yiliumu/article/details/20405505http://www.centoscn.com/CentOS/2015/0325/5014.htmlhttp://www.cnblogs.com/zf2011/archive/2011/05/17/2049155.html 搜索文件五个命令，因地制宜，不同需求使用不同命令，作者想让我们称为那少数人，感觉好难，：》 whereis ls locate ls //或locate -b \"\\ls\" which gcc //一般用来确认系统是否安装了指定的软件，常用 type -p gcc //type -p相当于which，type其本身是判断一个命令是否属于shell内置的，作者告诉我的，他不让我告诉别人。 find /-mtime -1 -exec ls -1 {} \\; //find相当叼的一个搜索命令，具体怎么叼，去看作者吹的吧，比我吹好。P56 对文件的打包压缩 tar -zcvf filename.tar.gz FILES //打包成gz格式的压缩包，j代表bz2，J代表xz tar -vxf filename //解压缩 程序的执行问题这一小节，对于我这个门外汉来说，有点难，什么多任务协调机制啊，计划任务啊，守护进程等等，没大看懂，也不敢做过多总结，就这些吧，以后有能力了再细看，哈哈。P58 Linux软件安装 ①源码安装相对麻烦的方法，具体做法参考作者的P71，也可以参考博客文章，感谢：http://www.centoscn.com/CentOS/2012/1226/96.html这种方式的弊端，作者也分析了，就是说这样安装会因为没有做软件相关性检查会导致它依赖的其他软件不存在或者版本不正确，从而导致无法正常运行。 ②利用软件管理工具rpm和dpkg不说了上图：![RPM][5]![DPKG][6] ③线上升级工具apt和yum还是上图：![yum][7]![apt][8] 磁盘管理这节感觉也好难理解，决定跳过。。。以后有能力了再搞：） 解决上网问题这一章后面，不想看了，没什么兴致都下去了，以后有机会再细看：（","categories":[{"name":"System","slug":"System","permalink":"http://blog.willhappy.cn/categories/System/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.willhappy.cn/tags/Linux/"}]},{"title":"基于maven使用IDEA创建多模块项目","slug":"13_2017-01-07_基于maven使用IDEA创建多模块项目","date":"2017-01-07T00:00:00.000Z","updated":"2024-06-01T13:17:35.408Z","comments":true,"path":"2017/01/07/13-2017-01-07-ji-yu-maven-shi-yong-idea-chuang-jian-duo-mo-kuai-xiang-mu/","link":"","permalink":"http://blog.willhappy.cn/2017/01/07/13-2017-01-07-ji-yu-maven-shi-yong-idea-chuang-jian-duo-mo-kuai-xiang-mu/","excerpt":"鉴于最近学习一个分布式项目的开发，讲一下关于使用IntelliJ IDEA基于Maven创建多模块项目的实际开发，可能有不合适的地方，但是项目是可以跑通的，也请有不足之处，都提出来，一起讨论下。","text":"鉴于最近学习一个分布式项目的开发，讲一下关于使用IntelliJ IDEA基于Maven创建多模块项目的实际开发，可能有不合适的地方，但是项目是可以跑通的，也请有不足之处，都提出来，一起讨论下。 [toc] 一. 项目工程目录首先展示一下，最终整个项目的工程目录： 简单介绍一下目录结构：common-parent为所有项目的父项目，主要用来管理所有项目使用的jar包及其版本。common-utils为公共的工具类项目，继承父项目，它会被打成jar包供其它项目使用。taotao-manager为我们自己的项目，继承与我们的父项目。taotao-manager-pojo为我们自己项目的一个子模块，依赖与taotao-manager,打成jar包taotao-manager-mapper为我们自己项目的一个子模块，依赖与taotao-manager-pojo,打成jar包taotao-manager-service为我们自己项目的一个子模块，依赖与taotao-manager-mapper,打成jar包taotao-manager-web为我们自己项目的一个子模块，依赖与taotao-manager-service,打成war包 二. 创建父工程下面为具体操作： 首先打开IntelliJ IDEA，按下面步骤来：或者第一次打开IDEA， 来到创建目录，选择Empty project，next 来到New Project页面，填写project name，选择Project location，点Finish等待IDEA加载完成，进行下一步 选择File–&gt;New–&gt;Module,进入New Module页面： 在New Module页面，按如下步骤操作： 填写组织名称和项目名称，以及版本号 配置本地maven目录及maven仓库配置文件 创建父工程最后一步，给Module取名，及选择工作目录，选择完成 等待生成pom文件，注意修改打包方式为pom，修改pom文件如下：(由于pom文件较长，只给出部分，获取所有，请关注github) &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;groupId>cn.william&lt;/groupId> &lt;artifactId>common-parent&lt;/artifactId> &lt;version>1.0-SNAPSHOT&lt;/version> &lt;packaging>pom&lt;/packaging>&lt;!--修改打包方式--> &lt;name>common-parent&lt;/name> &lt;url>http://maven.apache.org&lt;/url> &lt;!--集中定义依赖版本号--> &lt;properties> &lt;project.build.sourceEncoding>UTF-8&lt;/project.build.sourceEncoding> &lt;junit.version>4.12&lt;/junit.version> ...(省略) &lt;/properties> &lt;dependencyManagement> &lt;dependencies> &lt;!-- 时间操作组件 --> &lt;dependency> &lt;groupId>joda-time&lt;/groupId> &lt;artifactId>joda-time&lt;/artifactId> &lt;version>${joda-time.version}&lt;/version> &lt;/dependency> ...(省略) &lt;/dependencyManagement> &lt;build> &lt;finalName>${project.artifactId}&lt;/finalName> &lt;plugins> &lt;!-- 资源文件拷贝插件 --> &lt;plugin> &lt;groupId>org.apache.maven.plugins&lt;/groupId> &lt;artifactId>maven-resources-plugin&lt;/artifactId> &lt;version>2.7&lt;/version> &lt;configuration> &lt;encoding>UTF-8&lt;/encoding> &lt;/configuration> &lt;/plugin> &lt;!-- java编译插件 --> &lt;plugin> &lt;groupId>org.apache.maven.plugins&lt;/groupId> &lt;artifactId>maven-compiler-plugin&lt;/artifactId> &lt;version>3.5.1&lt;/version> &lt;configuration> &lt;source>1.8&lt;/source> &lt;target>1.8&lt;/target> &lt;encoding>UTF-8&lt;/encoding> &lt;/configuration> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/project> 三. 创建公共工具类首先，公共工具类是继承自父项目common-parent的。需要注意的一点是一点，为了项目看起来为分模块的形式（类似在eclipse中开发），在创建common-utils中有一步需要注意：下一步特别注意，这一步会影响目录结构， 同样注意项目的打包方式为jar，和父项目有所不同。 &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;parent> &lt;artifactId>common-parent&lt;/artifactId> &lt;groupId>cn.william&lt;/groupId> &lt;version>1.0-SNAPSHOT&lt;/version> &lt;relativePath>../common-parent/pom.xml&lt;/relativePath> &lt;/parent> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;artifactId>common-utils&lt;/artifactId> &lt;packaging>jar&lt;/packaging>&lt;!-- 打成jar包 --> &lt;name>common-utils&lt;/name> &lt;url>http://maven.apache.org&lt;/url> &lt;properties> &lt;project.build.sourceEncoding>UTF-8&lt;/project.build.sourceEncoding> &lt;/properties> &lt;!-- jar包的依赖 --> &lt;dependencies> &lt;!-- 时间操作组件 --> &lt;dependency> &lt;groupId>joda-time&lt;/groupId> &lt;artifactId>joda-time&lt;/artifactId> &lt;/dependency> ...(省略) &lt;/dependencies> &lt;/project> 三. 创建开发项目创建开发项目taotao-manager，其创建步骤同上，同样是继承common-parent,同样修改其pom文件，详细如下： &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;parent> &lt;artifactId>common-parent&lt;/artifactId> &lt;groupId>cn.william&lt;/groupId> &lt;version>1.0-SNAPSHOT&lt;/version> &lt;relativePath>../common-parent/pom.xml&lt;/relativePath> &lt;/parent> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;artifactId>taotao-manager&lt;/artifactId> &lt;packaging>pom&lt;/packaging> &lt;name>taotao-manager&lt;/name> &lt;url>http://maven.apache.org&lt;/url> &lt;modules> &lt;module>taotao-manager-pojo&lt;/module> &lt;module>taotao-manager-mapper&lt;/module> &lt;module>taotao-manager-service&lt;/module> &lt;module>taotao-manager-web&lt;/module> &lt;/modules> &lt;properties> &lt;project.build.sourceEncoding>UTF-8&lt;/project.build.sourceEncoding> &lt;/properties> &lt;!-- 依赖管理 --> &lt;dependencies> &lt;dependency> &lt;groupId>cn.william&lt;/groupId> &lt;artifactId>common-utils&lt;/artifactId> &lt;version>1.0-SNAPSHOT&lt;/version> &lt;/dependency> &lt;/dependencies> &lt;build> &lt;!-- 配置插件 --> &lt;plugins> &lt;plugin> &lt;groupId>org.apache.tomcat.maven&lt;/groupId> &lt;artifactId>tomcat7-maven-plugin&lt;/artifactId> &lt;configuration> &lt;port>8080&lt;/port> &lt;path>/&lt;/path> &lt;/configuration> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/project> 四. 创建开发项目子模块创建taotao-manager-pojo，mapper，service，web等子模块，详细如下： 右键点击taotao-manager，选择New，Module，这一步注意，与创建common-utils时不同，是将其子模块添加到taotao-manager目录下的：maven的相关配置，保持默认：注意子模块所在目录就好： 创建taotao-manager下其它子模块上面说的时创建taotao-manager-pojo子模块，另外三个子模块的创建方式与其类似，有一点不同时，在创建taotao-manager-web子模块时，maven项目的类型选择如下： 修改子模块的pom文件 子模块pojo，mapper，service的打包方式全为jar，只有web子模块打包为war包。 pojo子模块，pom.xml详细如下： &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;parent> &lt;artifactId>taotao-manager&lt;/artifactId> &lt;groupId>cn.william&lt;/groupId> &lt;version>1.0-SNAPSHOT&lt;/version> &lt;/parent> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;artifactId>taotao-manager-pojo&lt;/artifactId> &lt;packaging>jar&lt;/packaging> &lt;name>taotao-manager-pojo&lt;/name> &lt;url>http://maven.apache.org&lt;/url> &lt;properties> &lt;project.build.sourceEncoding>UTF-8&lt;/project.build.sourceEncoding> &lt;/properties> &lt;/project> mapper子模块依赖与pojo子模块，pom.xml详细如下： &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;parent> &lt;artifactId>taotao-manager&lt;/artifactId> &lt;groupId>cn.william&lt;/groupId> &lt;version>1.0-SNAPSHOT&lt;/version> &lt;/parent> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;artifactId>taotao-manager-mapper&lt;/artifactId> &lt;packaging>jar&lt;/packaging> &lt;name>taotao-manager-mapper&lt;/name> &lt;url>http://maven.apache.org&lt;/url> &lt;properties> &lt;project.build.sourceEncoding>UTF-8&lt;/project.build.sourceEncoding> &lt;/properties> &lt;dependencies> &lt;!-- 依赖与pojo子模块 --> &lt;dependency> &lt;groupId>cn.william&lt;/groupId> &lt;artifactId>taotao-manager-pojo&lt;/artifactId> &lt;version>1.0-SNAPSHOT&lt;/version> &lt;/dependency> &lt;!-- Mybatis --> &lt;dependency> &lt;groupId>org.mybatis&lt;/groupId> &lt;artifactId>mybatis&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.mybatis&lt;/groupId> &lt;artifactId>mybatis-spring&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>com.github.miemiedev&lt;/groupId> &lt;artifactId>mybatis-paginator&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>com.github.pagehelper&lt;/groupId> &lt;artifactId>pagehelper&lt;/artifactId> &lt;/dependency> &lt;!-- MySql --> &lt;dependency> &lt;groupId>mysql&lt;/groupId> &lt;artifactId>mysql-connector-java&lt;/artifactId> &lt;/dependency> &lt;!-- 连接池 --> &lt;dependency> &lt;groupId>com.alibaba&lt;/groupId> &lt;artifactId>druid&lt;/artifactId> &lt;/dependency> &lt;/dependencies> &lt;/project> service子模块依赖与mapper子模块，pom.xml详细如下： &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;parent> &lt;artifactId>taotao-manager&lt;/artifactId> &lt;groupId>cn.william&lt;/groupId> &lt;version>1.0-SNAPSHOT&lt;/version> &lt;/parent> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;artifactId>taotao-manager-service&lt;/artifactId> &lt;packaging>jar&lt;/packaging> &lt;name>taotao-manager-service&lt;/name> &lt;url>http://maven.apache.org&lt;/url> &lt;properties> &lt;project.build.sourceEncoding>UTF-8&lt;/project.build.sourceEncoding> &lt;/properties> &lt;dependencies> &lt;!-- 依赖与mapper子模块 --> &lt;dependency> &lt;groupId>cn.william&lt;/groupId> &lt;artifactId>taotao-manager-mapper&lt;/artifactId> &lt;version>1.0-SNAPSHOT&lt;/version> &lt;/dependency> &lt;!-- Spring --> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-context&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-beans&lt;/artifactId> &lt;/dependency> ...（省略） &lt;/dependencies> &lt;/project> web子模块依赖与service子模块，pom.xml详细如下： &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"> &lt;parent> &lt;artifactId>taotao-manager&lt;/artifactId> &lt;groupId>cn.william&lt;/groupId> &lt;version>1.0-SNAPSHOT&lt;/version> &lt;/parent> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;artifactId>taotao-manager-web&lt;/artifactId> &lt;packaging>war&lt;/packaging>&lt;!--打成war包--> &lt;name>taotao-manager-web Maven Webapp&lt;/name> &lt;url>http://maven.apache.org&lt;/url> &lt;dependencies> &lt;!-- 依赖于service --> &lt;dependency> &lt;groupId>cn.william&lt;/groupId> &lt;artifactId>taotao-manager-service&lt;/artifactId> &lt;version>1.0-SNAPSHOT&lt;/version> &lt;/dependency> ...（省略） &lt;/dependencies> &lt;build> &lt;finalName>taotao-manager-web&lt;/finalName> &lt;/build> &lt;/project> 关于上面省略的部分，可查看github完整项目，地址： 五. 运行项目 创建index.jsp至此，项目创建已经完成，我们可以在taotao-manager-web的webapp目录下创建index.jsp,详情如下： 使用tomcat插件我们使用maven的tomcat插件来运行项目，在此之前，确保在taotao-manager的pom文件中配置了tomcat的插件： ...（省略） &lt;build> &lt;!-- 配置插件 --> &lt;plugins> &lt;plugin> &lt;groupId>org.apache.tomcat.maven&lt;/groupId> &lt;artifactId>tomcat7-maven-plugin&lt;/artifactId> &lt;configuration> &lt;port>8080&lt;/port> &lt;path>/&lt;/path> &lt;/configuration> &lt;/plugin> &lt;/plugins> &lt;/build> ...（省略） 配置Maven Tomcat Plugin运行web项目 （1） 添加新配置 （2） 点击运行，或者点击旁边的debug （3） 出项错误出现错误，可能是common-parent和common-utils没有安装到本地仓库，出现的错误是找不到common-utils的jar包，那就需要我们安装一下。 等待将jar包安装到本地仓库，稍微有点慢可能，耐心等。。。 安装完成之后，再次运行，出现下面的信息，证明运行成功： 通过浏览器访问： 至此，我们的项目环境搭建成功，接下来就是实际的项目开发了。 声明：① 关于上面代码中出现的省略的部分，是由于内容偏长，所以省略，想要查看完成项目，请查看本人的github，地址：https://github.com/williamHappy/tao-shopping-mall② 关于上面有任何不足之处，敬请各位谅解，毕竟本人技术有限，也在学习阶段，也可以给出合理意见，共同改进。③ 黑黑，喜欢的，加个关注白，哈哈哈","categories":[{"name":"后端","slug":"后端","permalink":"http://blog.willhappy.cn/categories/后端/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"http://blog.willhappy.cn/tags/Maven/"},{"name":"java","slug":"java","permalink":"http://blog.willhappy.cn/tags/java/"}]},{"title":"HttpClient实现网络请求","slug":"12_2017-01-05_HttpClient实现网络请求","date":"2017-01-05T00:00:00.000Z","updated":"2024-06-01T13:17:35.408Z","comments":true,"path":"2017/01/05/12-2017-01-05-httpclient-shi-xian-wang-luo-qing-qiu/","link":"","permalink":"http://blog.willhappy.cn/2017/01/05/12-2017-01-05-httpclient-shi-xian-wang-luo-qing-qiu/","excerpt":"转自：文章","text":"转自：文章 [toc] 1.简介HttpClient是Apache Jakarta Common下的子项目，用来提供高效的、最新的、功能丰富的支持HTTP协议的客户端编程工具包，并且它支持HTTP协议最新的版本和建议。HttpClient已经应用在很多的项目中，比如Apache Jakarta上很著名的另外两个开源项目Cactus和HTMLUnit都使用了HttpClient。下载地址: http://hc.apache.org/downloads.cgi 2.特性 基于标准、纯净的Java语言。实现了Http1.0和Http1.1 以可扩展的面向对象的结构实现了Http全部的方法（GET, POST, PUT, DELETE, HEAD, OPTIONS, and TRACE）。 支持HTTPS协议。 通过Http代理建立透明的连接。 利用CONNECT方法通过Http代理建立隧道的https连接。 Basic, Digest, NTLMv1, NTLMv2, NTLM2 Session, SNPNEGO/Kerberos认证方案。 插件式的自定义认证方案。 便携可靠的套接字工厂使它更容易的使用第三方解决方案。 连接管理器支持多线程应用。支持设置最大连接数，同时支持设置每个主机的最大连接数，发现并关闭过期的连接。 自动处理Set-Cookie中的Cookie。 插件式的自定义Cookie策略。 Request的输出流可以避免流中内容直接缓冲到socket服务器。 Response的输入流可以有效的从socket服务器直接读取相应内容。 在http1.0和http1.1中利用KeepAlive保持持久连接。 直接获取服务器发送的response code和 headers。 设置连接超时的能力。 实验性的支持http1.1 response caching。 源代码基于Apache License 可免费获取。【真心看不大懂】 3.使用方法使用HttpClient发送请求、接收响应很简单，一般需要如下几步即可。 创建HttpClient对象。 创建请求方法的实例，并指定请求URL。如果需要发送GET请求，创建HttpGet对象；如果需要发送POST请求，创建HttpPost对象。 如果需要发送请求参数，可调用HttpGet、HttpPost共同的setParams(HetpParams params)方法来添加请求参数；对于HttpPost对象而言，也可调用setEntity(HttpEntity entity)方法来设置请求参数。 调用HttpClient对象的execute(HttpUriRequest request)发送请求，该方法返回一个HttpResponse。 调用HttpResponse的getAllHeaders()、getHeaders(String name)等方法可获取服务器的响应头；调用HttpResponse的getEntity()方法可获取HttpEntity对象，该对象包装了服务器的响应内容。程序可通过该对象获取服务器的响应内容。 释放连接。无论执行方法是否成功，都必须释放连接 4.实例package com.test; import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.io.UnsupportedEncodingException; import java.security.KeyManagementException; import java.security.KeyStore; import java.security.KeyStoreException; import java.security.NoSuchAlgorithmException; import java.security.cert.CertificateException; import java.util.ArrayList; import java.util.List; import javax.net.ssl.SSLContext; import org.apache.http.HttpEntity; import org.apache.http.NameValuePair; import org.apache.http.ParseException; import org.apache.http.client.ClientProtocolException; import org.apache.http.client.entity.UrlEncodedFormEntity; import org.apache.http.client.methods.CloseableHttpResponse; import org.apache.http.client.methods.HttpGet; import org.apache.http.client.methods.HttpPost; import org.apache.http.conn.ssl.SSLConnectionSocketFactory; import org.apache.http.conn.ssl.SSLContexts; import org.apache.http.conn.ssl.TrustSelfSignedStrategy; import org.apache.http.entity.ContentType; import org.apache.http.entity.mime.MultipartEntityBuilder; import org.apache.http.entity.mime.content.FileBody; import org.apache.http.entity.mime.content.StringBody; import org.apache.http.impl.client.CloseableHttpClient; import org.apache.http.impl.client.HttpClients; import org.apache.http.message.BasicNameValuePair; import org.apache.http.util.EntityUtils; import org.junit.Test; public class HttpClientTest { @Test public void jUnitTest() { get(); } /** * HttpClient连接SSL */ public void ssl() { CloseableHttpClient httpclient = null; try { KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType()); FileInputStream instream = new FileInputStream(new File(\"d:\\\\tomcat.keystore\")); try { // 加载keyStore d:\\\\tomcat.keystore trustStore.load(instream, \"123456\".toCharArray()); } catch (CertificateException e) { e.printStackTrace(); } finally { try { instream.close(); } catch (Exception ignore) { } } // 相信自己的CA和所有自签名的证书 SSLContext sslcontext = SSLContexts.custom().loadTrustMaterial(trustStore, new TrustSelfSignedStrategy()).build(); // 只允许使用TLSv1协议 SSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(sslcontext, new String[] { \"TLSv1\" }, null, SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER); httpclient = HttpClients.custom().setSSLSocketFactory(sslsf).build(); // 创建http请求(get方式) HttpGet httpget = new HttpGet(\"https://localhost:8443/myDemo/Ajax/serivceJ.action\"); System.out.println(\"executing request\" + httpget.getRequestLine()); CloseableHttpResponse response = httpclient.execute(httpget); try { HttpEntity entity = response.getEntity(); System.out.println(\"----------------------------------------\"); System.out.println(response.getStatusLine()); if (entity != null) { System.out.println(\"Response content length: \" + entity.getContentLength()); System.out.println(EntityUtils.toString(entity)); EntityUtils.consume(entity); } } finally { response.close(); } } catch (ParseException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } catch (KeyManagementException e) { e.printStackTrace(); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } catch (KeyStoreException e) { e.printStackTrace(); } finally { if (httpclient != null) { try { httpclient.close(); } catch (IOException e) { e.printStackTrace(); } } } } /** * post方式提交表单（模拟用户登录请求） */ public void postForm() { // 创建默认的httpClient实例. CloseableHttpClient httpclient = HttpClients.createDefault(); // 创建httppost HttpPost httppost = new HttpPost(\"http://localhost:8080/myDemo/Ajax/serivceJ.action\"); // 创建参数队列 List&lt;namevaluepair> formparams = new ArrayList&lt;namevaluepair>(); formparams.add(new BasicNameValuePair(\"username\", \"admin\")); formparams.add(new BasicNameValuePair(\"password\", \"123456\")); UrlEncodedFormEntity uefEntity; try { uefEntity = new UrlEncodedFormEntity(formparams, \"UTF-8\"); httppost.setEntity(uefEntity); System.out.println(\"executing request \" + httppost.getURI()); CloseableHttpResponse response = httpclient.execute(httppost); try { HttpEntity entity = response.getEntity(); if (entity != null) { System.out.println(\"--------------------------------------\"); System.out.println(\"Response content: \" + EntityUtils.toString(entity, \"UTF-8\")); System.out.println(\"--------------------------------------\"); } } finally { response.close(); } } catch (ClientProtocolException e) { e.printStackTrace(); } catch (UnsupportedEncodingException e1) { e1.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } finally { // 关闭连接,释放资源 try { httpclient.close(); } catch (IOException e) { e.printStackTrace(); } } } /** * 发送 post请求访问本地应用并根据传递参数不同返回不同结果 */ public void post() { // 创建默认的httpClient实例. CloseableHttpClient httpclient = HttpClients.createDefault(); // 创建httppost HttpPost httppost = new HttpPost(\"http://localhost:8080/myDemo/Ajax/serivceJ.action\"); // 创建参数队列 List&lt;namevaluepair> formparams = new ArrayList&lt;namevaluepair>(); formparams.add(new BasicNameValuePair(\"type\", \"house\")); UrlEncodedFormEntity uefEntity; try { uefEntity = new UrlEncodedFormEntity(formparams, \"UTF-8\"); httppost.setEntity(uefEntity); System.out.println(\"executing request \" + httppost.getURI()); CloseableHttpResponse response = httpclient.execute(httppost); try { HttpEntity entity = response.getEntity(); if (entity != null) { System.out.println(\"--------------------------------------\"); System.out.println( \"Response content: \" + EntityUtils.toString(entity, \"UTF-8\") ); System.out.println(\"--------------------------------------\"); } } finally { response.close(); } } catch (ClientProtocolException e) { e.printStackTrace(); } catch (UnsupportedEncodingException e1) { e1.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } finally { // 关闭连接,释放资源 try { httpclient.close(); } catch (IOException e) { e.printStackTrace(); } } } /** * 发送 get请求 */ public void get() { CloseableHttpClient httpclient = HttpClients.createDefault(); try { // 创建httpget. HttpGet httpget = new HttpGet(\"http://www.baidu.com/\"); System.out.println(\"executing request \" + httpget.getURI()); // 执行get请求. CloseableHttpResponse response = httpclient.execute(httpget); try { // 获取响应实体 HttpEntity entity = response.getEntity(); System.out.println(\"--------------------------------------\"); // 打印响应状态 System.out.println(response.getStatusLine()); if (entity != null) { // 打印响应内容长度 System.out.println(\"Response content length: \" + entity.getContentLength()); // 打印响应内容 System.out.println(\"Response content: \" + EntityUtils.toString(entity)); } System.out.println(\"------------------------------------\"); } finally { response.close(); } } catch (ClientProtocolException e) { e.printStackTrace(); } catch (ParseException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } finally { // 关闭连接,释放资源 try { httpclient.close(); } catch (IOException e) { e.printStackTrace(); } } } /** * 上传文件 */ public void upload() { CloseableHttpClient httpclient = HttpClients.createDefault(); try { HttpPost httppost = new HttpPost(\"http://localhost:8080/myDemo/Ajax/serivceFile.action\"); FileBody bin = new FileBody(new File(\"F:\\\\image\\\\sendpix0.jpg\")); StringBody comment = new StringBody(\"A binary file of some kind\", ContentType.TEXT_PLAIN); HttpEntity reqEntity = MultipartEntityBuilder.create().addPart(\"bin\", bin).addPart(\"comment\", comment).build(); httppost.setEntity(reqEntity); System.out.println(\"executing request \" + httppost.getRequestLine()); CloseableHttpResponse response = httpclient.execute(httppost); try { System.out.println(\"----------------------------------------\"); System.out.println(response.getStatusLine()); HttpEntity resEntity = response.getEntity(); if (resEntity != null) { System.out.println(\"Response content length: \" + resEntity.getContentLength()); } EntityUtils.consume(resEntity); } finally { response.close(); } } catch (ClientProtocolException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } finally { try { httpclient.close(); } catch (IOException e) { e.printStackTrace(); } } } } 将post方法进行重载，传入的参数包含url和请求字符串，实例如下： public static String POST(String url,String str){ String result = null; //创建默认的httpClient实例 CloseableHttpClient httpClient = HttpClients.createDefault(); //创建httppost HttpPost httpPost = new HttpPost(url); UrlEncodedFormEntity encodedFormEntity; try { HttpEntity httpEntity = new StringEntity(str); httpPost.setEntity(httpEntity); System.out.println(\"executing request \"+ httpPost.getURI()); HttpResponse httpResponse; httpResponse = httpClient.execute(httpPost); HttpEntity responseEntity = httpResponse.getEntity(); if (responseEntity!=null) { System.out.println(\"-------------------------------------\"); result = EntityUtils.toString(responseEntity,\"UTF-8\"); System.out.println(\"-------------------------------------\"); } }catch (ClientProtocolException e){ e.printStackTrace(); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); }finally { //关闭链接，释放资源 try { httpClient.close(); } catch (IOException e) { e.printStackTrace(); } } return result; } HttpEntity httpEntity = new StringEntity(str);httpPost.setEntity(httpEntity);","categories":[{"name":"后端","slug":"后端","permalink":"http://blog.willhappy.cn/categories/后端/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.willhappy.cn/tags/java/"},{"name":"HttpClient","slug":"HttpClient","permalink":"http://blog.willhappy.cn/tags/HttpClient/"}]},{"title":"java之反射技术及其应用","slug":"11_2017-01-03_java之反射技术及其应用（java005）","date":"2017-01-03T00:00:00.000Z","updated":"2024-06-01T13:17:35.408Z","comments":true,"path":"2017/01/03/11-2017-01-03-java-zhi-fan-she-ji-zhu-ji-qi-ying-yong-java005/","link":"","permalink":"http://blog.willhappy.cn/2017/01/03/11-2017-01-03-java-zhi-fan-she-ji-zhu-ji-qi-ying-yong-java005/","excerpt":"翻阅了很多资料想查看一个比较通俗易懂的关于java反射机制的理解，但是想要从概念中去理解一项技术，可能有点困难，所以先将理论型知识贴出来，后面，慢慢来理解。","text":"翻阅了很多资料想查看一个比较通俗易懂的关于java反射机制的理解，但是想要从概念中去理解一项技术，可能有点困难，所以先将理论型知识贴出来，后面，慢慢来理解。 反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。—-《百度百科》 注意：要理解java的反射机制，先要了解以下基本概念：运行时,编译时,编译型,解释型,类加载器,动态加载类等相关概念。 [toc] 一. Class类的使用 概念理解在Java中，每个class都有一个相应的Class对象。也就是说，当我们编写一个类，编译完成后，在生成的.class文件中，就会产生一个Class对象，用于表示这个类的类型信息。 获取Class实例的方式不能直接创建Class的实例对象，因为Class类的构造方法是私有的，只有jvm可以去创建。(1) 利用对象调用getClass()方法获取该对象的Class实例；(2) 使用Class类的静态方法forName()，用类的名字获取一个Class实例，源码如下； @CallerSensitive public static Class&lt;?> forName(String className) throws ClassNotFoundException { Class&lt;?> caller = Reflection.getCallerClass(); return forName0(className, true, ClassLoader.getClassLoader(caller), caller); } (3)运用.class的方式获取Class实例，对于基本数据类型的封装类，还可以采用TYPE来获取对应的基本数据类型的Class实例 综上所述，其实我们代码中创建的每一个类都是一个对象，只不过她是Class类的实例对象，这个对象我们称为该类的类类型。并且一个类只可能是Class类的一个实例对象，即获取的类类型是相同的 那么，如何去创建Class的实例呢？首先，过程要理解，源文件经过编译（javac.exe）以后，得到一个或多个.class文件。.class文件经过运行（java.exe）这步，就需要进行类的加载（通过JVM的类的加载器），记载到内存中的缓存。每一个放入缓存中的.class文件就是一个Class的实例！下面是创建Class实例的三种方法。 实例如下： public class ReflectTest { public void display(){ System.out.println(\"Hello World!\"); } public static void main(String[] args){ ReflectTest reflectTest = new ReflectTest(); Class clazz1 = reflectTest.getClass(); Class clazz2 = ReflectTest.class; Class clazz3 = null; try { clazz3 = Class.forName(\"com.william.test.ReflectTest\"); } catch (ClassNotFoundException e) { e.printStackTrace(); } System.out.println(clazz1==clazz2); System.out.println(clazz1==clazz3); System.out.println(clazz2==clazz3); } } output: true true true 其实，还有一种创建Class实例的方法，是通过类的加载器，如下： @Test public void LoadClassTest(){ ClassLoader loader = this.getClass().getClassLoader(); Class clazz4 = null; try { clazz4 = loader.loadClass(\"com.william.test.ReflectTest\"); } catch (ClassNotFoundException e) { e.printStackTrace(); } System.out.println(clazz4); } output: class com.william.test.ReflectTest 如何根据类类型去创建类的实例呢？ //通过类的类型创建该类的实例对象 ReflectTest reflectTest1 = null; try { reflectTest1 = (ReflectTest) clazz1.newInstance();//需要类有无参的构造方法 } catch (InstantiationException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } reflectTest.display(); output: Hello World! 动态加载类Class.forName(&quot;类的全称&quot;) 表示类的类类型，还代表了动态加载类 区分上面所说的编译，运行 编译时刻加载类是静态加载类，运行时刻加载类是动态加载类关于动态加载类的实例代码请参考：http://www.imooc.com/video/3733 java获取方法信息 /** *打印类的信息，包括类的成员函数，成员变量 */ public class ClassUtil { /** * 获取成员函数 * object 该对象所属类的信息 * * @param object */ public static void printMethodMessage(Object object) { //要获取类的信息，首先要获取类的类类型 Class clazz = object.getClass();//传递的是哪个子类的对象， clazz就是该子类的类类型 //获取类的名称 System.out.println(\"类的名称是：\" + clazz.getName()); /** * Method类，方法对象 * 一个成员方法就是一个Method对象 * getMethods()方法获取的是所有的public的函数，包括父类继承而来的 * getDeclaredMethods()获取的是所有该类自己声明的方法，不问访问权限 */ Method[] methods = clazz.getDeclaredMethods(); for (int i = 0; i &lt; methods.length; i++) { //1. 获取注解 Annotation[] ann = methods[i].getAnnotations(); for (Annotation a : ann) { System.out.println(a); } //2. 获取权限修饰符 String str = Modifier.toString(methods[i].getModifiers()); System.out.print(str + \" \"); //3. 得到方法的返回值类型的类类型 Class returnType = methods[i].getReturnType(); System.out.print(returnType.getName() + \" \"); //4. 得到方法的名称 System.out.print(methods[i].getName() + \"(\"); //5.获取参数类型-->得到的是参数列表的类型的类类型 Class[] paramTypes = methods[i].getParameterTypes(); //解析数组 for (int j = 0; j &lt; paramTypes.length; j++) { if (j == 1 || j == paramTypes.length - 1) { System.out.print(paramTypes[j].getName() + \" args\" + j); } else { System.out.print(paramTypes[j].getName() + \" args\" + j + \",\"); } } System.out.print(\")\"); //6.获取异常类型 Class[] exps = methods[i].getExceptionTypes(); if (exps.length != 0) { System.out.print(\" throws \"); } for (int k = 0; k &lt; exps.length; k++) { System.out.print(exps[k].getName() + \" \"); } System.out.println(); } } } class MethodTest { private String name; //注解类型在java之注解开发章节讲解过的 @MyAnnotation(wd = WeekDay.MON,id = 4) public int age; static String desc = \"这是一个人\"; public MethodTest() { } private MethodTest(String name, int age) { this.name = name; this.age = age; } @Deprecated public void print(int a, int b) throws Exception { System.out.println(a + b); } public void print(String a, String b) { System.out.println(a.toUpperCase() + \",\" + b.toLowerCase()); } @Override public String toString() { return \"MethodTest{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } //调用 MethodTest methodTest = new MethodTest(); ClassUtil.printMethodMessage(methodTest); output: 类的名称是：com.william.test.MethodTest public java.lang.String toString() @java.lang.Deprecated() public void print(int args0,int args1) throws java.lang.Exception public void print(java.lang.String args0,java.lang.String args1) 获取方法的信息，主要通过Method类数组来接受getMethods()方法的返回值，然后进行遍历解析。 获取成员变量信息获取成员变量的信息，同获取方法的信息类似，只不过使用Field类数组来接收getFieldss()方法的返回值，然后进行解析。代码如下： /** * 获取成员变量 */ public static void printFieldMessage(Object object) { //要获取类的信息，首先要获取类的类类型 Class clazz = object.getClass();//传递的是哪个子类的对象， clazz就是该子类的类类型 //获取类的名称 System.out.println(\"类的名称是：\" + clazz.getName()); /** * 成员变量也是对象 * java.lang.reflect.Field * Field类封装了关于成员变量的操作 * getFields()方法获取的是所有的public的成员变量的信息 * getDeclaredFields获取的是该类自己声明的成员变量的信息 */ Field[] fields = clazz.getDeclaredFields(); for (Field field : fields) { //获取每个属性的权限修饰符 int i = field.getModifiers(); String str = Modifier.toString(i); //得到成员变量的类型的类类型 Class fieldType = field.getType(); String typeName = fieldType.getName(); //得到成员变量的名称 String fieldName = field.getName(); System.out.println(str + \" \"+ typeName + \" \" + fieldName); } } //调用 String str = \"Hello World!\"; ClassUtil.printFieldMessage(str); output: 类的名称是：java.lang.String 类的名称是：java.lang.String private final [C value private int hash private static final long serialVersionUID 获取构造函数 /** * 获取对象的构造函数的信息 * * @param object */ public static void printConMessage(Object object) { //要获取类的信息，首先要获取类的类类型 Class clazz = object.getClass();//传递的是哪个子类的对象， clazz就是该子类的类类型 //获取类的名称 System.out.println(\"类的名称是：\" + clazz.getName()); /** * 构造函数也是对象 * java.lang.Constructor中封装了构造函数的信息 * getConstructors获取所有的public的构造函数 * getDeclaredConstructors得到所有的构造函数 */ Constructor[] constructors = clazz.getConstructors(); for (Constructor constructor : constructors) { System.out.print(constructor.getName() + \"(\"); //获取构造函数的参数列表--->得到的是参数列表的类类型 Class[] paramTypes = constructor.getParameterTypes(); for (Class clazz1 : paramTypes) { System.out.print(clazz1.getName() + \",\"); } System.out.println(\")\"); } } //调用 String str = \"Hello World!\"; ClassUtil.printConMessage(str); output: 类的名称是：java.lang.String java.lang.String([B,int,int,) java.lang.String([B,java.nio.charset.Charset,) java.lang.String([B,java.lang.String,) java.lang.String([B,int,int,java.nio.charset.Charset,) java.lang.String([B,int,int,java.lang.String,) java.lang.String(java.lang.StringBuilder,) java.lang.String(java.lang.StringBuffer,) 二. 方法的反射 方法的反射1） 如何获取某个方法 方法的名称和方法的参数里列表才能唯一决定某个方法2） 方法反射的操作 method.invoke(对象，参数里列表)示例代码： public class MethodReflect { public static void main(String[] args){ //要获取print(int,int)方法 1. 要获取一个方法就是获取类的信息，获取类的信息首先要获取类的类类型 MethodTest methodTest = new MethodTest(); Class clazz = methodTest.getClass(); try { //Method method = clazz.getMethod(\"print\",new Class[]{int.class,int.class}); Method method = clazz.getMethod(\"print\",int.class,int.class); //以前的方法的方法调用 //methodTest.print(10,20); //方法的反射操作 //方法如果没有返回值返回null，有返回值返回具体的返回值 //method.invoke(methodTest,new Object[]{10,20}); Object o = method.invoke(methodTest,10,20); System.out.println(\"============================\"); //获取方法print（String，String） Method method1 = clazz.getMethod(\"print\",String.class,String.class); //用方法进行反射操作 o = method1.invoke(methodTest,\"hello\",\"WORLD!\"); } catch (Exception e) { e.printStackTrace(); } } } class MethodTest { private String name; public int age; static String desc = \"这是一个人\"; public MethodTest() { } private MethodTest(String name, int age) { this.name = name; this.age = age; } public void print(int a, int b) { System.out.println(a + b); } public void print(String a, String b) { System.out.println(a.toUpperCase() + \",\" + b.toLowerCase()); } @Override public String toString() { return \"MethodTest{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } } output: 30 ============================ HELLO,world! 三. 成员变量的反射实例如下： //成员变量的反射 Class clazz1; try { clazz1 = Class.forName(\"com.william.test.MethodTest\"); Object object = clazz1.newInstance(); MethodTest methodTest1 = (MethodTest) object; //调用private属性 Field field1 = clazz1.getDeclaredField(\"name\"); field1.setAccessible(true); field1.set(methodTest1,\"william\"); System.out.println(methodTest1.toString()); //调用public的属性 Field field2 = clazz1.getField(\"age\"); field2.set(methodTest1,9); System.out.println(methodTest1.toString()); //调用static属性 Field field3 = clazz1.getDeclaredField(\"desc\"); System.out.println(field3.get(MethodTest.desc)); //System.out.println(field3.get(null)); } catch (Exception e) { e.printStackTrace(); } output: MethodTest{name='william', age=0} MethodTest{name='william', age=9} 这是一个人 四. 构造函数的反射实例如下： //构造函数的反射 Class clazz3 = MethodTest.class; try { Constructor constructor = clazz3.getDeclaredConstructor(String.class,int.class); constructor.setAccessible(true); MethodTest methodTest2 = (MethodTest) constructor.newInstance(\"will\",99); System.out.println(methodTest2.toString()); } catch (Exception e) { e.printStackTrace(); } output: MethodTest{name='will', age=99} 五. 认识泛型的本质先来看一个实例： public class FanXingTest { public static void main(String[] args) { ArrayList list = new ArrayList(); ArrayList&lt;String> list1 = new ArrayList&lt;String>(); list1.add(\"hello\"); //list1.add(20);编译错误 Class c1 = list.getClass(); Class c2 = list1.getClass(); System.out.println(c1 == c2); //反射的操作都是编译之后的操作 try { Method m = c2.getMethod(\"add\",Object.class); m.invoke(list1,20);//绕过编译操作就绕过了泛型 System.out.println(list1.size()); System.out.println(list1); } catch (Exception e) { e.printStackTrace(); } } } output: true 2 [hello, 20] 通过返回结果，我们可以看到在编译之后集合的泛型是去泛型化的，java中集合类型的泛型，是防止错误输入的，只在编译阶段有效，绕过编译就无效了，所以我们通过方法的反射来操作，可以绕过编译。 六. 反射应用之动态代理动态代理是指客户通过代理类来调用其他对象的方法，并且是在程序运行时根据需要动态创建目标类的代理对象。实例代码： //动态代理的使用 interface Subject { void action(); } //被代理类 class RealSubject implements Subject { @Override public void action() { System.out.println(\"我是被代理类，记得要执行我奥，么么~~~\"); } } class MyInvocationHandler implements InvocationHandler { Object object;//实现了接口的被代理类的对象的声明 //①给被代理的对象实例化 ②返回一个代理类的对象 public Object blind(Object object) { this.object = object; return Proxy.newProxyInstance(object.getClass().getClassLoader(), object.getClass().getInterfaces(), this); } //当通过代理类的对象发起对被重写的方法的调用时，都会转化为对如下的invoke方法的调用 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { //method方法的返回值是returnVal Object returnVal = method.invoke(object,args); return returnVal; } } public class ProxyTest { public static void main(String[] args){ //1. 创建被代理类对象 RealSubject realSubject = new RealSubject(); //2. 创建一个实现了InvocationHandler接口的类的对象 MyInvocationHandler handler = new MyInvocationHandler(); //3. 调用blind()方法，冬天的返回一个同样实现了real所在类实现的接口Subject的代理类的对象。 Object object = handler.blind(realSubject); Subject subject = (Subject) object;//此时sub就是代理类的对象 subject.action();//转到对InvacationHandler接口的实现类的invoke()方法的调用 } } output: 我是被代理类，记得要执行我奥，么么~~~ 说明，了解动态代理和静态代理的区别，所谓的静态代理，其代理类和目标对象的类在编译期间就确定下来，不利于程序的扩展。即，每一个代理类只能为一个接口服务，也就是说程序开发中会产生很多代理类。 七. 动态代理与AOP由：转换为： 实例： interface Human { void info(); void fly(); } class SuperMan implements Human { @Override public void info() { System.out.println(\"我是超人！\"); } @Override public void fly() { System.out.println(\"I believe I can fly!\"); } } class HumanUtil { public void method1() { System.out.println(\"=============方法一============\"); } public void method2() { System.out.println(\"=============方法二============\"); } } class MyInvocationHandler implements InvocationHandler { Object object;//被代理类对象的声明 public void setObject(Object object) { this.object = object; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { HumanUtil h = new HumanUtil(); h.method1(); Object returnVal = method.invoke(object, args); h.method2(); return returnVal; } } //动态的创建一个代理类的对象 class MyProxy { public static Object getProxyInstance(Object object) { MyInvocationHandler handler = new MyInvocationHandler(); handler.setObject(object); return Proxy.newProxyInstance(object.getClass().getClassLoader(), object.getClass().getInterfaces(), handler); } } public class TestAOP { public static void main(String[] args){ SuperMan man = new SuperMan();//创建一个被代理类的对象 Human human = (Human) MyProxy.getProxyInstance(man);//返回一个代理类的对象 human.info();//通过代理类的对象嗲用重写的抽象的方法 System.out.println(); human.fly(); } } output: =============方法一============ 我是超人！ =============方法二============ =============方法一============ I believe I can fly! =============方法二============ AOP代理的方法： 相关概念 什么是编译？ 答：将原程序翻译成计算机语言，就是二进制代码，在java中是将.java文件也就是源程序翻译成.class的字节码 什么是编译时？ 答：将原程序翻译成计算机语言的过程中，将.java翻译为.class文件的过程 什么是运行时？ 答：就是在启动这个程序的时候，在java中是,类加载器加载.class文件，并交给jvm处理 什么是编译型语言？ 答：将原程序一次性全部转换为二进制代码，然后执行程序 什么是解释型语言？ 答：转换一句，执行一句，java是既编译又解释的语言 编译型语言和解释型语言的区别： 答：编译型语言效率高，依赖于编译器，但是跨平台差，解释型的效率低，依赖于解释器，但跨平台强 什么是类加载器？ 答：类加载器就是JVM中的类装载器，作用就是将编译好的.class字节码运到检查器进行安全检查的，检查通过后开始解释执行 什么是运行时动态加载类？ 答：反射就是可以将一个程序（类）在运行的时候获得该程序（类）的信息的机制，也就是获得在编译期不可能获得的类的信息，因为这些信息是保存在Class对象中的，而这个Class对象是在程序运行时动态加载的它就是可以在程序运行的时候动态装载类，查看类的信息，生成对象，或操作生成对象。类在运行的时候，可以得到该类的信息，并且 可以动态的修改这些信息，自己能看到自己，跟照镜子一样，class对象是在运行的时候产生的，通过class对象操作类的信息是在运行时进行的，当运行 程序的时候，类加载器会加载真正需要的类，什么是真正需要的呢？就是该类真正起作用，如：有该类的对象实例，或该类调用了静态方法属性等","categories":[{"name":"后端","slug":"后端","permalink":"http://blog.willhappy.cn/categories/后端/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.willhappy.cn/tags/java/"},{"name":"提升","slug":"提升","permalink":"http://blog.willhappy.cn/tags/提升/"},{"name":"Reflect","slug":"Reflect","permalink":"http://blog.willhappy.cn/tags/Reflect/"}]},{"title":"java多线程开发应用","slug":"10_2017-01-01_java多线程","date":"2017-01-01T00:00:00.000Z","updated":"2024-06-01T13:17:35.408Z","comments":true,"path":"2017/01/01/10-2017-01-01-java-duo-xian-cheng/","link":"","permalink":"http://blog.willhappy.cn/2017/01/01/10-2017-01-01-java-duo-xian-cheng/","excerpt":"在之前的博客 java提升2相关章节/) 介绍了关于多线程的基础知识，可以翻阅查看，本章节深入了解一下多线程的应用。","text":"在之前的博客 java提升2相关章节/) 介绍了关于多线程的基础知识，可以翻阅查看，本章节深入了解一下多线程的应用。 [toc] 一. 线程安全对于线程安全问题，首先举个例子： //窗口售票问题 class MyThreadDemo implements Runnable { int ticket = 100; @Override public void run() { while (true){ if (ticket>0) { try { Thread.currentThread().sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName()+\"售票，票号为：\"+ticket--); }else{ break; } } } } public class ThreadTest { public static void main(String[] args){ MyThreadDemo m = new MyThreadDemo(); Thread t1 = new Thread(m); Thread t2 = new Thread(m); Thread t3 = new Thread(m); t1.start(); t2.start(); t3.start(); } } 问题描述：上面的多线程售票出现了一下错误现象重票： 错票： 首先，我们分析一下为什么出现这种问题呢？我们所期望的理想状态为： 但是，会出现一个极端状态： 这是由于一个线程在操作共享数据过程中，未执行完毕的情况下，例外的线程参与进来，导致了共享数据存在了安全问题，本实例的共享数据为ticket。 那么，如何处理程序的线程安全问题呢？必须让一个线程操作共享数据完毕以后，其它线程才有机会参与共享数据的操作。 原理我们也理解了，那java如何去实现线程的安全呢？使用线程的同步机制实现方式有两种： 同步代码块 synchronized(同步监视器){//需要被同步的代码块（即操作共享数据的代码）} 共享数据：多个线程共同操作的同一个数据（变量） 同步监视器：由任何一个类的对象来充当，哪个线程获取此监视器，谁就执行大括号里被同步的代码。俗称：锁。 代码实现： class MyThreadDemo implements Runnable { int ticket = 100; Object object = new Object(); @Override public void run() { //Object object = new Object();//不行，由成员变量变为局部变量，每创建一个线程，都会创建一个对象 while (true){ synchronized (object){//同步监视器（锁）可以由任何一个类的对象来充当，也可以使用this，表示当前对象，只new了一次。但是在继承的方式中，一定要注意使用this，可能创建了多个线程对象，要求是多个线程使用同一个锁，即使用同一个对象。 if (ticket>0) { try { Thread.currentThread().sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName()+\"售票，票号为：\"+ticket--); }else{ break; } } } } } 同步方法 同步的方法实现在java提升2相关章节/)已经给出，可以前去查看。 它是将操作共享数据的方法声明为synchronized,即此方法为同步方法，能够保证当其中一个线程执行此方法时，其它线程在外等待直至此线程执行完此方法。 那么同步方法有没有锁呢，答案是有的，锁为this。但是同样要注意，在使用继承创建的线程的方式中，同样要慎用同步方法的方式，因为它的锁为this。必须保证多个线程共用一把锁。 使用锁的方式（了解） 二. 互斥锁之单例模式之懒汉式的线程安全问题互斥锁指的是一次最多只能有一个线程持有的锁. 在jdk1.5之前, 我们通常使用synchronized机制控制多个线程对共享资源的访问. 关键字synchronized来与对象的互斥锁联系。当某个对象用synchronized修饰时，表明该对象在任一时刻只能由一个线程访问。 同步的局限性：导致程序的执行效率要降低 同步方法（非静态的）的锁为this。 同步方法（静态的）的锁为当前类本身。 单例模式懒汉式实现： class Singleton { private Singleton() { } private static Singleton instance = null; public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } public class TestSingleton { public static void main(String[] args) { Singleton s1 = Singleton.getInstance(); Singleton s2 = Singleton.getInstance(); System.out.println(s1 == s2); } } output: true 会出现线程安全问题,多个线程同时执行时，第一个线程调用getInstance()进入if语句内,还未实例化，出现线程挂起，后面的线程也会进入会再创建一个对象，最终导致可能返回了不同Singleton对象。 解决线程安全问题实现： public static Singleton getInstance() { //如果第一个线程获取了单例的实例对象，后面的线程再获取实例的时候就不需要进入同步代码块了 if (instance == null) {//多线程执行时，会先判断对象是否为null，如果为null，直接返回，无需等待进去同步代码块线程执行完毕，然后再去执行，提高了效率 synchronized (Singleton.class) {//对于静态方法，使用但钱勒本身充当锁 if (instance == null) { instance = new Singleton(); } } } return instance; } 综上，用这种方式解决了懒汉式的线程安全问题，也提高了效率，但是在实际开发中还是用饿汉式的比较多，因为这种方式，相对复杂，不适合应用。 三. 线程的死锁问题死锁,是指不同的线程分别占用对方需要的同步资源不放弃，都再等待对方放弃自己需要的同步资源，就形成了线程的死锁。 死锁的实例： public class TestDeadLock { static StringBuffer sb1 = new StringBuffer(); static StringBuffer sb2 = new StringBuffer(); public static void main(String[] args){ new Thread(){ public void run(){ synchronized (sb1){ try { Thread.currentThread().sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } sb1.append(\"A\"); synchronized (sb2){ sb2.append(\"B\"); System.out.println(sb1); System.out.println(sb2); } } } }.start(); new Thread(){ public void run(){ synchronized (sb2){ sb1.append(\"C\"); synchronized (sb1){ sb2.append(\"D\"); System.out.println(sb1); System.out.println(sb2); } } } }.start(); } } 四. 线程通信 三个方法 wait(): 令当前线程挂起并放弃CPU，同步资源，使别的线程可访问并修改共享资源，而当前线程排队等候再次对资源的访问 notify()： 唤醒正在排队等待同步资源的线程中优先级最高者结束等待 notifyAll(): 唤醒正在排队等待资源的所有线程结束等待。 注：Java.lang.Object提供的这三个方法只有再synchronized方法或synchronized代码块中才能使用，否则会报java.lang.lllegalMonitorStateException异常。 实例： /** * 线程通信 * 使用两个线程打印1-100，线程1，线程2，交替打印 */ class PrintNum implements Runnable { int num = 1; @Override public void run() { while (true) { synchronized (this){ notify(); if (num &lt;= 100) { try { Thread.currentThread().sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \":\" + num); num++; } else { break; } try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } } } public class TestCommunication { public static void main(String[] args) { PrintNum p = new PrintNum(); Thread t1 = new Thread(p); Thread t2 = new Thread(p); t1.setName(\"甲\"); t2.setName(\"乙\"); t1.start(); t2.start(); } } output: 甲:1 乙:2 甲:3 乙:4 甲:5 乙:6 ... 甲:97 乙:98 甲:99 乙:100 关于多线程的相关知识，暂时先到这，后续有学习的内容，会持续更新，喜欢的，加个关注白////呲牙。","categories":[{"name":"后端","slug":"后端","permalink":"http://blog.willhappy.cn/categories/后端/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.willhappy.cn/tags/java/"},{"name":"提升","slug":"提升","permalink":"http://blog.willhappy.cn/tags/提升/"},{"name":"Thread","slug":"Thread","permalink":"http://blog.willhappy.cn/tags/Thread/"}]},{"title":"java之注解开发应用","slug":"9_2016-12-31_java之注解开发","date":"2016-12-31T00:00:00.000Z","updated":"2024-06-01T13:17:35.408Z","comments":true,"path":"2016/12/31/9-2016-12-31-java-zhi-zhu-jie-kai-fa/","link":"","permalink":"http://blog.willhappy.cn/2016/12/31/9-2016-12-31-java-zhi-zhu-jie-kai-fa/","excerpt":"","text":"[toc] 一. 注解概念知识注解（Annotation）,也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释,这些信息被保存在Annotation的”name=value”对中。 二. 基本的Annotation使用Annotation时要在其前面加上@符号，并把该Annotation当成一个修饰符使用，用于修饰它支持的程序元素。 三个基本的Annotation： @Override:限定重写父类方法，该注释只能用于方法 @Deprecated：用于表示某个程序元素（类，方法等）已过时 @SupperessWarnings: 抑制编译器警告 三. 元注解JDK的元注解是用来修饰其他Annotation定义。JDK1.5提供了专门在注解上的注解类型，分别为以下四种： @Retention @Target @Documented @Inherited 分别来说明以下：@Retention,只能用于修饰一个Annotation定义，用于指定该Annotation可以保留多长时间，@Retention包含了一个RetentionPolicy类型的成员变量，使用@Rentention时必须为该value成员变量指定值： RetentionPolicy.SOURCE: 编译器直接丢弃这种策略的注释 RetentionPolicy.ClASS： 编译器将把注释记录在class文件中，当运行java程序时，JVM不会保留注解，这是默认值。 RetentionPolicy.RUNTIME: 编译器将把注释记录在class文件中，当运行java程序时，JVM会保留注释，程序可以通过反射获取该注释 @Target,用于修饰Annotation定义，用于指定被修饰的Annotation能用于修饰哪些程序元素。@Target也包含一个名为Value的成员变量。@Target说明了Annotation所修饰的对象范围：Annotation可被用于 packages、types（类、接口、枚举、Annotation类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。在Annotation类型的声明中使用了target可更加明晰其修饰的目标。取值（ElementType）有：1.CONSTRUCTOR:用于描述构造器2.FIELD:用于描述域3.LOCAL_VARIABLE:用于描述局部变量4.METHOD:用于描述方法5.PACKAGE:用于描述包6.PARAMETER:用于描述参数7.TYPE:用于描述类、接口(包括注解类型) 或enum声明 @Documented,用于指定被该元Annotation修饰的Annotation类将被javadoc工具提取成文档。定义为Documented的注解必须设置Retention值为RUNTIME。 @Inherited，被它修饰的Annotation将具有继承性，如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解（实际应用中，使用较少）。 四. 自定义注解使用@interface自定义注解，会自动继承java.lang.annotation.Annotation接口，由编译程序自动完成其他细节。在定义注解时，不能继承其他的注解或接口。@interface用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型（返回值只能是基本类型、Class、String、enum）,可以通过default来声明参数的默认值。 定义注解格式： public @interface 注解名{定义体} 实例代码： @Target(ElementType.FIELD)//作用范围在属性上 @Retention(RetentionPolicy.RUNTIME) @Documented public @interface MyAnnotation { public enum WeekDay{SUN,MON,TUE,WED,THU,FRI,SAT}; WeekDay wd() default WeekDay.SUN; public int id() default -1; public String name() default \"\"; } 自定义注释的使用： @MyAnnotation(wd = WeekDay.MON) public int age; 注解元素默认值：注解元素必须有确定的值，要么在定义注解的默认值中指定，要么在使用注解时指定，非基本类型的注解元素的值不可为null。因此, 使用空字符串或0作为默认值是一种常用的做法。这个约束使得处理器很难表现一个元素的存在或缺失的状态，因为每个注解的声明中，所有元素都存在，并且都具有相应的值，为了绕开这个约束，我们只能定义一些特殊的值，例如空字符串或者负数，一次表示某个元素不存在，在定义注解时，这已经成为一个习惯用法。如果在定义注解中没有指定默认值，或者在使用时，没有指定值，会报以下错误： 关于注解的更过知识，请查看博客：http://www.cnblogs.com/peida/archive/2013/04/24/3036689.html博主写的狠详细，也很好，采摘了博主部分内容，望博主见谅，也帮他宣传下，知识共享。。。 上面博主的一张脑图，很好，分享一下：","categories":[{"name":"后端","slug":"后端","permalink":"http://blog.willhappy.cn/categories/后端/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.willhappy.cn/tags/java/"},{"name":"提升","slug":"提升","permalink":"http://blog.willhappy.cn/tags/提升/"},{"name":"Annotation","slug":"Annotation","permalink":"http://blog.willhappy.cn/tags/Annotation/"}]},{"title":"java之枚举类型应用","slug":"8_2016-12-30_java之枚举类型","date":"2016-12-30T00:00:00.000Z","updated":"2024-06-01T13:17:35.408Z","comments":true,"path":"2016/12/30/8-2016-12-30-java-zhi-mei-ju-lei-xing/","link":"","permalink":"http://blog.willhappy.cn/2016/12/30/8-2016-12-30-java-zhi-mei-ju-lei-xing/","excerpt":"","text":"[toc] 一. 前言 为什么使用枚举类型？ 在此之前，我们需要创建一个整形常量集，但是这些整型常量集并不会必然地将其自身的取值限制在这个常量集的范围之内，因此他们更有风险，且更难以使用。但是，枚举类型消除了这一缺陷，显得更加使用，下面实例说明。 使用public final static的方法定义如下常量集： public class WeekDay{ public static final int SUN = 1; public static final int MON = 2; public static final int TUE = 3; } 通过下面的方法，传入不同类型的参数： private static String getToday(int weekDay){ switch (weekDay){ case ConstantTest.MON: System.out.println(\"MON\"); break; case ConstantTest.SUN: System.out.println(\"SUN\"); break; case ConstantTest.TUE: System.out.println(\"TUE\"); break; } return null; } //调用上面的方法 getToday(ConstantTest.MON);//正常的场景 getToday(5);//错误的场景，产生类型不安全的问题，因为取值没有在常量集范围之内 通过上面的方法，getToday(5)传入的参数，虽然编译时通过，但是在运行时出现什么情况，我们就不得而知了，但是这显然是不符合java程序的类型安全。 二. 枚举定义枚举类型是指由一组固定的常量组成合法的类型，定义方法如下： public enum WeekDay{ SUN, MON, TUE, WED, THT, FRI, SAT } 在创建enum时，编译器会自动添加一些有用的特性，他会创建toString()方法，以便你可以方便的显示某个enum实例的名字，编译器还会创建ordinal()方法，用来表示某个特定enum常量的声明顺序，以及static values()方法，用来按照enum常量的声明顺序，产生由这些常量值构成的数组： for (WeekDay wd : WeekDay.values()) { System.out.println(wd + \",ordinal\" + wd.ordinal()); } output: SUN,ordinal：0 MON,ordinal：1 TUE,ordinal：2 WED,ordinal：3 THT,ordinal：4 FRI,ordinal：5 SAT,ordinal：6 改写上面的例子： //定义枚举 public enum WeekDay { SUN, MON, TUE, WED, THT, FRI, SAT } private static String getToday(WeekDay weekDay){ switch (weekDay){ case MON: System.out.println(\"MON\"); break; case SUN: System.out.println(\"SUN\"); break; case TUE: System.out.println(\"TUE\"); break; } return null; } public static void main(String[] args){ getToday(WeekDay.MON);//正常的场景 //getToday(5);//编译时出错，超出了enum的类型范围。 } 三. 枚举的用法 常量定义 public enum WeekDay { SUN, MON, TUE, WED, THT, FRI, SAT } switch public enum WeekDay { SUN, MON, TUE, WED, THT, FRI, SAT } public class SelectDay{ WeekDay weekday = WeekDay.SUN; public void select(){ switch(weekday){ case SUN: weekday = WeekDay.SUN; bread; ... } } } 向枚举中添加新方法 public enum Color { RED(\"红色\", 1), GREEN(\"绿色\", 2), BLANK(\"白色\", 3), YELLO(\"黄色\", 4); // 成员变量 private String name; private int index; // 构造方法 private Color(String name, int index) { this.name = name; this.index = index; } // 普通方法 public static String getName(int index) { for (Color c : Color.values()) { if (c.getIndex() == index) { return c.name; } } return null; } // get set 方法 public String getName() { return name; } public void setName(String name) { this.name = name; } public int getIndex() { return index; } public void setIndex(int index) { this.index = index; } } 覆盖枚举的方法 public enum Color { RED(\"红色\", 1), GREEN(\"绿色\", 2), BLANK(\"白色\", 3), YELLO(\"黄色\", 4); // 成员变量 private String name; private int index; // 构造方法 private Color(String name, int index) { this.name = name; this.index = index; } //覆盖方法 @Override public String toString() { return this.index+\"_\"+this.name; } } 实现接口 public interface Behaviour { void print(); String getInfo(); } public enum Color implements Behaviour{ RED(\"红色\", 1), GREEN(\"绿色\", 2), BLANK(\"白色\", 3), YELLO(\"黄色\", 4); // 成员变量 private String name; private int index; // 构造方法 private Color(String name, int index) { this.name = name; this.index = index; } //接口方法 @Override public String getInfo() { return this.name; } //接口方法 @Override public void print() { System.out.println(this.index+\":\"+this.name); } } 使用接口组织枚举 public interface Food { enum Coffee implements Food{ BLACK_COFFEE,DECAF_COFFEE,LATTE,CAPPUCCINO } enum Dessert implements Food{ FRUIT, CAKE, GELATO } } 实例参考至：http://www.imooc.com/article/3924","categories":[{"name":"后端","slug":"后端","permalink":"http://blog.willhappy.cn/categories/后端/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.willhappy.cn/tags/java/"},{"name":"提升","slug":"提升","permalink":"http://blog.willhappy.cn/tags/提升/"},{"name":"enum","slug":"enum","permalink":"http://blog.willhappy.cn/tags/enum/"}]},{"title":"Java之自动拆装箱及享元模式应用","slug":"7_2016-12-29_Java之自动拆装箱及享元模式应用（java004）","date":"2016-12-29T00:00:00.000Z","updated":"2024-06-01T13:17:35.408Z","comments":true,"path":"2016/12/29/7-2016-12-29-java-zhi-zi-dong-chai-zhuang-xiang-ji-xiang-yuan-mo-shi-ying-yong-java004/","link":"","permalink":"http://blog.willhappy.cn/2016/12/29/7-2016-12-29-java-zhi-zi-dong-chai-zhuang-xiang-ji-xiang-yuan-mo-shi-ying-yong-java004/","excerpt":"首先，来说一下关于编译器蜜糖（compiler suger）的问题，它给我们带来便利的同时，也埋下了一些陷阱，像foreach的增强，自动拆装箱等，本节一起来学习一下蜜糖之一的自动拆装箱机制。","text":"首先，来说一下关于编译器蜜糖（compiler suger）的问题，它给我们带来便利的同时，也埋下了一些陷阱，像foreach的增强，自动拆装箱等，本节一起来学习一下蜜糖之一的自动拆装箱机制。 [toc] 一. 静态导入 静态导入 import语句可以导入一个类或某个包中的所有类 import static语句导入一个类中的某个静态方法或所有静态方法 举例 import static java.lang.Math.max; import static java.lang.Math.*; 二. 可变参数 特点 只能出现在参数泪飙的最后； …位于变量类型和变量名之间，前后有无空格都可以； 调用可变参数的方法时，编译器为该可变参数隐含创建一个数组，在方法体中以数组的形式访问可变参数。 举例 public static int add(int x,int... args){ int sum = x; // for (int i = 0; i &lt; args.length; i++) { // sum = sum + args[i]; // } //使用for循环增强 for (int arg : args) { sum += arg; } return sum; } overload和override区别http://developer.51cto.com/art/201106/266705.htmhttp://www.cnblogs.com/whgw/archive/2011/10/01/2197083.html重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。很重要的一点就是，Overloaded的方法是可以改变返回值的类型。 三. 自动拆装箱及享元模式及其应用 前言介绍自动拆装箱前，要先理解基本数据类型（Primitive）和对象（Object）的相关概念，在java中，所要处理的东西几乎都是对象，但是基本数据类型不是对象，向我们使用的int、double、boolean、byte、long等等，而他们都对应了一个引用的类型，称为装箱基本类型，也称为包装类。 自动拆装箱装箱：根据数据创建对应的包装对象 Integer i = new Integer(3); Integer j = 4;//jdk1.5之后可以通过这种方式自动装箱 装箱：根据数据创建对应的包装对象 int index2 = j.intValue(); int index1 = i;//自动拆箱 而自动拆装箱的功能事实上是编译器帮的忙，编译器在编译时期依您所编写的语法，来决定是否进行拆装箱操作。 JDK1.5 为Integer 增加了一个全新的方法：public static Integer valueOf(int i) 在自动装箱过程时，编译器调用的是static Integer valueOf(int i)这个方法 于是:Integer a=3; ==&gt; Integer a=Integer.valueOf(3); 此方法与new Integer(i)的不同处在于:方法一调用类方法返回一个表示 指定的 int 值的 Integer 实例。方法二产生一个新的Integer 对象。 缓冲机制的原理关于自动拆装箱的缓冲机制原理的详细解释，看下面的blog，博主很解释的很给力勒！http://blog.csdn.net/u010293702/article/details/44621675还有其他的一些包装类详情，也可以关注这篇blog，下面举例举实例加深理解 举例 package com.william.test; /** * Created by william on 2016/12/25. */ public class AutoBoxTest { public static void main(String[] args){ Integer integer = 3;//数据装箱 //实际的操作为：Integer iObj = new Integer(3); System.out.println(integer+12);//自动拆箱做加法 String str1 = new String(\"abc\"); String str2 = new String(\"abc\"); String str4 = \"abc\"; String str5 = \"abc\"; Integer i1 = 120; Integer i2 = 120; Integer i3 = 130; Integer i4 = 130; System.out.println(\"str1==str2:\"+(str1==str2)); System.out.println(\"str4==str5:\"+(str4==str5));//串常量所生成的变量，其中所存放的内存地址是相等的 System.out.println(\"str1.equals(str2):\"+str1.equals(str2));//String中重写equals（）方法，比较其内容 System.out.println(\"str1.equals(str4):\"+str1.equals(str4)); System.out.println(\"i1==i2:\"+(i1==i2)); System.out.println(\"i3==i4:\"+(i3==i4));//至于i3==i4返回false的原因就是因为Integer的缓冲机制导致的 System.out.println(\"i3.equals(i4):\"+i3.equals(i4));//Integer中重写equals（）方法，使其比较其值，而不是用来比较两个引用变量是否指向同一个对象 } } output: 15 str1==str2:false str4==str5:true str1.equals(str2):true str1.equals(str4):true i1==i2:true i3==i4:false i3.equals(i4):true 对于上面用到的equals(),==另外还有像hashcode,instanceof,compareTo等比较方法的区别，感兴趣的可以自己查阅学习，这里只说一下equals()和==的区别。 “==”比较两个变量本身的值，即两个对象在内存中的首地址。 equals()在Object类中同样是用来比较‘地址’的，但是在String，Integer等包装类中重写了equals()方法，使其比较的是内容，这也就是上面的实例中，使用equals比较返回true的原因。 对于其详细解释：http://blog.csdn.net/t12x3456/article/details/7341515 享元模式与Integer类举个简单的例子：天天跟MM发短信，手指都累死了，最近买了个新手机，可以把一些常用的句子存在手机里，要用的时候，直接拿出来，在前面加上 MM的名字就可以发送了，再不用一个字一个字敲了。共享的句子就是Flyweight，MM的名字就是提取出来的外部特征，根据上下文情况使用。 这里说到的享元模式和Integer类，在上面的例子中，我们学习到了Integer会把常用的-128~127之间的数字在装箱后会被缓存起来，当下次对同样的数字装箱时，两个Interger对象是相等的，因为他们指向的是同一块内存，即是使用同一个对象，而不再这个范围中的数字，在自动装箱时，是不会被缓存的，即重新创建一个对象，所以当数字大于127时，他们用‘==’比较，返回的是false，即他们在内存中的首地址是不一样的。 通过以上所属，享元模式，是对于哪些非常小但又需要在系统的很多地方都需要到他的时候，我们可以把它缓存起来，以便在诗词再次使用，减少了创建对象的开销。 备注：感谢引用的以上各位博主的博客，让我学习到了很多。。。","categories":[{"name":"后端","slug":"后端","permalink":"http://blog.willhappy.cn/categories/后端/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.willhappy.cn/tags/java/"},{"name":"autoboxing","slug":"autoboxing","permalink":"http://blog.willhappy.cn/tags/autoboxing/"},{"name":"提升","slug":"提升","permalink":"http://blog.willhappy.cn/tags/提升/"}]},{"title":"Java提升2","slug":"6_2016-11-25_Java高级知识(java003)","date":"2016-11-25T00:00:00.000Z","updated":"2024-06-01T13:17:35.408Z","comments":true,"path":"2016/11/25/6-2016-11-25-java-gao-ji-zhi-shi-java003/","link":"","permalink":"http://blog.willhappy.cn/2016/11/25/6-2016-11-25-java-gao-ji-zhi-shi-java003/","excerpt":"","text":"[toc] 一. Java集合类详解 Connection接口 集合可以理解为一个动态的对象数组，不同的是集合中的对象内容可以任意扩充 集合的特点： 性能高 容易扩展和修改 Collection的常用子类 List Set Queue List接口 List接口可以存放任意的数据，而且在List接口中内容是可以重复的 List接口常用子类： ArrayList Vector 常用操作：判断集合是否为空：boolean isEmpty()查找指定的对象是否存在：int indexOf(Object o)|比较|ArrayList|Vector||-|-|-||推出时间|JDK1.2之后推出|JDK1.0推出||性能|采用异步处理方式，性能高|采用同步处理方式，性能低||线程安全|属于非线程安全|属于线程安全| Set接口 Set接口中不能加入重复元素，但是可以排序 Set接口常用子类 散列存放：HashSet 有序存放：TreeSet Iterator接口 集合输出的标准操作： 标准做法，使用Iterator接口 操作原理： Iterator是专门的迭代输出接口，迭代输出就是将元素一个个进行判断，判断其是否有内容，如果有内容则把内容取出。 Map接口 保存形式： Key—&gt;value的方式保存 常用子类： HashMap：无序存放，key不允许重复（非线程安全的） Hashtable：无序存放，key不允许重复（线程安全的） 二. Java中的IO操作 作用： IO也写作“I/O”，可理解为In和Out，即输入与输出。所以，IO体系的基本功能就是：读和写。 IO流 作用：读写设备上的数据，硬盘文件、内存、键盘、网络… 根据数据的走向，可分为：输入流、输出流 根据处理的数据类型，可分为：字节流、字符流 字节流和字符流 字节流可以处理所有类型的数据，如MP3，图片、文字、视频等。在读取时，读到一个字节就返回一个字节。 在java中对应的类都以“Stream”结尾。 字符流仅能处理纯文本数据，如txt文本等。在读取时，读到一个或者多个字节，先查找指定的编码表，然后将查到的字符返回。 在Java中对应的类都以“Reader”或“Writer” 结尾 字符、字节和编码 字节（Byte） 字节是通过网络传输信息或再硬盘或内存中存储信息的单位，是计算机信息技术用于计量存储容量和传输容量的一种计量单位。 1个字节等于8位二进制，即一个8位二进制数，是一个狠具体的存储空间。 如0x01,0x45,0xFA,… 字符（Char） 字符是人们使用的几号，抽象意义上的一个符号。 如’1’,’中’,’a’,’￥’,’$’,… 字符集（Charset） “字符集”也称为“编码”。 三者的区别，请看下表： 使用字节流读写数据 使用fileInputStream和fileOutputStream来进行文件的拷贝 public static void main(String[] args) { try { FileInputStream fileInputStream = new FileInputStream(\"Java01/text.txt\"); FileOutputStream fileOutputStream = new FileOutputStream(\"Java01/newText.txt\"); byte input[] = new byte[50]; while (fileInputStream.read(input) != -1) { fileOutputStream.write(input); } fileInputStream.close(); fileOutputStream.close(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } 使用带缓冲的字节流读写数据 public static void main(String[] args){ try { FileInputStream fileInputStream = new FileInputStream(\"Java01/text.txt\"); BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream,1000000);//设置缓冲区的大小 //大型文件对应的数组可以大一些，小文件对应的数组小一些 byte input[] = new byte[100000]; int count = 0; long before = System.currentTimeMillis(); //读取之前的时间 while (bufferedInputStream.read(input)!=-1){ count++; } bufferedInputStream.close(); fileInputStream.close(); System.out.println(System.currentTimeMillis()-before+\"ms\"); //读取之后和之前的差值 System.out.println(\"都去了\"+ count +\"次\"); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } 说明：通过多次调试缓冲区和字节数组的大小，来寻找文件读取效率最高的数据。 使用字符流读写数据同样是，进行文件拷贝，现在使用字符流来读写数据，实例如下： public static void main(String[] args) { try { FileInputStream fileInputStream = new FileInputStream(\"Java01/text.txt\"); FileOutputStream fileOutputStream = new FileOutputStream(\"Java01/newText.txt\"); InputStreamReader inputStreamReader = new InputStreamReader(fileInputStream, \"UTF-8\");//InputStreamReader使用指定的 charset 读取字节并将其解码为字符。 OutputStreamWriter outputStreamWriter = new OutputStreamWriter(fileOutputStream, \"UTF-8\"); char input[] = new char[100]; int l = 0; while ((l = inputStreamReader.read(input)) != -1) { outputStreamWriter.write(input, 0, l); //将字符读入数组中的某一部分。 } // while (inputStreamReader.read(input) != -1) { //读入数组的的字符会存在偏移，即多读出字符 // outputStreamWriter.write(input); // } outputStreamWriter.close(); inputStreamReader.close(); fileOutputStream.close(); fileInputStream.close(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } 使用带有缓冲的字符流读写数据 即添加BufferedReader和BufferedWriter，会出现一个问题，就是写入文件的时候会丢弃换行符，可使用PrintWriterPrintWriter实例化： PrintWriter pw = new PrintWriter(outputStreamWriter,true);//实例化并强制自动刷新缓冲区数据 FileReader与FileWriter 使用FileReader和FileWriter来读写一些纯文本文件，读写以字符为基准的文件。用法同上述几种文件读出方式类似，不做赘述。 RandomAccessFile随机文件读写 实例代码：MultiwriterFile.java package com.william.RandomAccessFileTest; import java.io.File; import java.io.FileNotFoundException; import java.io.IOException; import java.io.RandomAccessFile; /** * Created by william on 2016/11/25. */ public class MultiwriterFile { static File file = new File(\"Java01/text.txt\"); public static void main(String[] args) { // if (file.exists()) { // file.delete(); // } // new WriteFile(file,1).start(); // new WriteFile(file,2).start(); // new WriteFile(file,3).start(); // new WriteFile(file,4).start(); // new WriteFile(file,5).start(); try { RandomAccessFile randomAccessFile = new RandomAccessFile(file, \"r\"); randomAccessFile.seek(300); byte input[] = new byte[20]; randomAccessFile.read(input); String str = new String(input); System.out.print(str); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } } WriteFile.java package com.william.RandomAccessFileTest; import java.io.File; import java.io.FileNotFoundException; import java.io.IOException; import java.io.RandomAccessFile; /** * Created by william on 2016/11/25. */ public class WriteFile extends Thread { File file; int block; int L = 100; public WriteFile(File file, int block) { this.file = file; this.block = block; } /** * 文件随机读取示意图： * 1 2(100) 3 4(300) 5 * |-----------------|-----------------|-----------------|-----------------|-------- * 0xL&lt;-----100----->1xL */ public void run() { try { RandomAccessFile randomAccessFile = new RandomAccessFile(file, \"rw\"); randomAccessFile.seek((block - 1) * L); randomAccessFile.writeBytes(\"This is block\" + block); for (int i=0;i&lt;20;i++) { randomAccessFile.writeBytes(\"-\"); } randomAccessFile.writeBytes(\"\\n\"); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } } 执行写操作，输出结果： This is block1——————– This is block2——————– This is block3——————– This is block4——————– This is block5——————– 执行读操作输出结果：输出：输出20个字节长度 This is block4—— 使用Apache IO库操作IO与文件 对原始java对文件的操作做了封装，使用起来更加的方便，详细请看Apache的官方API文档。 三. Java多线程编程 线程与进程 线程： 程序中的单独顺序的控制流 新城本身依靠程序进行运行 线程是程序中的顺序控制流，只能使用分配给程序的资源和环境 进程： 执行中的程序 一个进程可以包含一个或多个线程 一个进程至少要包含一个线程 单线程： 程序中只存在一个线程，实际上主方法就是一个主线程 多线程： 多线程是在一个程序中运行多个任务 多线程的目的是更好的利用cpu资源 线程的实现 在java中，线程的实现有两种：①. 继承Thread类②. 实现Runnable接口 Thread类：Thread类是在java.lang包中定义的，继承Thread类必须重写run()方法定义格式： class className extends Thread{ run(){}; } 实例： public class MyThread extends Thread { private String name; public MyThread(String name) { this.name = name; } @Override public void run() { for (int i = 0; i &lt; 1000; i++) { System.out.println(name + \":\" + i); } super.run(); } } 说明：当在主方法中使用Start启动线程时，我们可以看到两个线程时并行执行的，即谁先拿到cpu的资源，谁就执行，并不是顺序执行的。 看部分输出结果： …B:25B:26B:27B:28B:29A:0B:30A:1A:2A:3… Runnable接口 实现Runnable接口中的run方法，与Thread的run方法一样，在主方法中调用时，如下调用： MyRunnable r = new MyRunnable(\"A\"); Thread t = new Thread(r); t.start(); 线程的状态 线程也有固定的操作状态： 创建状态：准备好了一个多线程的对象 就绪状态：调用了start()方法，等待cpu进行调度 运行状态：执行run()方法 阻塞状态：暂时停止执行，可能将资源交给其他线程使用 终止状态（死亡状态）：线程销毁 线程的常用方法 取得线程名称getName() 取得当前线程对象currentThread() 判断线程是否启动isAlive() 线程的强行运行join() 线程的休眠sleep() 礼让yield() 线程的优先级 优先级顺序设置： 1-MIN_PRIORITY 10-MAX_PRIORITY 5-NORM_PRIORITY如果什么都不设置默认值是5 同步与死锁 同步代码块在代码块上加上“synchronized”关键字，则此代码块就称为同步代码块 同步代码块格式：synachronized(同步对象){ 需要同步的代码块；} 同步方法除了代码块可以同步，方法也是可以同步的 方法同步格式：synchronized void 方法名称(){}同步实例： class MyThreadDemo implements Runnable { private int ticket = 5; public void run() { for (int i = 0; i &lt; 10; i++) { tell(); } } public synchronized void tell() { if (ticket > 0) { try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"车票：\" + ticket--); } } } public class synchronizedtest { public static void main(String[] args) { MyThreadDemo m = new MyThreadDemo(); Thread t1 = new Thread(m); Thread t2 = new Thread(m); Thread t3 = new Thread(m); t1.start(); t2.start(); t3.start(); } } 而死锁，就相当与两个人耍赖皮，比如说：张三有十块钱，李四有一本书，张三说，你先把书给我，我就给你钱，李四说你先给我钱，我就给你书，两个人互不想让，就会陷入等待，就会出现死锁的状况。 线程的生命周期不解释，上图： 四. Java中的HTTP通信 使用Http的Get方法读取网络数据 看下面博客吧，视频上讲的挺散，但是要感谢视频的老师，同时感谢博客的博主。：）http://blog.csdn.net/luckyzhoustar/article/details/50259209 使用Http的Post方式与网络交互通信 啥都不说了，还是博客文章：http://blog.csdn.net/thl331860203/article/details/51783434 使用HttpClient进行Get方式通信 使用Apache的HttpClient的jar包，具体的操作，自己网上查去吧，不像写了。 使用HttpClient进行Post方式通信 使用Apache的HttpClient的jar包，具体的操作，自己网上查去吧，不像写了。做参考吧：https://www.oschina.net/code/snippet_1591393_46723 五. Java中内部类，匿名内部类理解http://blog.csdn.net/zzjjiandan/article/details/9189943 一般来说，有4种内部类：常规内部类、静态内部类、局部内部类、匿名内部类。 常规内部类常规内部类和普通类最大的不同就是，它能访问(这里，访问的意思包括读和写)外部类的私有实例域。具体参考博客：http://blog.csdn.net/l294265421/article/details/46574009 静态内部类静态内部类和普通类的对比使用，讲的很好，感谢博主：http://kenby.iteye.com/blog/1603803 局部内部类 在局部内部类前不能用修饰符public和private,protected. 可以定义与外部类同名的变量 如果内部类没有与外部类同名的变量，在内部类中可以直接访问外部类的实例变量 如果内部类中有与外部类同名的变量，直接用变量名访问的是内部类的变量,用this.变量名访问的也是内部类变量. 用外部类名.this.内部类变量名访问的是外部类变量 不可以定义静态变量和方法 可以访问外部类的局部变量(即方法内的变量)，但是变量必须是final的 可以访问外部类的所有成员 实例：http://blog.csdn.net/l294265421/article/details/46583475 匿名内部类如果只需要创建一个内部类的一个对象，就没必要给这个类一个名字。这个没有名字的内部类叫做匿名内部类。实例：http://blog.csdn.net/l294265421/article/details/46583759 小插曲：关于类的实例化顺序 1.在实例化一个类的对象时，先要实例化该类的成员变量，再执行该类的构造函数。 在实例化一个类的成员变量时，先要实例化静态成员变量，再实例化非静态成员变量。 一个类的静态成员变量只实例化一次，即只有一个拷贝，在该类的所有对象中共享。 执行一个类的静态成员函数时，该类的对象并没有生成，因此，只会实例化该类的静态成员变量，而不会实例化非静态成员变量，也不会执行构造函数。 最好自己写一个小的实例，然后自己debugger一下，这样更容易理解上述的总结，可以用下面的小实例： class A{ private int a = 10; private static int AA = 100; public A(int a) { this.a = a; } public void printA(){ System.out.println(\"this is A\"); } public static void printText(){ System.out.println(\"come here!\"); } } public class newclasstest { public static void main(String[] args){ A.printText(); A a = new A(22); a.printA(); } }","categories":[{"name":"后端","slug":"后端","permalink":"http://blog.willhappy.cn/categories/后端/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.willhappy.cn/tags/java/"},{"name":"提升","slug":"提升","permalink":"http://blog.willhappy.cn/tags/提升/"}]},{"title":"Java提升1","slug":"5_2016-11-24_Java中级知识(java002)","date":"2016-11-24T00:00:00.000Z","updated":"2024-06-01T13:17:35.408Z","comments":true,"path":"2016/11/24/5-2016-11-24-java-zhong-ji-zhi-shi-java002/","link":"","permalink":"http://blog.willhappy.cn/2016/11/24/5-2016-11-24-java-zhong-ji-zhi-shi-java002/","excerpt":"","text":"[toc] 一.WebService入门 Java中的xml操作 XML和HTML区别 XML被设计为传输和存储数据，其焦点是数据的内容 HTML被设计用来显示数据，起焦点是数据的外观 HTML旨在显示信息，而XML旨在传输信息 使用java读取XML文件实例： public class ReadXML { public static void main(String[] args) { try { //dom解析xml文件 DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = factory.newDocumentBuilder(); Document document = builder.parse(new File(\"Java01/languages.xml\")); Element root = document.getDocumentElement(); System.out.println(\"cat=\" + root.getAttribute(\"cat\")); NodeList list = root.getElementsByTagName(\"lan\"); for (int i = 0; i &lt; list.getLength(); i++) { Element lan = (Element) list.item(i); System.out.println(\"===============\"); System.out.println(\"id=\" + lan.getAttribute(\"id\")); // Element name = (Element) lan.getElementsByTagName(\"name\").item(0); // System.out.println(\"name=\"+name.getTextContent()); NodeList cList = lan.getChildNodes(); for (int j = 0; j &lt; cList.getLength(); j++) { Node c = cList.item(j); if (c instanceof Element) { System.out.println(c.getNodeName() + \"=\" + c.getTextContent()); } } } } catch (ParserConfigurationException e) { e.printStackTrace(); } catch (SAXException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } } languages.xml文件： &lt;?xml version=\"1.0\" encoding=\"utf-8\" ?> &lt;languages cat=\"it\"> &lt;lan id=\"1\"> &lt;name>java&lt;/name> &lt;ide>IntelliJ IDEA&lt;/ide> &lt;/lan> &lt;lan id=\"2\"> &lt;name>swift&lt;/name> &lt;ide>Xcode&lt;/ide> &lt;/lan> &lt;lan id=\"3\"> &lt;name>C#&lt;/name> &lt;ide>Visual Studio&lt;/ide> &lt;/lan> &lt;/languages> 使用java创建xml数据 使用dom4j操作xml数据 java中的JSON操作 JSON数据格式简介 json是存储和交换文本信息的语法。 json是轻量级的文本数据交换格式 json独立于语言和平台 json具有自我描述性，更易理解 使用java读取json数据 使用gson的jar包来读取json 使用java创建json数据 二. Spring spring入门 a. 简介：spring是一个轻量级控制反转（ioc）和面向切面（aop）的容器框架，它主要是为了解解决企业应用开发的复杂性而诞生的 b. 优势： 它定位的领域是许多其他流行的framework没有的 spring是全面的和模块化的 他的设计从底部帮助你编写易于测试的代码 spring是潜在的一站式解决方案 c. 优点： 低侵入式设计，代码污染极低 write Once,Run Anywhere DI有效的降低了耦合度 AOP提供了通用任务的集中管理 ORM和DAO简化了对数据库访问 高度开放性，并不强制 spring之IOC a. 浅谈IOCIOC（Inversion of Control，控制反转）是spring的核心，贯穿始终。所谓IOC，对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系： 传统开发模式：对象之间互相依赖（像找对象，自己需要什么样的对象，按自己的标准去找，完全由自己来做，来筛选） IOC开发模式：IOC容器安排对象之间的依赖（像有一个婚姻介绍所，会收集所有的男女对象，你需要什么样的对象，只需要提交给他，他会帮你筛选，你只需要谈恋爱就行了，其他的交个婚介就可以了） b. IOC理论背景 c. IOC通俗的理解如下： IOC控制反转：说的是创建对象实例的控制权从代码控制剥离到IOC容器控制，实际就是你在xml文件控制，侧重原理 DI依赖注入：说的是创建对象实例时，为这个对象注入属性值或其他对象实例，侧重于实现。 ioc比如有一个类，在类里面有方法（不是静态的方法），调用类里面的方法，创建类的对象，使用对象调用方法，创建类对象的过程，需要new出来对象 把对象的创建不是通过new方式实现，而是交给spring配置创建类对象 spring之AOP a. AOP图解 面向切面的编程，扩展功能不是修改源代码实现 springIOC容器深入理解 a. IOC概念 b. Java反射机制 ClassLoader工作机制 装载：查找和导入Class文件 链接：执行校验，准备和解析步骤 初始化：对垒的静态变量、静态代码块执行初始化工作 c. 资源访问工具类d. BeanFactory和ApplicationContext的介绍e. Bean的生命周期 spring的配置文件 a. spring容器高层视图 spring容器启动基本条件： spring的框架类包 bean的配置文件 bean的实现类 bean的元数据信息： bean的实现类 bean的属性信息 bean的依赖关系 bean的行为配置 bean的创建方式 传智播客spring框架2016版 笔记记录 一. Spring概念（传智播客笔记） spring是开源的轻量级框架 spring核心主要两部分： aop：面向切面编程，扩展功能不是修改源代码实现 ioc：控制反转（1） 比如有一个类，在类里面有方法（不是静态的方法），调用类里面的方法，创建类的对象，使用对象调用方法，创建类对象的过程，需要new出来对象（2） 把对象的创建不是通过new方式实现，而是交个spring配置创建类对象 spring是一站式框架 spring在javaee三层结构中，每一层都提供不同的解决技术（1） web层：springMVC（2） service层：spring的ioc（3） dao层：spring的jdbcTemplate spring版本 hivernate5.x spring4.x 二. Spring的ioc操作 把对象的创建交给spring进行管理 ioc操作两部分： ioc的配置文件的方式 ioc的注解方式 ioc底层原理 xml配置文件 dom4J解决xml 工厂设计模式 java反射技术 ioc入门案例 导入jar包（1） 解压资料zip文件jar特点：都有三个jar包（2） 做spring最基本功能时候，导入四个核心的jar包就可以了（3） 导入支持日志输出的jar包 创建类，在类里面创建方法 创建spring配置文件，配置创建类（1） spring核心配置文件名称和位置不是固定的，建议放到src下面，官方建议applicationContext.xml（2） 引入schema约束（3） 配置对象的创建 写代码测试对象创建 三. Spring的bean管理（xml方式） bean实例化的方式 在spring里面通过配置文件创建对象 bean实例化三种方式实现（1） 使用类的无参数构造创建（重点）注：如果类里面没有无参数的构造，会出现异常（2） 使用静态工厂创建① 创建静态的方法，返回类对象（3） 使用实例工厂创建① 创建不是静态的方法，返回类对象 Bean标签常用属性 id属性：起名称，id属性值名称任意命名注：① id属性值，不能包含特殊符号② 根据id值得到配置对象 class属性：创建对象所在类的全路径 name属性：功能和id属性一样的，id属性值布恩那个包含特殊符号，但是在name属性值里面可以包含特殊符号，name属性为了解决strus1遗留的问题。 scope属性① singleton：默认值，单例的② prototype：多例的③ request：web项目中，spring创建一个bean的对象，将对象存入到session域中④ session：web项目中，spring创建一个bean对象，将对象存入到session域中⑤ globalSession：web项目中，应用到porlet环境，如果没有porlet环境那么globalSession相当于session。 属性的注入① 创建对象的时候，向类里面属性里面设置值② 属性注入的方式介绍（1） 使用set方法注入（2） 使用有参数构造注入（3） 使用接口注入③ 在spring框架里面，支持前两种方式 注入对象类型属性（重点）①. 创建service类和dao类（1） 在service中得到dao对象②. 具体过程实现（1） 在service里面把dao做为类型属性（2） 生成dao类型属性的set方法（3） 在配置文件中注入关系 P 名称空间的注入 注入复杂类型属性① 数组② list集合③ map集合④ properties类型 IOC和DI区别 IOC:控制反转，把对象创建交给spring进行配置 DI：依赖注入，向类里面的属性中设置值 关系：依赖注入不能单独存在，需要在ioc基础上完成操作 spring整合web项目原理 加载spring核心配置文件① new对象，功能可以实现，效率很低 实现思想：吧加载配置文件和创建对象过程，在服务器启动时候完成 实现原理① ServletContext对象② 监听器③ 具体使用：在服务器启动的时候，为每个项目创建一个ServletContext对象在servletContext对象创建时候，使用监听器可以具体盗ServletContext对象在什么时候创建使用监听器监听到ServletContext对象创建时候加载Spring配置文件，把配置文件配置对象创建把创建出来的对象放到ServletContext域对象里面（setAttribute方法）获取对象的时候，盗ServletContext域中得到（getAttribute方法） 四. Spring的bean管理（注解） 注解 代码里面特殊标记，使用注解可以完成功能 注解写法@注解名称（属性名称=属性值） 注解使用在类上面，方法上面和属性上面 spring注解开发准备 导入jar包（基本jar包和aop的jar包） 创建类，创建方法 创建spring配置文件，引入约束 开启注解扫描 &lt;!-- 注解扫描包 到包里面扫描类、方法和属性上面是否有注释 --> &lt;context:component-scan base-package=\"com.seeknovel\"/> &lt;!-- 扫描属性上面的注解 --> &lt;context:annotation-config>&lt;/context:annotation-config> 注解创建对象 在创建对象的类上面使用注解实现 创建对象有四个注解 创建对象单实例还是多实例 注解注入属性 创建service类，创建dao类，在service得到dao对象 五. AOP aop概述 aop:面向切面编程，扩展功能不修改源代码实现aop采取横向抽取机制，取代了传统纵向继承体系重复性代码 aop原理示意图如下： aop操作术语 Joinpoint(连接点)：所谓的连接点是指那些被拦截到的点。在spring中，这些点指的是方法，因为spring只支持方法类型的连接点。 Pointcut（切入点）：所谓的切入点是指我们要对哪些Joinpoint进行拦截的定义。 Advice（通知/增强）：所谓通知是指拦截到Joinpoint之后所要做的事情就是通知，通知分为前置通知，后置通知，异常通知，最终通知，环绕通知（切面要完成的功能） Introduction（引介）：引介是一种特殊的通知在不修改类代码的前提下，Introduction可以在运行期为类动态添加一些方法或Field。 Target（目标对象）：代理的目标对象（要增强的类）Weaving（织入）：是把增强应用到目标的过程，把advice应用到target的过程Proxy（代理）：一个类被aop治入增强后，就产生一个结果代理类Aspect（切面）：是切入点和通知（引介）的结合 术语解读： 4.Spring的aop操作 在spring里面进行aop操作，使用aspectj实现① aspectj不是spring的一部分，和spring一起使用进行aop操作② spring2.0以后增加了对AspectJ的支持 使用aspectj实现aop有两种方式① 基于aspectj的xml配置② 基于aspectj的注解方式 aop操作准备 除了导入基本的jar包之外，还需要导入aop相关的jar包 创建spring核心配置文件，导入aop的约束 使用表达式配置切入点 切入点：实际增强的方法 常用表达式① execution（cn.itcast.aop.Book.add(..)）② execution( cn.itcast.aop.Book.(..))③ execution( .(..))④ 匹配所有save开头的方法 execution(save(..))aop基于Aspectj配置实现： 注：环绕通知的增强 //环绕通知 public void aroundTest(ProceedingJoinPoint proceedingJoinPoint){ //方法之前 System.out.println(\"方法之前。。。\"); //执行被增强的方法 proceedingJoinPoint.proceed(); //方法之后 System.out.println(\"方法之后。。。\"); } log4J介绍 通过log4j可以看到程序运行过程中更详细的信息 使用log4j查看日志 使用① 导入log4j的jar包⑤ 复制log4j配置文件，复制到src下面 设置日志级别 log4j.rootLogger=info,stdout① info：看到基本信息② debug：看到更详细的信息 六. Spring整合web项目演示 演示为题（1） action调用service，service调用dao（2） 每次访问action时候，都会加载spring配置文件 解决方法：（1） 在服务器启动时候，创建俺对象加载配置文件（2） 底层使用监听器、ServletContext对象 在spring里面不需要我们自己写代码实现，spring已经封装好了（1） 封装了一个监听器，只需要配置监听器就可以了（2） 配置监听器之前做事情：导入spring整合web项目jar包在web.xml中配置: &lt;listener> &lt;listener-class>org.springframework.web.context.ContextLoaderListener&lt;/listener-class> &lt;/listener> &lt;!-- 指定加载spring配置文件位置 --> &lt;context-param> &lt;param-name>contextConfigLocation&lt;/param-name> &lt;param-value>classpath*:spring-context.xml&lt;/param-value> &lt;/context-param> 基于aspectj的注解aop 使用注解方式实现aop操作① 创建对象 &lt;!-- 创建对象 --> &lt;bean id=\"book\" class=\"cn.itcast.aop.Book\">&lt;/bean> &lt;bean id=\"myBook\" class=\"cn.itcast.aop.MyBook\">&lt;/bean> ② 在spring核心配置文件中，开启aop操作 &lt;!-- 开启aop操作 --> &lt;aop:aspectj-autoproxy>&lt;/aop:aspectj-autoproxy> ③ 在增强类上面使用注解完成aop操作 七. Spring的jdbcTemplate操作 spring框架一站式框架（1） 针对javaee三层，每一层都有解决技术（2） 在dao层，使用jdbcTemplate spring对不同的持久化层技术都进行了封装（1） jdbcTemplate对jdbc进行了封装 jdbcTemplate使用和dbutils使用很相似，都数据库进行crud操作 增加① 导入jdbcTemplate的jar包② 创建对象，设置数据库信息③ 创建jdbcTemplate对象，设置数据源④ 调用jdbcTemplate对象里面的方法实现操作 修改，删除类似与增加，不做赘述 查找 查找区别与dbutils，返回结果集的处理类需要自己去实现，而dbutils则给出了不同的结果集处理类，而jdbcTemplate则需要自己去实现RowMapper（）接口来处理结果。dbutils中也有类似于RowMapper（）接口的接口为ResultSetHandler（），但是他也提供了不同的实现类，来处理不同的结果。 八. Spring事务管理 Spring事物管理两种方式（1） 编程式事务管理（不用）（2） 声明式事务管理 基于xml配置文件实现 基于注解实现 spring事务管理的api介绍 （1） spring针对不同的dao层框架，提供接口不同的实现类 （2） 配置事物管理器 搭建转账环境（1） 创建数据库表，添加数据（2） 创建service和dao类，完成注入关系 service层又叫业务逻辑层 dao层，单独对数据库操作，在dao层不添加业务 （3） 声明式事务管理（xml配置，麻烦不建议使用） 配置文件方式使用aop思想配置 （4） 声明式事务管理（注解） 配置事务管理器 配置事物注解 在要使用事务的方法所在类上面添加注解图示： 九. ssh框架的整合 ssh整合思想","categories":[{"name":"后端","slug":"后端","permalink":"http://blog.willhappy.cn/categories/后端/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.willhappy.cn/tags/java/"},{"name":"提升","slug":"提升","permalink":"http://blog.willhappy.cn/tags/提升/"}]},{"title":"Java入门","slug":"4_2016-11-20_Java初级知识(java001)","date":"2016-11-20T00:00:00.000Z","updated":"2024-06-01T13:17:35.408Z","comments":true,"path":"2016/11/20/4-2016-11-20-java-chu-ji-zhi-shi-java001/","link":"","permalink":"http://blog.willhappy.cn/2016/11/20/4-2016-11-20-java-chu-ji-zhi-shi-java001/","excerpt":"","text":"[toc] 一. 什么是java java编程语言是个简答/完全面向对象/分布式/解释性/健壮性/安全与系统无关/可移植性/高性能/多线程和动态得编程语言。 二. java体系 java SE java平台标准版 java EE java平台企业版 java ME java平台微型版 三. java开发环境 Eclipse myEclipse IntelliJ IDEA 四. java开发前提 java源代码是.java得纯文本文件，可以使用任何文本编辑气编写，单不可执行。JDK是java语言得开发包，可以将.java文件编译盛可执行得java程序可执行java程序需要JVM猜可以运行JRE包含了JVMJDK包含了JRE 注：JRE(java runtime environment,java运行环境),运行java程序所需要得环境得集合，包含JVM标准实现及java核心类库。仅能够完成java得运行，而无法对java进行编译/调试等。JDK（java development kit）是java语言得软甲开发工具包（SDK）,面向java开发者发布的java套件。JDK包含得基本组件包括：编译器/jar打包工具/javadoc文档生成器/debug调试器/头文件生成器/反汇编器/监控工具等。 五. 数据类型初阶 java定义了基本数据类型、引用数据类型和自定义数据类型。 本主题将介绍java的八种基本数据类型和引用数据类型中String类型 栈空间： a. 栈空间存取数据的效率搞。 b. 栈中的数据按“先进后出”的方式管理。 c. 栈空间存储空间较小，不能存放大量的数据。 d. JVM将基本类型的数据存放在栈空间。 堆空间： a. 堆空间存取数据的效率最低； b. 数据存放的位置随机分配； c. 堆空间存储数据的空间大，能存放大容量的数据。 六. 自动类型转换（1） byte-&gt;short-&gt;int-&gt;long-&gt;float-&gt;double（2） int和char类型的数据在某种情况下可以自动相互转换。 七. 通过Scanner从控制台获取数据（1） String next();作用：接受控制台输入的一个字符串，空格或回车作为一次输入数据的结束，所以不能将空格作为字符串接受。（2） String nextLine();作用：接受控制台输入的一个字符串，以回车作为输入数据的结束。（3） int nexInt();作用：接受控制台输入的一个int类型的数据。（4） double nextDouble();（5） boolean nextBoolean();（6） 从控制台输入char类型的数据Scanner类没有提供直接输入char类型的方法，可以通过charAt()方法从next()或nextLine()获取输入的字符。 char String.charAt(int index);作用：从字符串中获取指定下表的字符，下标从0开始。 八. 数组学习（实例：冒泡排序） /** * 正宗的冒泡排序 * 1.比较相邻的元素。如果第一个比第二个大，就交换他们两个。 * 2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 * 3.针对所有的元素重复以上的步骤，除了最后一个。 * 4.持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 */ int a[] = {78,34,12,64,5,4}; int temp = 0; for (int i = 0; i &lt; a.length-1; i++) { for (int j = 0; j &lt; a.length-1-i; j++) { //第i轮排序过后，最大数都会相应的放到后面，所以次数相应的减少i+1次 if (a[j]>a[j+1]) { temp = a[j]; a[j] = a[j+1]; a[j+1] = temp; } } } for (int i = 0; i &lt; a.length; i++) { System.out.println(a[i]); } 九. String字符串 实例化String对象 1）直接赋值的方式； 2）使用关键字new推荐使用直接赋值的方式，因为使用关键字new，会在堆内存中开辟空间存储字符串本身，另外开辟空间存储栈空间指向堆空间的对象。（可能表达不大准确，可看图）。 字符串的比较 “==” 比较的是地址 “equals”比较的是内容 字符串常用方法 a. toCharArray();字符串转换成数组 b. charAt();从字符串中取出指定位置的字符 c. getBytes();字符串与byte数组的转换 d. indexOf();过滤字符串中存在的字符，返回字符的当前位置 e. trim();去掉字符串的前后空格 f. subString()；从字符串中取出子字符串 g. toLowerCase(),toUpperCase();大小写转换 h. endsWith(),startWith();判断字符串的开头结尾字符 i. replace();替换String字符串中的一个字符 十. StringBuffer缓冲区，本身也是操作字符串的，但是与String不同，StringBuffer是可以更改的，而String内容是不可修改的。 StringBuffer stringBuffer = new StringBuffer(); stringBuffer.append(\"hello world!\"); for (int i = 0; i &lt; 100; i++){ stringBuffer.append(i); } System.out.print(stringBuffer.toString()); 同样的如果用String添加 String str = \"hello world!\"; for(int i = 0; i &lt; 100; i++){ str = str + i; } System.out.print(str); 说明：两种方法追加字符串输出的结果是相同的，但是执行的速度是不同的，相对来说，StringBuffer的执行速度更快一些，因为他只是在原先的字符位置进行修改，而String则需要每次改变都要开辟新的内存空间。 十一. StringBuilder 一个可变的字符序列，该类被设计作用StringBuffer的一个简易替换，用在字符串缓冲区被单个线程使用的时候。建议优先考虑该类，速度比StringBuffer要快。 但是如果涉及到线程安全方面，建议使用StringBuffer。 常用方法： append() insert() 十二. 异常处理 异常的格式 //伪代码 try{ 异常的语句； }catch(Exception e){ 异常的处理； }finally{ 一定会执行的代码； } 实例： int a = 10, b = 0 , temp = 0; try { temp = a/b; }catch (Exception e){ System.out.println(e); } System.out.println(temp); 输出为：java.lang.ArithmeticException: / by zero 0 常见异常 a. 数组越界异常：ArrayIndexOutOfBoundsException b. 数字格式化异常：NumberFormatException c. 算数异常：ArithmeticException d. 空指针异常：NullPointerException 十三. java面向对象中类和对象 方法的定义 static（静态方法）就是没有this的方法。 方法的重载：方法名称相同，返回类型，但是参数的类型和个数不同，通过传递参数的个数和类型不同来完成不同的功能。每个重载方法都必须有独一无二的参数列表。 对象的创建,如下所示 Class Person{ String name = null; int age = 0; } //声名并实例化对象 Person per = new Person(); 说明：Person per 创建栈内存per，使用new Person()开辟堆内存空间，栈内存的per指向对应的堆内存空间，堆内存空间存储name=null；age=0；对象创建的内存划分，如图： 构造器 构造器没有任何返回值，如果类中没有构造器，则编译器会自动帮你常见一个默认的构造器，如果已经定义了构造器（无论是否有参数），编译器都不会帮你自动创建默认的构造器。a. 格式： 访问修饰符 类名称（）{ 程序语句 } b. 注意点：（1）构造方法名称必须与类名一致（2）构造方法没有返回值 面向对象三大特征 a. 封装性对外部不可见 b. 继承扩展类的功能 c. 多态性方法的重载对象的多态 方法的递归调用 实例如下： public static void main(String[] args){ /** * 递归方法的调用 * 100+99+...+1 * 输出的值为5050 */ System.out.print(addNum(100)); } //静态方法 public static int addNum(int num) { if (num == 1) { return 1; } else { return num + addNum(num - 1); } } static关键字 由static修饰的变量成为静态变量，也称为类变量。 静态变量定义的位置时在方法之外。 静态变量与静态方法都是在类从磁盘加载至内存后被创建的，与类同时存在，同时消亡。 静态变量又称类的成员变量，在类中时全局变量，可以别类中的所有方法调用。 静态变量的值由jvm自动初始化。 使用static声名全局属性 使用static是声名的方法可以直接通过类名进行调用 使用static方法的时候，只能访问static声名的属性和方法，而非static声名的属性和方法时不能访问的。 匿名对象 匿名对象就是没有名字的对象，如果程序中只是用一次该对象，就可以使用匿名对象的方式。 实例: //学生类 class Student{ public void tell(){ System.out.print(\"Hello World!\"); } } public class test{ public static void main(String[] args){ /** * 匿名对象的使用 * 输出：Hello world! */ new Student().tell(); } } this关键字 表示类中的属性和调用方法 调用本类中的构造方法 表示当前对象 十四. java面向对象的基本特征：继承 继承的基本概念 扩展父类的功能 java中使用extends关键字完成继承 class 子类 extends 父类 {} 继承的限制 在java中只允许单继承 子类不能直接访问父类的私有成员 子类对象的实例化过程 a. 在子类对象实例化之前，必须先调用父类中的构造方法，之后调用子类构造方法示例图如下： A(实例化子类对象) -->|1.先调用父类构造| B(调用父类构造) A -->|2.再调用子类构造| C(调用子类构造) java方法重写与super关键字 在继承中，也存在这重写的概念，起始就是子类定义了和父类同名的方法 定义： 方法名称相同，返回值类型相同，参数也相同。 重写的限制： 被子类重写的方法不能拥有比父类方法更加严格的访问权限 访问权限： private&lt;default&lt;protected&lt;public private只能在当前类中进行访问，default在同一包下进行访问，public在整个工程下进行访问。 super关键字 强行调用父类的方法的执行 重写与重载区别 NO 区别点 重载 重写 1 单词 Overloading Overriding 2 定义 方法名称相同，参数的类型或个数不同 方法名称、参数的类型、返回值类型全部相同 3 访问权限 对权限没有要求 被重写的方法不能拥有比父类更加严格的权限 4 范围 发生在同一个类中 发生在继承中 十五. java面向对象-抽象类和接口 final关键字 final关键字在java中被称为完结器，表示最终的意思 final能声名类、方法、属性： 使用final声名的类不能被继承 使用final声名的方法不能别重写 使用final声名的变量变成常量，常量是不可以别修改的 抽象类 抽象类概念： 包含一个抽象方法的类就是抽象类 抽象方法： 声名而未被实现的方法，抽象方法必须使用abstract关键字声名 抽象类被子类继承，子类（如果不是抽象类，必须重写抽象类中的所有抽象方法） 定义格式： abstract class className{ 属性 方法 抽象方法 } 抽象类不能直接实例化，要通过其子类进行实例化 接口 接口是java中最重要的概念，接口可以理解为一种特殊的类，里面全部是有全局常量和公共的抽象方法组成。 接口的格式： interface interfaceName{ 全局常量 抽象方法 } 接口的实现也必须通过子类，使用关键字implements，而且接口是可以多实现的。 一个子类可以同时继承抽象类和实现接口 一个接口不能继承一个抽象类，但是却可以通过extends关键字同时继承多个接口，实现接口的多继承。实例：interface Inter3 extends Inter1,Inter2{} 接口和抽象类的访问修饰符 接口可以使用public或者默认访问修饰符，接口的方法只能使用public，属性可以使用public、static、final； 抽象类可以使用public或者默认的访问修饰符，抽象类的方法可以使用public、protected、默认的或private，属性可以是public、static、final、protected、private。 十六. java面向对象多态性 多态性 a. 多态性的体现： 方法的重载和重写 对象的多态性 b. 对象的多态性： 向上转型：程序会自动完成 父类 父类对象 = 子类实例 向下转型：强制类型转换 子类 子类对象 = （子类）父类实例 class A { public void tell1() { System.out.println(\"A====tell1\"); } public void tell2() { System.out.println(\"A====tell2\"); } } class B extends A { public void tell1() { System.out.println(\"B====tell1\"); } public void tell3() { System.out.println(\"B====tell3\"); } } public class Test1 { public static void main(String[] args) { /** * 向上转型 * 输出：B====tell1 * A====tell2 */ // B b = new B(); // A a = b; // a.tell1();//tell1重写,调用被重写之后的方法 // a.tell2(); /** * 向下转型 * 输出：B====tell1 * A====tell2 * B====tell3 */ A a = new B();//注意向下转型之前，先要向上转型 B b = (B) a; b.tell1(); b.tell2(); b.tell3(); } } c. 对象的多态的应用 class A1{ public void tell1(){ System.out.println(\"A1====tell1\"); } } class B1 extends A1{ public void tell2(){ System.out.println(\"B1====tell2\"); } } class C1 extends A1{ public void tell3(){ System.out.println(\"C1====tell3\"); } } class D1 extends A1{ public void tell4(){ System.out.println(\"D1====tell4\"); } } public class Test2 { public static void main(String[] args){ /** * 多态的应用 * 输出：A1====tell1 * A1====tell1 * A1====tell1 */ say(new B1()); say(new C1()); say(new D1()); } public static void say(A1 a1){ a1.tell1(); } } instanceof关键字 在java中可以使用instanceof关键字判断一个对象到底是不是一个类的实例 抽象类的应用 接口的应用 interface USB { void start(); void stop(); } class C { public static void work(USB u) { u.start(); System.out.println(\"工作中\"); u.stop(); } } class USBDisk implements USB { @Override public void start() { System.out.println(\"u盘开始工作\"); } @Override public void stop() { System.out.println(\"u盘停止工作\"); } } class Printer implements USB { @Override public void start() { System.out.println(\"打印机开始工作\"); } @Override public void stop() { System.out.println(\"打印机停止工作\"); } } public class Test3 { public static void main(String[] args) { /** * 接口的应用 * 输出：u盘开始工作 * 工作中 * u盘停止工作 * 打印机开始工作 * 工作中 * 打印机停止工作 */ C.work(new USBDisk()); C.work(new Printer()); } } 十七. java面向对象之泛型 知识泛型 a. 泛型是在JDK1.5之后增加的新功能，泛型（Generic） b. 泛型可以解决数据类型的安全性问题，他主要的原理，是在类声名的时候通过一个标识标识类中某个属性的类型或者是某个方法的返回值及参数类型。 c. 格式： 访问权限 class 类名称&lt;泛型，泛型...>{ 属性 方法 } d. 对象的创建 类名称&lt;具体类型&gt; 对象名称 = new 类名称&lt;具体类型&gt;(); 构造方法中使用泛型 构造方法可以为类中的属性初始化，那么如果类中的属性通过泛型指定，而又需要通过构造方法设置属性内容的时候，那么构造方法的定义与之前并无不同，不需要向声名类那样指定泛型。 设置多个泛型 class Gen&lt;T,K>{ private T take; private K key; } //实例化 Gen&lt;Integer,String> g = new Gen&lt;Integer,String>(); 通配符 可以使用？作为通配符 泛型接口 格式：interface 接口名称&lt;泛型标识&gt;{} 泛型方法 泛型方法中可以定义泛型参数，此时，参数的类型就是传入数据类型。 格式： 访问权限 &lt;泛型标识&gt; 泛型标识 方法名称（[泛型标识 参数名称]） 泛型数组 public class Test3{ public static void main(String[] args){ Integer arr[] = {1,2,3,4}; tell(arr); } public static &lt;T>void tell(T arr[]){ for(int i = 0; i &lt; arr.length; i++){ System.out.println(arr[i]); } } } 十八. 常用javaAPI详解 java本地文件操作 文件和文件夹的创建、删除、重命名 文件属性的读取 文件属性的设置 遍历文件夹实例如下： public class Test5 { public static void main(String[] args){ printFiles(new File(\"E:\\\\workspace\\\\interlIDEA\\\\JavaStudy\"),1); } public static void printFiles(File dir,int tab){ if(dir.isDirectory()){ File next[] = dir.listFiles(); for (int i = 0; i &lt; next.length; i++) { for (int j = 0; j &lt; tab; j++) { System.out.print(\"|--\"); } System.out.println(next[i].getName()); if (next[i].isDirectory()) { printFiles(next[i],tab + 1); } } } } } 文件的简单读取 public class Test6 { public static void main(String[] args){ File file = new File(\"text.txt\"); if (file.exists()) { System.out.println(\"exist\"); try { FileInputStream fis = new FileInputStream(file); InputStreamReader isr = new InputStreamReader(fis,\"UTF-8\"); BufferedReader br = new BufferedReader(isr); String line; while ((line = br.readLine())!=null){ System.out.println(line); } br.close(); isr.close(); fis.close(); }catch (FileNotFoundException e){ e.printStackTrace(); }catch (UnsupportedEncodingException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } try { File newFile = new File(\"newtext.txt\"); FileOutputStream fos = new FileOutputStream(newFile); OutputStreamWriter osw = new OutputStreamWriter(fos,\"UTF-8\"); BufferedWriter bw = new BufferedWriter(osw); bw.write(\"我深爱这你\\n\"); bw.write(\"我深深的爱着\\n\"); bw.close(); osw.close(); fos.close(); System.out.println(\"写入完成！\"); }catch (UnsupportedEncodingException e) { e.printStackTrace(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } } 十九. java的日期与时间处理实例： public class Test8 { public static void main(String[] args) throws ParseException { /** * 时间实例： * 设定女朋友的生日，并在提前2个星期的星期六提醒 */ //1.设定生日，String String birthday = \"2015-05-30\"; //2.将String类型转换为日期 SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd\"); Date date = simpleDateFormat.parse(birthday); //3.对日期进行计算 Date spec = prepareBirthday(date); //4.将计算后的结果，转换为String类型，输出 String str2 = simpleDateFormat.format(spec); System.out.println(birthday + \"提前2周的周六为：\" + str2); } /** * 传入一个日期，计算出该日期的2个星期前的周六的日期 * * @param birthdayDate * @return */ public static Date prepareBirthday(Date birthdayDate) { Calendar calendar = new GregorianCalendar(); calendar.setTime(birthdayDate);//传入的date日期，转换为calendar calendar.add(Calendar.WEEK_OF_MONTH, -2);//提前2周 calendar.set(Calendar.DAY_OF_WEEK, Calendar.SATURDAY);//调整为当前星期的周六 return calendar.getTime(); } } 二十. java工程结构管理 Build Path事指定java工程所包含的额资源属性集合，在一个成熟的java工程中，不仅仅有自己编写的源代码，还需要引用系统运行库（JRE），第三方的功能扩展库，工作空间中的其他工程，甚至外部的类文件，所有这些资源都是被这个工程所依赖的，并且背引用后，才能够将工程编译成功，而build path就是用来配置和管理对这些资源的引用的。Build Path一般包括： JRE运行时库 第三方功能扩展库（*.jar格式文件） 其他工程 其他的源代码或class文件 二十一. jsp基础 基本介绍 jsp起源 jsp是一门脚本语言 jsp拥有java语言的所有特性 jsp运行于jsp容器中（jsp容器有：Tomcat，jetty） jsp会被转换成servlet web开发基础 HTML 1.HTML==HyperText Markup Language 2.由服务器返回，由浏览器呈现 URI/URL/URN URL==Uniform Resource Locator 代表资源的地址信息 &lt;协议&gt;//&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt; URN==Uniform Resource Name 代表某个资源独一无二的名称 URI==Uniform Resource Identifier 用于标识某一互联网资源名称的字符串 HTTP协议简介 HTTP==HyperText Transfer Protocol 1990年提出 特点： 支持客户/服务器模式 灵活 无连接 无状态 方法|方法名|对应规范||-|-||GET|向特定的资源发出请求||POST|向指定资源提交数据进行处理请求| jsp基本语法 jsp程序段定义 输出： jsp代码注释 jsp编译指令和动作指令 说明：WEB-INF中的jsp就是无法通过地址栏访问的，所以安全。 访问web-inf下jsp资源的几种方式： 方法一：如果说你要访问这个文件夹中的jsp文件需要在项目的web.xml文件中去配置servlet格式差不多的配置就ok了 如下: &lt;servlet> &lt;servlet-name>runtain&lt;/servlet-name> &lt;jsp-file>/WEB-INF/INF.jsp&lt;/jsp-file> &lt;/servlet> &lt;servlet-mapping> &lt;servlet-name>runtain&lt;/servlet-name> &lt;url-pattern>/XXX&lt;/url-pattern> 访问地址:http://localhost:8080/runtain/xxx 即可访问jsp页面内容 方法二： 方法三: request.getRequestDispatcher(\"/WEB-INF/a.jsp\").forward(request, response); 怎么样让servlet访问web-inf下的网页或jsp文件呢？ 因为web-inf下,应用服务器把它指为禁访目录，即直接在浏览器里是不能访问到的。因些，可以让servlet进行访问，如web-inf下有a.jsp，则可以用request.getRequestDispatcher(&quot;/WEB-INF/a.jsp&quot;).forward(request,response);进行派遣访问但如果web-inf下有a.htm,则用request.getRequestDispatcher(&quot;/WEB-INF/a.htm&quot;).forward(request,response);则不能访问。一开始想不通，觉得怪。后来想想，jsp其实也是servlet,会自动编译的，于是work目录下会有/web-inf/a$jsp.class类型，于是有头绪了,让应用服务器能够编译.htm,如a$htm.class.抱有这个想法，开始动手. 在tomcat下的conf/web.xml，找到jsp的访问方式 &lt;servlet-mapping> &lt;servlet-name>jsp&lt;/servlet-name> &lt;url-pattern>*.jsp&lt;/url-pattern> &lt;/servlet-mapping> 于是在下面添加 &lt;servlet-mapping> &lt;servlet-name>jsp&lt;/servlet-name> &lt;url-pattern>*.htm&lt;/url-pattern> &lt;/servlet-mapping> &lt;servlet-mapping> &lt;servlet-name>jsp&lt;/servlet-name> &lt;url-pattern>*.html&lt;/url-pattern> &lt;/servlet-mapping> 随后，一切OK，此时可访问a.htm。a.html在work/web-inf/下者有a\\$htm.class, a\\$html.class 生成 编译指令： 动作指令： 说明：forward指令下面的内容不会被执行 说明：注意区分编译指令的include和动作指令的include的区别 对于静态包含，&lt;%@include%&gt;，中包含的文件，只是简单的嵌入到主文件中，就是在jsp页面转化成Servlet时才嵌入到主文件中，因为运行的结果是只生成了一个Servlet。而对于动态包含jsp:incude，如果被包含文件是动态的，那么就会生成两个Servlet，也就是被包含文件也要经过jsp引擎编译执行生成一个Servlet，两个Servlet通过request和reponse进行通信。如果被包含的文件是静态的，那么这种情况和&lt;%@include&gt;就很相似，只生成了一个Servlet，但是他们之间没有进行简单的嵌入，而依然是通过request和reponse进行的通信。 jsp内置对象 out对象 request对象 请求的方法名： 请求的资源： 请求使用的协议： 请求的服务器IP： 请求的服务器端口： 客户端IP地址： 客户端主机名： 表单提交来的值： response对象 exception对象 异常描述信息： exception对象的字符串描述： config对象 在web.xml中添加配置： &lt;servlet> &lt;servlet-name>config&lt;/servlet-name> &lt;jsp-file>/jsps/Test08/config.jsp&lt;/jsp-file> &lt;init-param> &lt;param-name>username&lt;/param-name> &lt;param-value>william&lt;/param-value> &lt;/init-param> &lt;init-param> &lt;param-name>password&lt;/param-name> &lt;param-value>123456&lt;/param-value> &lt;/init-param> &lt;/servlet> jsp中使用config获取： 用户名： 密码： page对象 session对象 sessionId: session的创建时间： session的最后访问时间： session的失效时间： application对象 服务器信息： 应用名称： 主机名称： pageContext对象 二十二. JDBC相关知识 数据库基础知识 数据库简介 关系数据模型 特点： 概念单一 规范化 二维表 术语： 关系 元祖 属性 属性域 主键 外键 数据库范式 1NF（原子性） 2NF（唯一性） 3NF（冗余行判断） mysql入门 sql功能：DDL、DML、DCL JDBC编程 JDBC（Java Data Base Connectivity） JDBC的组成：JDBC API/JDBC Driver API JDBC API：DriverManager/Connection/Statement/PreparedStatement/ResultSet JDBC Driver API；JDBC-ODBC bridge/部分java技术的本地API驱动程序/全部基于java技术的本地API驱动程序/全部基于java技术的本地协议驱动程序 JDBC程序编写步骤： A(JDBC编程流程) -->B(1.加载驱动) A -->C(2.打开连接) A -->D(3.执行查询) A -->E(4.处理结果) A -->F(5.清理环境) 实例： public static void main(String[] args){ String sql = \"select * from tbl_user\"; Connection conn = null; Statement st = null; ResultSet rs = null; try { //获取数据库连接 Class.forName(\"com.mysql.jdbc.Driver\"); conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/jsp_db\",\"root\",\"\"); st = conn.createStatement(); rs = st.executeQuery(sql); while(rs.next()){ System.out.print(rs.getInt(\"id\")+\" \"); System.out.print(rs.getString(\"name\")+\" \"); System.out.print(rs.getString(\"password\")+\" \"); System.out.print(rs.getString(\"email\")+\" \"); System.out.println(); } }catch (Exception e){ e.printStackTrace(); }finally{ try { rs.close(); }catch (Exception e2){} try { st.close(); }catch (Exception e3){} try { conn.close(); }catch (Exception e4){} } } 事务处理 事务的四个特性：原子性/一致性/隔离性/持久性 事务实例： public class TransactionTest { public static Connection getConnection(){ Connection conn = null; try { Class.forName(\"com.mysql.jdbc.Driver\"); conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/jsp_db\",\"root\",\"\"); }catch (Exception e){ e.printStackTrace(); } return conn; } public static void insertUserData(Connection conn) throws SQLException{ String sql = \"insert into tbl_user(id,name,password,email) values (10,'Tom','123456','tom@gmail.com')\"; Statement st = conn.createStatement(); int count = st.executeUpdate(sql); System.out.println(\"向用户表中插入了\" + count + \"条记录\"); //conn.close(); } public static void insertAddressData(Connection conn) throws SQLException{ String sql = \"insert into tbl_address(id,city,country,user_id) values (1,'shanghai','China','10')\"; Statement st = conn.createStatement(); int count = st.executeUpdate(sql); System.out.println(\"向地址表中插入了\" + count + \"条记录\"); //conn.close(); } public static void main(String[] args){ Connection conn = null; try { conn = getConnection(); conn.setAutoCommit(false); insertUserData(conn); insertAddressData(conn); conn.commit(); } catch (SQLException e) { System.out.println(\"=========捕获到sql异常==========\"); e.printStackTrace(); try { conn.rollback(); System.out.println(\"=========事务回归==========\"); } catch (Exception e1) { e1.printStackTrace(); } }finally{ try { if (conn!=null) { conn.close(); } } catch (Exception e2) { e2.printStackTrace(); } } } } JDBC编程优化 二十三. Servlet概述A(Servlet) --> B(Server+Applet) A --> C(特殊的java类) A --> D(Servlet与HTTP) servlet处理流程分析 生命周期：加载类-&gt;调用init()方法初始化-&gt;处理请求-&gt;销毁 有关servlet的详细信息：http://www.cnblogs.com/xuekyo/archive/2013/02/24/2924072.htm servlet过滤器 编码转换过滤器 权限校验过滤器 二十四. java基础知识面试指导本课时巩固知识点： java关键字及功能 java数据类型 java基本运算符 java基本程序控制语句 java数组 java关键字 熟知java常用关键字的拼写及功能 所有的ajva关键字都是小写的 goto和const时保留关键字，在java中没有使用 true，false，null不是严格意义上的关键字，而是文字常量（literals） 程序遇到return语句将不会执行finally语句 java数据类型 8种数据类型：byte，short，int，long，float，double，char，boolean 8种基本数据类型占用的字节长度 3种引用数据类型：类，接口，数组 8种基本数据类型对应的包装类，被final修饰，不可被继承 String和StringBuffer类也是被final修饰 java基本运算符 java基本运算符的种类 java基本运算符的优先级 单目，双目，三目运算符的划分 运算符操作过程种的类型转换问题 java程序流程控制语句 三种执行方式：顺序结构，选择结构和循环结构 条件选择语句：if…else,switch…case 循环语句：while,do…while,for 注意while和do…while的区别，for的三个循环条件 switch支持的数据类型有：byte，short，char，int以及枚举类型 java数组 java数组的概念和特点 一维数组和二位数组的声名 数组初始化的两种方式：静态初始化和动态初始化 动态初始化数组必须给出长度，否则将报”缺少数组维数”的错误 动态初始化二维数组时，可以只指定第一位的长度而不指定第二维的 当数组包含的元素时引用数据类型时，必须为每个元素实例化，否则会出现空指针异常 常见java基础知识陷阱 浮点数运算陷阱 float和double不能进行精确运算 不能简单的使用四舍五入的方法解决上述问题 可以使用BigDecimal类解决 自增、自减运算符陷阱 ++和–运算符的规则 i++和++i的区别 进行增量或减量运算常见错误 字符和字符串陷阱 字符串与字符拼接规则 转义字符使用规则 返回与退出陷阱 return与try…catch语句 exit()函数与try…catch语句 实例：谈谈final，finally，finalize的区别？答：final—修饰符（关键字） finally—再异常处理时提供finally块来执行任何清除操作 finalize—方法名 二十五. java面向对象面试指导 java面向对象必会知识点 面向对象的特点 封装 继承 多态面向对象程序涉及方法的优点：可重用性，可扩展性，可管理性 类与对象知识点 类与对象的概念 类方法的特点 匿名对象 构造函数与构造代码块 接口 Object 变量相关知识点： 成员变量与局部变量 实例变量与类变量 静态变量 变量的声名周期 java面向对象知识点精华 抽象、封装、继承、多态是面向对象程序设计中的四个特点。 面向对象的软件开发大体分为：面向对象的分析，面向对象的设计，面向对象的实现。 面向对象程序设计方法的优点是：可重用性，可扩展性，可管理性。 类的定义：class前的修饰符分为访问控制修饰符和非访问控制修饰符两大类。访问控制修饰符包括public和private，非访问控制符包括abstract（抽象），final（最终）。 final类是最终类，是不能有子类的类，abstract和final不能同时修饰一个类，因为抽象类本身是没有具体对象的，需要派生出子类后在创建子类对象，而最终类不可能有子类。 创建对象的格式：类名 对象名 = new 构造方法（参数）；注意前面是类名后面是构造方法。 如果class前面由public修饰符，则默认的构造方法的前面也应该有public修饰符。 类中有static修饰的域或方法，可用类名或对象名访问，否则只能用对象名访问。 修饰域的访问控制符可以是：public，private，protected，private protected。非访问控制符可以是：static，final，volatile（易失域）。 类变量的最本质的特点是：他们是类的域，不属于任何一个类的具体对象实例。 局部变量是方法体内声名的，只有当方法被调用时他们才存在，因而只能在本方法内使用，不存在访问控制符，也不能声名为静态变量（static），但可以声名为final变量，局部变量必须初始化。 修饰方法的访问控制符可以是：public，private，protected，private protected；修饰方法的非访问控制符可以是：static，final，abstract，native（本地方法），synchronized（同步方法）。 用static修饰的变量或方法都为类成员，类成员可以用类名或实例访问，实例成员只能用实例名来访问。 如果一个类中含有抽象方法，则此类为抽象类，如果抽象类的子类不为抽象类，则子类必须实现父类的所有抽象方法。抽象方法不能用静态方法和最终方法。抽象方法只有函数头的声名，而用分号来替代方法体，没有大括号。如abstract void abstractmethod(); this变量用在一个方法内部，指向当前对象，当前对象值得是调用当前正在执行的方法的那个对象，super变量是直接指向父类的构造方法，用来引用父类中的变量和方法。 如果要引用一个保重的多个类，可以用星号来代替。使用星号只能标识本层次的所有类，而不包括子层次下的类。经常需要用两条语句来引入两个层次的类：import java.awt.;improt java.awt.event.; 关于访问修饰符： 类中限定为public的成员可以被所有的类访问。 类中限定为private的成员只能被这个类本身访问。 类中限定为protected的成员可以被这类本身，他的子类，以及同一个包中的其他类访问。 用private protected修饰的成员可以被该类本身访问，也可以被类中的所有子类访问。 默认梵文控制符规定只能被同一个保重的类访问和引用，不能被其他包中的类访问。 注意： abstract和private，static，final，native不能并列修饰同一个方法。 abstract类中不能有private修饰的域和方法。 static方法不能处理非static的域。 重载方法的参数必须不同，或者是参数个数不同，或者是参数类型不同，重载的多个方法必须返回相同的数据类型。 在java中，一个类获取某个接口定义的功能并不是通过直接继承这个接口的属性和方法实现的，因为接口中的属性都是常量，接口的方法都是没有方法体的抽象方法，没有具体定义操作。 java面向对象面试案例解析 实例：接口是否可以继承接口？抽象类是否可以实现接口？抽象类是否可以继承实体类？答：接口可以继承接口。抽象类可以实现接口，抽象类可继承实体类，但前提是实体类必须有明确的构造函数。 二十六. jsp和servlet面试指导 jsp与servlet必会知识点 http://www.jikexueyuan.com/course/1340.html jsp知识精华 Servlet知识点精华 jsp和servlet面试案例 二十七. mysql初级面试指导http://www.jikexueyuan.com/course/1362_3.html mysql初级必会知识 sql语句 sql的增删查改基本操作 sql的条件查询 查询中的order by 查询中group by和having子句 子查询 JDBC必会知识点 mysql与jdbc知识点精华 mysql与jdbc面试案例","categories":[{"name":"后端","slug":"后端","permalink":"http://blog.willhappy.cn/categories/后端/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://blog.willhappy.cn/tags/基础/"},{"name":"Java","slug":"Java","permalink":"http://blog.willhappy.cn/tags/Java/"}]},{"title":"jQuery.form和jQuery.validate的使用","slug":"3_2015-11-20_jQuery.formANDjQuery.validate","date":"2015-11-20T00:00:00.000Z","updated":"2024-06-01T13:17:35.408Z","comments":true,"path":"2015/11/20/3-2015-11-20-jquery.formandjquery.validate/","link":"","permalink":"http://blog.willhappy.cn/2015/11/20/3-2015-11-20-jquery.formandjquery.validate/","excerpt":"","text":"[toc] jquery.form的两种提交方式方式1：ajaxFormajaxForm方式必须先绑定表单，它一般在$(document).ready(function(){})中定义，他能让表单在不刷新页面的情况下post到目标，例： $(document).ready(function(){ $('#updateForm').ajaxForm(function(){ alert(\"ajaxForm提交完成\"); }); }); 方式2：ajaxSubmitajaxSubmit方式是以相应事件来通过ajax方式提交表单，比如单击某个按钮来触发该表单的提交，例： $('#btnTest').on('click',function(){ $('#updateForm').ajaxSubmit(function(){ alert(\"ajaxForm提交完成！\"); }); }); jquery.validate + jquery.form提交的三种方式方式1通过jquery.validate的submintHandler选项，即当表单通过验证时执行回调函数，在这个回调函数中通过jquery.form来提交表单； 方式2通过jquery.form的beforeSubmit，即在提交表单前执行回调函数，这个函数如果返回true，则提交表单，如果返回false，则终止提交表单，根据jquery.validate插件的valid()方法，可以通过jquery.form提交表单时来对表单进行验证； 方式3通过jquery.validate的validate()方法，这个方法的好处是对表单验证的控制更加自由。","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.willhappy.cn/categories/前端/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://blog.willhappy.cn/tags/jQuery/"}]},{"title":"GitHub+Hexo搭建个人博客","slug":"2_2015-07-24_hexoCreate","date":"2015-07-24T00:00:00.000Z","updated":"2024-06-01T13:17:35.408Z","comments":true,"path":"2015/07/24/2-2015-07-24-hexocreate/","link":"","permalink":"http://blog.willhappy.cn/2015/07/24/2-2015-07-24-hexocreate/","excerpt":"看到同学使用github+hexo搭建了属于自己的博客，眼馋，弄了好久了，感觉有点眼高手低了，一直没来得及写一下自己搭建的流程，心血来潮，下边来简单介绍下搭建流程，也方便自己以后review，也可以和大家共享交流技术问题。可以关注我的blog, 地址：http://blog.willhappy.cn","text":"看到同学使用github+hexo搭建了属于自己的博客，眼馋，弄了好久了，感觉有点眼高手低了，一直没来得及写一下自己搭建的流程，心血来潮，下边来简单介绍下搭建流程，也方便自己以后review，也可以和大家共享交流技术问题。可以关注我的blog, 地址：http://blog.willhappy.cn [toc] 1.hexo介绍Hexo简介： Hexo是一个基于node.js快速，简介且高效的博客框架，可以将Markdown文件快速的生成静态网页，托管到github pages上。–《摘自Judas的hexo博客》 2.搭建前准备所需软件 git: http://git-scm.com/ node.js：http://nodejs.org/ 运行 Git-2.7.0.2-64-bit.exe，安装完成后，验证git安装是否成功： git --version 若出现git的版本号级表示安装成功，即 git version 2.7.0.windows.2 运行 node-v5.7.0-x64.msi，安装完成后，验证node.js是否安装成功，在git bash中执行： npm -v 若出现版本号，即代表成功，如： 1.4.3 3.安装hexo 可以先创建一个文件夹，命名随自己，这里假设命名为hexo，在hexo目录下，打开git bash，执行： npm install -g hexo //安装hexo 安装成功，继续执行命令进行hexo初始化： hexo init //hexo初始化 网速决定你的等待时间，可能需要几分钟，成功后会在hexo目录下生成相关目录。 现在，我们就可以启动hexo本地服务，命令： hexo s 注意（踩过的坑）： ERROR Local hexo not found in E:\\GitHub\\hexo 出现这个错误的原因可能是：仔细观察是hexo的生成目录中缺少了node_modules文件夹，所以这个文件夹没有更新上去，可以继续在git bash中执行: npm install 重新安装以后，继续执行：hexo s 即可。 现在可以使用浏览器访问：http://localhost:4000/。-在git bash中按Ctrl+C即可停止hexo服务。现在，我们便完成了静态博客的搭建。 4.书写blog文章 可以在git bash中使用命令来新建文件 hexo new \"newBlog\" //新建文章 然后来写文章内容，但是这样过于麻烦，因为hexo 博客是支持markdown语法格式的，我们可以使用相关的编辑器编写好md文档后，将其放在hexo目录下的\\source_posts文件夹下，此文件夹下已经有了一个hello-world.md文件。然后我们执行： hexo g //生成静态页面 重新生成一下静态页面，然后执行hexo s启动服务。通过http://localhost:4000/， 可以访问我们书写了新文章的博客了。 5.配置到GitHub到这里，我们只能通过自己启动本地服务去访问博客，别人访问不到我们的blog网站，下面介绍如何将hexo部署到github pages上，可实现任何人都可以访问自己的blog文章。 首先，在github上创建一个特殊的仓库，仓库名称为： 用户名.github.io 然后在hexo目录下找到_config.yml文件，打开在最后修改如下代码： deploy: type: git repo: https://github.com/用户名/用户名.github.io.git branch: master 最后，在git bash中执行命令，提交到github： hexo d 如果不出意外的话，在浏览器中可以通过http://用户名.github.io/ 来访问你的博客了。 hexo博客整体命令操作流程图： 6.主题修改 在这里 https://github.com/hexojs/hexo/wiki/Themes 挑选好我们心动的主题。 在hexo目录下，使用git bash 执行命令： git clone 主题地址 下载好主题后，同样在hexo目录下打开配置文件: _config.yml，把对应的主题目录名改下： theme: 主题名称 更改好主题目录名后 我们执行hexo g重新生成下静态页面，然后hexo s启动本地服务，重新访问：http://localhost:4000/，查看新主题的效果。 确认无误后，我们执行 hexo d 上传到github，最后通过 用户名.github.io访问查看最终效果。 7.hexo 相关命令hexo new page\"pageName\" 新建页面 cls 清屏 hexo clean 清理项目 hexo g(generate) 生成静态页面至public目录 hexo s(server) 开启预览访问端口 hexo d(deploy) 将.deploy目录部署到GitHub hexo help 查看帮助 hexo version 查看Hexo的版本 8.绑定域名参考文章：https://blog.csdn.net/xiangzhihong8/article/details/53355036可以访问：http://blog.willhappy.cn 9.更多博客网站的主题优化，插件应用，博客文章书写技巧能相关内容敬请期待。。。也可以关注hexo官方网站：hexo.io","categories":[{"name":"通用","slug":"通用","permalink":"http://blog.willhappy.cn/categories/通用/"}],"tags":[{"name":"Github","slug":"Github","permalink":"http://blog.willhappy.cn/tags/Github/"},{"name":"hexo","slug":"hexo","permalink":"http://blog.willhappy.cn/tags/hexo/"}]},{"title":"Hello World","slug":"1_2015-05-23_hello-world","date":"2015-05-23T00:00:00.000Z","updated":"2024-06-01T13:17:35.408Z","comments":true,"path":"2015/05/23/1-2015-05-23-hello-world/","link":"","permalink":"http://blog.willhappy.cn/2015/05/23/1-2015-05-23-hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. [toc] Quick StartCreate a new posthexo new \"My New Post\" More info: Writing Run serverhexo server More info: Server Generate static fileshexo generate More info: Generating Deploy to remote siteshexo deploy More info: Deployment","categories":[{"name":"通用","slug":"通用","permalink":"http://blog.willhappy.cn/categories/通用/"}],"tags":[{"name":"兴趣","slug":"兴趣","permalink":"http://blog.willhappy.cn/tags/兴趣/"}]}]}